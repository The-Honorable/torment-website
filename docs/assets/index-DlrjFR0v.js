const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/cube-recipes-2S7hyrHr.js","assets/debounce-DlM2vs2L.js","assets/filter-helpers-018iK1be.js","assets/uniques-BEcVqnBA.js","assets/item-type-filters-DhJkOFOx.js","assets/character-classes-LLAbBzNg.js","assets/damage-types-Du-j2Hbt.js","assets/uniques-Gzdpaqtq.js","assets/sets-DKIF3Nkp.js","assets/sets-C2BmTZpX.js","assets/runewords-WhMd1zXd.js","assets/runewords-B5RPaBdT.js","assets/grail-DDDBTxvt.js","assets/bases-BbXlLkHV.js","assets/affixes-DIWt--ce.js"])))=>i.map(i=>d[i]);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function initializeTC39Metadata() {
  Symbol.metadata ??= Symbol.for("Symbol.metadata");
}
const Metadata = {
  get(key, type) {
    return type[Symbol.metadata]?.[key];
  },
  define(value, type, ...keys) {
    let metadata = Object.getOwnPropertyDescriptor(type, Symbol.metadata)?.value;
    if (metadata == null) {
      Object.defineProperty(type, Symbol.metadata, { value: metadata = /* @__PURE__ */ Object.create(null), enumerable: true, configurable: true, writable: true });
    }
    const length = keys.length;
    switch (length) {
      case 0:
        throw new Error("At least one key must be provided");
      case 1:
        metadata[keys[0]] = value;
        return;
      case 2:
        metadata[keys[0]] = metadata[keys[1]] = value;
        return;
      default: {
        for (let i = 0; i < length; ++i) {
          metadata[keys[i]] = value;
        }
        return;
      }
    }
  },
  has(key, type) {
    const metadata = type[Symbol.metadata];
    return metadata == null ? false : key in metadata;
  },
  delete(key, type) {
    const metadata = type[Symbol.metadata];
    if (metadata == null)
      return;
    Reflect.deleteProperty(metadata, key);
    return;
  }
};
const objectFreeze$1 = Object.freeze;
const objectAssign$1 = Object.assign;
const safeString$2 = String;
const getMetadata$2 = Metadata.get;
const defineMetadata$2 = Metadata.define;
const isPromise = (v) => v instanceof Promise;
const isArray = (v) => v instanceof Array;
const isSet = (v) => v instanceof Set;
const isMap = (v) => v instanceof Map;
const isObject = (v) => v instanceof Object;
function isObjectOrFunction(value) {
  return typeof value === "object" && value !== null || typeof value === "function";
}
const isFunction = (v) => typeof v === "function";
const isString = (v) => typeof v === "string";
const isSymbol = (v) => typeof v === "symbol";
const isNumber = (v) => typeof v === "number";
const createLookup$1 = () => /* @__PURE__ */ Object.create(null);
const areEqual = Object.is;
const createMappedError$4 = (code, ...details) => {
  const paddedCode = safeString$2(code).padStart(4, "0");
  const message = getMessageByCode$4(code, ...details);
  const link = `https://docs.aurelia.io/developer-guides/error-messages/0001-to-0023/aur${paddedCode}`;
  return new Error(`AUR${paddedCode}: ${message}\\n\\nFor more information, see: ${link}`);
};
const errorsMap$4 = {
  [
    1
    /* ErrorNames.no_registration_for_interface */
  ]: `No registration for interface: '{{0}}'`,
  [
    2
    /* ErrorNames.none_resolver_found */
  ]: `'{{0}}' was registered with "none" resolver, are you injecting the right key?`,
  [
    3
    /* ErrorNames.cyclic_dependency */
  ]: `Cyclic dependency found: {{0}}`,
  [
    4
    /* ErrorNames.no_factory */
  ]: `Resolver for {{0}} returned a null factory`,
  [
    5
    /* ErrorNames.invalid_resolver_strategy */
  ]: `Invalid resolver strategy specified: {{0}}. Did you assign an invalid strategy value?`,
  [
    6
    /* ErrorNames.unable_auto_register */
  ]: `Unable to autoregister dependency: {{0}}`,
  [
    7
    /* ErrorNames.resource_already_exists */
  ]: `Resource key "{{0}}" already registered`,
  [
    8
    /* ErrorNames.unable_resolve_key */
  ]: `Unable to resolve key: {{0}}`,
  [
    9
    /* ErrorNames.unable_jit_non_constructor */
  ]: `Attempted to jitRegister something that is not a constructor: '{{0}}'. Did you forget to register this resource?`,
  [
    10
    /* ErrorNames.no_jit_intrinsic_type */
  ]: `Attempted to jitRegister an intrinsic type: "{{0}}". Did you forget to add @inject(Key)`,
  [
    11
    /* ErrorNames.null_resolver_from_register */
  ]: `Invalid resolver, null/undefined returned from the static register method.`,
  [
    12
    /* ErrorNames.no_jit_interface */
  ]: `Attempted to jitRegister an interface: {{0}}`,
  [
    13
    /* ErrorNames.no_instance_provided */
  ]: `Cannot call resolve '{{0}}' before calling prepare or after calling dispose.`,
  [
    14
    /* ErrorNames.null_undefined_key */
  ]: `Key cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?A common cause is circular dependency with bundler, did you accidentally introduce circular dependency into your module graph?`,
  [
    15
    /* ErrorNames.no_construct_native_fn */
  ]: `'{{0}}' is a native function and cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`,
  [
    16
    /* ErrorNames.no_active_container_for_resolve */
  ]: `There is not a currently active container to resolve "{{0}}". Are you trying to "new Class(...)" that has a resolve(...) call?`,
  [
    17
    /* ErrorNames.invalid_new_instance_on_interface */
  ]: `Failed to instantiate '{{0}}' via @newInstanceOf/@newInstanceForScope, there's no registration and no default implementation, or the default implementation does not result in factory for constructing the instances.`,
  [
    18
    /* ErrorNames.event_aggregator_publish_invalid_event_name */
  ]: `Invalid channel name or instance: '{{0}}'.`,
  [
    19
    /* ErrorNames.event_aggregator_subscribe_invalid_event_name */
  ]: `Invalid channel name or type: {{0}}.`,
  [
    20
    /* ErrorNames.first_defined_no_value */
  ]: `No defined value found when calling firstDefined()`,
  [
    21
    /* ErrorNames.invalid_module_transform_input */
  ]: `Invalid module transform input: {{0}}. Expected Promise or Object.`,
  [
    22
    /* ErrorNames.invalid_inject_decorator_usage */
  ]: `The @inject decorator on the target ('{{0}}') type '{{1}}' is not supported.`,
  [
    23
    /* ErrorNames.resource_key_already_registered */
  ]: `Resource key '{{0}}' has already been registered.`
};
const getMessageByCode$4 = (name2, ...details) => {
  let cooked = errorsMap$4[name2];
  for (let i = 0; i < details.length; ++i) {
    cooked = cooked.replace(`{{${i}}}`, String(details[i]));
  }
  return cooked;
};
const logError = (...args) => globalThis.console.error(...args);
const isArrayIndex = /* @__PURE__ */ (() => {
  const isNumericLookup = {};
  let result = false;
  let length = 0;
  let ch = 0;
  let i = 0;
  return (value) => {
    switch (typeof value) {
      case "number":
        return value >= 0 && (value | 0) === value;
      case "string":
        result = isNumericLookup[value];
        if (result !== void 0) {
          return result;
        }
        length = value.length;
        if (length === 0) {
          return isNumericLookup[value] = false;
        }
        ch = 0;
        i = 0;
        for (; i < length; ++i) {
          ch = value.charCodeAt(i);
          if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
            return isNumericLookup[value] = false;
          }
        }
        return isNumericLookup[value] = true;
      default:
        return false;
    }
  };
})();
const baseCase = /* @__PURE__ */ (function() {
  const isDigit = objectAssign$1(createLookup$1(), {
    "0": true,
    "1": true,
    "2": true,
    "3": true,
    "4": true,
    "5": true,
    "6": true,
    "7": true,
    "8": true,
    "9": true
  });
  const charToKind = (char) => {
    if (char === "") {
      return 0;
    }
    if (char !== char.toUpperCase()) {
      return 3;
    }
    if (char !== char.toLowerCase()) {
      return 2;
    }
    if (isDigit[char] === true) {
      return 1;
    }
    return 0;
  };
  return (input, cb) => {
    const len = input.length;
    if (len === 0) {
      return input;
    }
    let sep = false;
    let output = "";
    let prevKind;
    let curChar = "";
    let curKind = 0;
    let nextChar2 = input.charAt(0);
    let nextKind = charToKind(nextChar2);
    let i = 0;
    for (; i < len; ++i) {
      prevKind = curKind;
      curChar = nextChar2;
      curKind = nextKind;
      nextChar2 = input.charAt(i + 1);
      nextKind = charToKind(nextChar2);
      if (curKind === 0) {
        if (output.length > 0) {
          sep = true;
        }
      } else {
        if (!sep && output.length > 0 && curKind === 2) {
          sep = prevKind === 3 || nextKind === 3;
        }
        output += cb(curChar, sep);
        sep = false;
      }
    }
    return output;
  };
})();
const camelCase = /* @__PURE__ */ (function() {
  const cache2 = createLookup$1();
  const callback = (char, sep) => {
    return sep ? char.toUpperCase() : char.toLowerCase();
  };
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = cache2[input] = baseCase(input, callback);
    }
    return output;
  };
})();
const pascalCase = /* @__PURE__ */ (function() {
  const cache2 = createLookup$1();
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = camelCase(input);
      if (output.length > 0) {
        output = output[0].toUpperCase() + output.slice(1);
      }
      cache2[input] = output;
    }
    return output;
  };
})();
const kebabCase = /* @__PURE__ */ (function() {
  const cache2 = createLookup$1();
  const callback = (char, sep) => {
    return sep ? `-${char.toLowerCase()}` : char.toLowerCase();
  };
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = cache2[input] = baseCase(input, callback);
    }
    return output;
  };
})();
const toArray = (input) => {
  const length = input.length;
  const arr = Array(length);
  let i = 0;
  for (; i < length; ++i) {
    arr[i] = input[i];
  }
  return arr;
};
const bound = (originalMethod, context) => {
  const methodName = context.name;
  context.addInitializer(function() {
    Reflect.defineProperty(this, methodName, {
      value: originalMethod.bind(this),
      writable: true,
      configurable: true,
      enumerable: false
    });
  });
};
const mergeArrays = (...arrays) => {
  const result = [];
  let k = 0;
  const arraysLen = arrays.length;
  let arrayLen = 0;
  let array;
  let i = 0;
  for (; i < arraysLen; ++i) {
    array = arrays[i];
    if (array !== void 0) {
      arrayLen = array.length;
      let j = 0;
      for (; j < arrayLen; ++j) {
        result[k++] = array[j];
      }
    }
  }
  return result;
};
const firstDefined = (...values) => {
  const len = values.length;
  let value;
  let i = 0;
  for (; len > i; ++i) {
    value = values[i];
    if (value !== void 0) {
      return value;
    }
  }
  throw createMappedError$4(
    20
    /* ErrorNames.first_defined_no_value */
  );
};
const getPrototypeChain = /* @__PURE__ */ (function() {
  const functionPrototype = Function.prototype;
  const getPrototypeOf = Object.getPrototypeOf;
  const cache2 = /* @__PURE__ */ new WeakMap();
  let proto = functionPrototype;
  let i = 0;
  let chain = void 0;
  return function(Type) {
    chain = cache2.get(Type);
    if (chain === void 0) {
      cache2.set(Type, chain = [proto = Type]);
      i = 0;
      while ((proto = getPrototypeOf(proto)) !== functionPrototype) {
        chain[++i] = proto;
      }
    }
    return chain;
  };
})();
function toLookup(...objs) {
  return objectAssign$1(createLookup$1(), ...objs);
}
const isNativeFunction = /* @__PURE__ */ (() => {
  const lookup2 = /* @__PURE__ */ new WeakMap();
  let isNative = false;
  let sourceText = "";
  let i = 0;
  return (fn2) => {
    isNative = lookup2.get(fn2);
    if (isNative == null) {
      i = (sourceText = fn2.toString()).length;
      isNative = i > 28 && sourceText.indexOf("[native code] }") === i - 15;
      lookup2.set(fn2, isNative);
    }
    return isNative;
  };
})();
const onResolve = (maybePromise, resolveCallback) => {
  if (isPromise(maybePromise)) {
    return maybePromise.then(resolveCallback);
  }
  return resolveCallback(maybePromise);
};
const onResolveAll = (...maybePromises) => {
  let maybePromise = void 0;
  let firstPromise = void 0;
  let promises = void 0;
  let i = 0;
  let ii = maybePromises.length;
  for (; i < ii; ++i) {
    maybePromise = maybePromises[i];
    if (isPromise(maybePromise = maybePromises[i])) {
      if (firstPromise === void 0) {
        firstPromise = maybePromise;
      } else if (promises === void 0) {
        promises = [firstPromise, maybePromise];
      } else {
        promises.push(maybePromise);
      }
    }
  }
  if (promises === void 0) {
    return firstPromise;
  }
  return Promise.all(promises);
};
const instanceRegistration$1 = (key, value) => new Resolver(key, 0, value);
const singletonRegistration$2 = (key, value) => new Resolver(key, 1, value);
const transientRegistation = (key, value) => new Resolver(key, 2, value);
const callbackRegistration = (key, callback) => new Resolver(key, 3, callback);
const cachedCallbackRegistration = (key, callback) => new Resolver(key, 3, cacheCallbackResult(callback));
const aliasToRegistration = (originalKey, aliasKey) => new Resolver(aliasKey, 5, originalKey);
const deferRegistration = (key, ...params) => new ParameterizedRegistry(key, params);
const containerLookup = /* @__PURE__ */ new WeakMap();
const cacheCallbackResult = (fun) => {
  return (handler, requestor, resolver) => {
    let resolverLookup = containerLookup.get(handler);
    if (resolverLookup === void 0) {
      containerLookup.set(handler, resolverLookup = /* @__PURE__ */ new WeakMap());
    }
    if (resolverLookup.has(resolver)) {
      return resolverLookup.get(resolver);
    }
    const t = fun(handler, requestor, resolver);
    resolverLookup.set(resolver, t);
    return t;
  };
};
const Registration = {
  /**
   * allows you to pass an instance.
   * Every time you request this {@linkcode Key} you will get this instance back.
   * ```
   * Registration.instance(Foo, new Foo()));
   * ```
   *
   * @param key - key to register the instance with
   * @param value - the instance associated with the key
   */
  instance: instanceRegistration$1,
  /**
   * Creates an instance from the class.
   * Every time you request this {@linkcode Key} you will get the same one back.
   * ```
   * Registration.singleton(Foo, Foo);
   * ```
   *
   * @param key - key to register the singleton class with
   * @param value - the singleton class to instantiate when a container resolves the associated key
   */
  singleton: singletonRegistration$2,
  /**
   * Creates an instance from a class.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.instance(Foo, Foo);
   * ```
   *
   * @param key - key to register the transient class with
   * @param value - the class to instantiate when a container resolves the associated key
   */
  transient: transientRegistation,
  /**
   * Creates an instance from the method passed.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.callback(Foo, () => new Foo());
   * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - key to register the callback with
   * @param callback - the callback to invoke when a container resolves the associated key
   */
  callback: callbackRegistration,
  /**
   * Creates an instance from the method passed.
   * On the first request for the {@linkcode Key} your callback is called and returns an instance.
   * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.
   * If you pass the same {@linkcode Registration} to another container the same cached value will be used.
   * Should all references to the resolver returned be removed, the cache will expire.
   * ```
   * Registration.cachedCallback(Foo, () => new Foo());
   * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - key to register the cached callback with
   * @param callback - the cache callback to invoke when a container resolves the associated key
   */
  cachedCallback: cachedCallbackRegistration,
  /**
   * creates an alternate {@linkcode Key} to retrieve an instance by.
   * Returns the same scope as the original {@linkcode Key}.
   * ```
   * Register.singleton(Foo, Foo)
   * Register.aliasTo(Foo, MyFoos);
   *
   * container.getAll(MyFoos) // contains an instance of Foo
   * ```
   *
   * @param originalKey - the real key to resolve the get call from a container
   * @param aliasKey - the key that a container allows to resolve the real key associated
   */
  aliasTo: aliasToRegistration,
  /**
   * @internal
   * @param key - the key to register a defer registration
   * @param params - the parameters that should be passed to the resolution of the key
   */
  defer: deferRegistration
};
const createImplementationRegister = function(key) {
  return function register2(container) {
    container.register(singletonRegistration$2(this, this), aliasToRegistration(this, key));
  };
};
const annoBaseName = "au:annotation";
const getAnnotationKeyFor$1 = (name2, context) => {
  if (context === void 0) {
    return `${annoBaseName}:${name2}`;
  }
  return `${annoBaseName}:${name2}:${context}`;
};
const appendAnnotation = (target, key) => {
  const keys = getMetadata$2(annoBaseName, target);
  if (keys === void 0) {
    defineMetadata$2([key], target, annoBaseName);
  } else {
    keys.push(key);
  }
};
const annotation$1 = /* @__PURE__ */ objectFreeze$1({
  name: "au:annotation",
  appendTo: appendAnnotation,
  set(target, prop, value) {
    defineMetadata$2(value, target, getAnnotationKeyFor$1(prop));
  },
  get: (target, prop) => getMetadata$2(getAnnotationKeyFor$1(prop), target),
  getKeys(target) {
    let keys = getMetadata$2(annoBaseName, target);
    if (keys === void 0) {
      defineMetadata$2(keys = [], target, annoBaseName);
    }
    return keys;
  },
  isKey: (key) => key.startsWith(annoBaseName),
  keyFor: getAnnotationKeyFor$1
});
const resourceBaseName = "au:resource";
const getResourceKeyFor = (type, name2, context) => {
  {
    return `${resourceBaseName}:${type}`;
  }
};
const Protocol = {
  annotation: annotation$1
};
const hasOwn = Object.prototype.hasOwnProperty;
function fromAnnotationOrDefinitionOrTypeOrDefault(name2, def2, Type, getDefault) {
  let value = getMetadata$2(getAnnotationKeyFor$1(name2), Type);
  if (value === void 0) {
    value = def2[name2];
    if (value === void 0) {
      value = Type[name2];
      if (value === void 0 || !hasOwn.call(Type, name2)) {
        return getDefault();
      }
      return value;
    }
    return value;
  }
  return value;
}
function fromAnnotationOrTypeOrDefault(name2, Type, getDefault) {
  let value = getMetadata$2(getAnnotationKeyFor$1(name2), Type);
  if (value === void 0) {
    value = Type[name2];
    if (value === void 0 || !hasOwn.call(Type, name2)) {
      return getDefault();
    }
    return value;
  }
  return value;
}
function fromDefinitionOrDefault(name2, def2, getDefault) {
  const value = def2[name2];
  if (value === void 0) {
    return getDefault();
  }
  return value;
}
const registrableMetadataKey = Symbol.for("au:registrable");
const DefaultResolver = {
  singleton: (key) => new Resolver(key, 1, key)
};
class ContainerConfiguration {
  constructor(inheritParentResources, defaultResolver) {
    this.inheritParentResources = inheritParentResources;
    this.defaultResolver = defaultResolver;
  }
  static from(config) {
    if (config === void 0 || config === ContainerConfiguration.DEFAULT) {
      return ContainerConfiguration.DEFAULT;
    }
    return new ContainerConfiguration(config.inheritParentResources ?? false, config.defaultResolver ?? DefaultResolver.singleton);
  }
}
ContainerConfiguration.DEFAULT = ContainerConfiguration.from({});
const createContainer$1 = (config) => new Container(null, ContainerConfiguration.from(config));
const InstrinsicTypeNames = new Set("Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet".split(" "));
let containerId = 0;
let currentContainer = null;
class Container {
  get depth() {
    return this._parent === null ? 0 : this._parent.depth + 1;
  }
  get parent() {
    return this._parent;
  }
  constructor(parent, config) {
    this.id = ++containerId;
    this._registerDepth = 0;
    this._disposableResolvers = /* @__PURE__ */ new Map();
    this._parent = parent;
    this.config = config;
    this._resolvers = /* @__PURE__ */ new Map();
    this.res = {};
    if (parent === null) {
      this.root = this;
      this._factories = /* @__PURE__ */ new Map();
    } else {
      this.root = parent.root;
      this._factories = parent._factories;
      if (config.inheritParentResources) {
        for (const key in parent.res) {
          this.registerResolver(key, parent.res[key]);
        }
      }
    }
    this._resolvers.set(IContainer, containerResolver);
  }
  register(...params) {
    if (++this._registerDepth === 100) {
      throw createMappedError$4(6, ...params);
    }
    let current;
    let keys;
    let value;
    let j;
    let jj;
    let i = 0;
    let ii = params.length;
    let def2;
    for (; i < ii; ++i) {
      current = params[i];
      if (!isObjectOrFunction(current)) {
        continue;
      }
      if (isRegistry(current)) {
        current.register(this);
      } else if ((def2 = getMetadata$2(resourceBaseName, current)) != null) {
        def2.register(this);
      } else if (isClass(current)) {
        const registrable = current[Symbol.metadata]?.[registrableMetadataKey];
        if (isRegistry(registrable)) {
          registrable.register(this);
        } else if (isString(current.$au?.type)) {
          const $au = current.$au;
          const aliases = (current.aliases ?? emptyArray).concat($au.aliases ?? emptyArray);
          let key = `${resourceBaseName}:${$au.type}:${$au.name}`;
          if (this.has(key, false)) {
            {
              globalThis.console?.warn(createMappedError$4(7, key));
            }
            continue;
          }
          aliasToRegistration(current, key).register(this);
          if (!this.has(current, false)) {
            singletonRegistration$2(current, current).register(this);
          }
          j = 0;
          jj = aliases.length;
          for (; j < jj; ++j) {
            key = `${resourceBaseName}:${$au.type}:${aliases[j]}`;
            if (this.has(key, false)) {
              {
                globalThis.console?.warn(createMappedError$4(7, key));
              }
              continue;
            }
            aliasToRegistration(current, key).register(this);
          }
        } else {
          singletonRegistration$2(current, current).register(this);
        }
      } else {
        keys = Object.keys(current);
        j = 0;
        jj = keys.length;
        for (; j < jj; ++j) {
          value = current[keys[j]];
          if (!isObjectOrFunction(value)) {
            continue;
          }
          if (isRegistry(value)) {
            value.register(this);
          } else {
            this.register(value);
          }
        }
      }
    }
    --this._registerDepth;
    return this;
  }
  registerResolver(key, resolver, isDisposable = false) {
    validateKey(key);
    const resolvers = this._resolvers;
    const result = resolvers.get(key);
    if (result == null) {
      resolvers.set(key, resolver);
      if (isResourceKey(key)) {
        if (this.res[key] !== void 0) {
          throw createMappedError$4(7, key);
        }
        this.res[key] = resolver;
      }
    } else if (result instanceof Resolver && result._strategy === 4) {
      result._state.push(resolver);
    } else {
      resolvers.set(key, new Resolver(key, 4, [result, resolver]));
    }
    if (isDisposable) {
      this._disposableResolvers.set(key, resolver);
    }
    return resolver;
  }
  deregister(key) {
    validateKey(key);
    const resolver = this._resolvers.get(key);
    if (resolver != null) {
      this._resolvers.delete(key);
      if (isResourceKey(key)) {
        delete this.res[key];
      }
      if (this._disposableResolvers.has(key)) {
        resolver.dispose();
        this._disposableResolvers.delete(key);
      }
    }
  }
  // public deregisterResolverFor<K extends Key>(key: K, searchAncestors: boolean): void {
  //   validateKey(key);
  //   // eslint-disable-next-line @typescript-eslint/no-this-alias
  //   let current: Container | null = this;
  //   let resolver: IResolver | undefined;
  //   while (current != null) {
  //     resolver = current._resolvers.get(key);
  //     if (resolver != null) {
  //       current._resolvers.delete(key);
  //       break;
  //     }
  //     if (current.parent == null) { return; }
  //     current = searchAncestors ? current.parent : null;
  //   }
  //   if (resolver == null) { return; }
  //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {
  //     throw createError('Cannot deregister a resolver with array strategy');
  //   }
  //   if (this._disposableResolvers.has(resolver as IDisposableResolver<K>)) {
  //     (resolver as IDisposableResolver<K>).dispose();
  //   }
  //   if (isResourceKey(key)) {
  //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
  //     delete this.res[key];
  //   }
  // }
  registerTransformer(key, transformer) {
    const resolver = this.getResolver(key);
    if (resolver == null) {
      return false;
    }
    if (resolver.getFactory) {
      const factory = resolver.getFactory(this);
      if (factory == null) {
        return false;
      }
      factory.registerTransformer(transformer);
      return true;
    }
    return false;
  }
  getResolver(key, autoRegister = true) {
    validateKey(key);
    if (key.resolve !== void 0) {
      return key;
    }
    const previousContainer = currentContainer;
    let current = currentContainer = this;
    let resolver;
    let handler;
    try {
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          if (current._parent == null) {
            handler = isRegisterInRequester(key) ? this : current;
            if (autoRegister) {
              return this._jitRegister(key, handler);
            }
            return null;
          }
          current = current._parent;
        } else {
          return resolver;
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    return null;
  }
  has(key, searchAncestors = false) {
    return this._resolvers.has(key) || isResourceKey(key) && key in this.res || ((searchAncestors && this._parent?.has(key, true)) ?? false);
  }
  get(key) {
    validateKey(key);
    if (key.$isResolver) {
      return key.resolve(this, this);
    }
    const previousContainer = currentContainer;
    let current = currentContainer = this;
    let resolver;
    let handler;
    try {
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          if (current._parent == null) {
            handler = isRegisterInRequester(key) ? this : current;
            resolver = this._jitRegister(key, handler);
            return resolver.resolve(current, this);
          }
          current = current._parent;
        } else {
          return resolver.resolve(current, this);
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    throw createMappedError$4(8, key);
  }
  getAll(key, searchAncestors = false) {
    validateKey(key);
    const previousContainer = currentContainer;
    const requestor = currentContainer = this;
    let current = requestor;
    let resolver;
    let resolutions = emptyArray;
    try {
      if (searchAncestors) {
        while (current != null) {
          resolver = current._resolvers.get(key);
          if (resolver != null) {
            resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));
          }
          current = current._parent;
        }
        return resolutions;
      }
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          current = current._parent;
          if (current == null) {
            return emptyArray;
          }
        } else {
          return buildAllResponse(resolver, current, requestor);
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    return emptyArray;
  }
  invoke(Type, dynamicDependencies) {
    if (isNativeFunction(Type)) {
      throw createMappedError$4(15, Type);
    }
    const previousContainer = currentContainer;
    currentContainer = this;
    {
      let resolvedDeps;
      let dep;
      try {
        resolvedDeps = getDependencies(Type).map((_) => this.get(dep = _));
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}, caused by dependency: ${String(dep)}`);
        currentContainer = previousContainer;
        throw ex;
      }
      try {
        return dynamicDependencies === void 0 ? new Type(...resolvedDeps) : new Type(...resolvedDeps, ...dynamicDependencies);
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}`);
        throw ex;
      } finally {
        currentContainer = previousContainer;
      }
    }
    try {
      return dynamicDependencies === void 0 ? new Type(...getDependencies(Type).map(containerGetKey, this)) : new Type(...getDependencies(Type).map(containerGetKey, this), ...dynamicDependencies);
    } finally {
      currentContainer = previousContainer;
    }
  }
  hasFactory(key) {
    return this._factories.has(key);
  }
  getFactory(Type) {
    let factory = this._factories.get(Type);
    if (factory === void 0) {
      if (isNativeFunction(Type)) {
        throw createMappedError$4(15, Type);
      }
      this._factories.set(Type, factory = new Factory(Type, getDependencies(Type)));
    }
    return factory;
  }
  registerFactory(key, factory) {
    this._factories.set(key, factory);
  }
  createChild(config) {
    if (config === void 0 && this.config.inheritParentResources) {
      if (this.config === ContainerConfiguration.DEFAULT) {
        return new Container(this, this.config);
      }
      return new Container(this, ContainerConfiguration.from({
        ...this.config,
        inheritParentResources: false
      }));
    }
    return new Container(this, ContainerConfiguration.from(config ?? this.config));
  }
  disposeResolvers() {
    const resolvers = this._resolvers;
    const disposableResolvers = this._disposableResolvers;
    let disposable;
    let key;
    for ([key, disposable] of disposableResolvers.entries()) {
      disposable.dispose?.();
      resolvers.delete(key);
    }
    disposableResolvers.clear();
  }
  useResources(container) {
    const res = container.res;
    for (const key in res) {
      this.registerResolver(key, res[key]);
    }
  }
  find(keyOrKind, name2) {
    const key = isString(name2) ? `${resourceBaseName}:${keyOrKind}:${name2}` : keyOrKind;
    let container = this;
    let resolver = container.res[key];
    if (resolver == null) {
      container = container.root;
      resolver = container.res[key];
    }
    if (resolver == null) {
      return null;
    }
    return resolver.getFactory?.(container)?.Type ?? null;
  }
  dispose() {
    if (this._disposableResolvers.size > 0) {
      this.disposeResolvers();
    }
    this._resolvers.clear();
    if (this.root === this) {
      this._factories.clear();
      this.res = {};
    }
  }
  /** @internal */
  _jitRegister(keyAsValue, handler) {
    const $isRegistry = isRegistry(keyAsValue);
    if (!isFunction(keyAsValue) && !$isRegistry) {
      throw createMappedError$4(9, keyAsValue);
    }
    if (InstrinsicTypeNames.has(keyAsValue.name)) {
      throw createMappedError$4(10, keyAsValue);
    }
    if ($isRegistry) {
      const registrationResolver = keyAsValue.register(handler, keyAsValue);
      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
        const newResolver = handler._resolvers.get(keyAsValue);
        if (newResolver != null) {
          return newResolver;
        }
        throw createMappedError$4(11, keyAsValue);
      }
      return registrationResolver;
    }
    if (keyAsValue.$isInterface) {
      throw createMappedError$4(12, keyAsValue.friendlyName);
    }
    const resolver = this.config.defaultResolver(keyAsValue, handler);
    handler._resolvers.set(keyAsValue, resolver);
    return resolver;
  }
}
class Factory {
  constructor(Type, dependencies2) {
    this.Type = Type;
    this.dependencies = dependencies2;
    this.transformers = null;
  }
  construct(container, dynamicDependencies) {
    const previousContainer = currentContainer;
    currentContainer = container;
    let instance;
    {
      let resolvedDeps;
      let dep;
      try {
        resolvedDeps = this.dependencies.map((_) => container.get(dep = _));
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}, caused by dependency: ${String(dep)}`);
        currentContainer = previousContainer;
        throw ex;
      }
      try {
        if (dynamicDependencies === void 0) {
          instance = new this.Type(...resolvedDeps);
        } else {
          instance = new this.Type(...resolvedDeps, ...dynamicDependencies);
        }
        if (this.transformers == null) {
          return instance;
        }
        return this.transformers.reduce(transformInstance, instance);
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}`);
        throw ex;
      } finally {
        currentContainer = previousContainer;
      }
    }
    try {
      if (dynamicDependencies === void 0) {
        instance = new this.Type(...this.dependencies.map(containerGetKey, container));
      } else {
        instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
      }
      if (this.transformers == null) {
        return instance;
      }
      return this.transformers.reduce(transformInstance, instance);
    } finally {
      currentContainer = previousContainer;
    }
  }
  registerTransformer(transformer) {
    (this.transformers ??= []).push(transformer);
  }
}
function transformInstance(inst, transform) {
  return transform(inst);
}
function validateKey(key) {
  if (key === null || key === void 0) {
    throw createMappedError$4(
      14
      /* ErrorNames.null_undefined_key */
    );
  }
}
function containerGetKey(d3) {
  return this.get(d3);
}
function resolve(...keys) {
  if (currentContainer == null) {
    throw createMappedError$4(16, ...keys);
  }
  {
    if (keys.length === 1) {
      try {
        return currentContainer.get(keys[0]);
      } catch (ex) {
        logError(`[DEV:aurelia] resolve() call error for: ${String(keys[0])}`);
        throw ex;
      }
    } else {
      let key;
      try {
        return keys.map((_) => currentContainer.get(key = _));
      } catch (ex) {
        logError(`[DEV:aurelia] resolve() call error for: ${String(key)}`);
        throw ex;
      }
    }
  }
  return keys.length === 1 ? currentContainer.get(keys[0]) : keys.map(containerGetKey, currentContainer);
}
const buildAllResponse = (resolver, handler, requestor) => {
  if (resolver instanceof Resolver && resolver._strategy === 4) {
    const state = resolver._state;
    const ii = state.length;
    const results = Array(ii);
    let i = 0;
    for (; i < ii; ++i) {
      results[i] = state[i].resolve(handler, requestor);
    }
    return results;
  }
  return [resolver.resolve(handler, requestor)];
};
const containerResolver = {
  $isResolver: true,
  resolve(handler, requestor) {
    return requestor;
  }
};
const isRegistry = (obj) => isFunction(obj?.register);
const isSelfRegistry = (obj) => isRegistry(obj) && typeof obj.registerInRequestor === "boolean";
const isRegisterInRequester = (obj) => isSelfRegistry(obj) && obj.registerInRequestor;
const isClass = (obj) => obj.prototype !== void 0;
const isResourceKey = (key) => isString(key) && key.indexOf(":") > 0;
class ResolverBuilder {
  constructor(_container, _key) {
    this._container = _container;
    this._key = _key;
  }
  instance(value) {
    return this._registerResolver(0, value);
  }
  singleton(value) {
    return this._registerResolver(1, value);
  }
  transient(value) {
    return this._registerResolver(2, value);
  }
  callback(value) {
    return this._registerResolver(3, value);
  }
  cachedCallback(value) {
    return this._registerResolver(3, cacheCallbackResult(value));
  }
  aliasTo(destinationKey) {
    return this._registerResolver(5, destinationKey);
  }
  /** @internal */
  _registerResolver(strategy, state) {
    const { _container: container, _key: key } = this;
    this._container = this._key = void 0;
    return container.registerResolver(key, new Resolver(key, strategy, state));
  }
}
const cloneArrayWithPossibleProps = (source) => {
  const clone = source.slice();
  const keys = Object.keys(source);
  const len = keys.length;
  let key;
  for (let i = 0; i < len; ++i) {
    key = keys[i];
    if (!isArrayIndex(key)) {
      clone[key] = source[key];
    }
  }
  return clone;
};
const diParamTypesKeys = getAnnotationKeyFor$1("di:paramtypes");
const getAnnotationParamtypes = (Type) => {
  return getMetadata$2(diParamTypesKeys, Type);
};
const getDesignParamtypes = (Type) => getMetadata$2("design:paramtypes", Type);
const getOrCreateAnnotationParamTypes = (context) => {
  return context.metadata[diParamTypesKeys] ??= [];
};
const getDependencies = (Type) => {
  const key = getAnnotationKeyFor$1("di:dependencies");
  let dependencies2 = getMetadata$2(key, Type);
  if (dependencies2 === void 0) {
    const inject2 = Type.inject;
    if (inject2 === void 0) {
      const designParamtypes = getDesignParamtypes(Type);
      const annotationParamtypes = getAnnotationParamtypes(Type);
      if (designParamtypes === void 0) {
        if (annotationParamtypes === void 0) {
          const Proto = Object.getPrototypeOf(Type);
          if (isFunction(Proto) && Proto !== Function.prototype) {
            dependencies2 = cloneArrayWithPossibleProps(getDependencies(Proto));
          } else {
            dependencies2 = [];
          }
        } else {
          dependencies2 = cloneArrayWithPossibleProps(annotationParamtypes);
        }
      } else if (annotationParamtypes === void 0) {
        dependencies2 = cloneArrayWithPossibleProps(designParamtypes);
      } else {
        dependencies2 = cloneArrayWithPossibleProps(designParamtypes);
        let len = annotationParamtypes.length;
        let auAnnotationParamtype;
        let i = 0;
        for (; i < len; ++i) {
          auAnnotationParamtype = annotationParamtypes[i];
          if (auAnnotationParamtype !== void 0) {
            dependencies2[i] = auAnnotationParamtype;
          }
        }
        const keys = Object.keys(annotationParamtypes);
        let key2;
        i = 0;
        len = keys.length;
        for (i = 0; i < len; ++i) {
          key2 = keys[i];
          if (!isArrayIndex(key2)) {
            dependencies2[key2] = annotationParamtypes[key2];
          }
        }
      }
    } else {
      dependencies2 = cloneArrayWithPossibleProps(inject2);
    }
    defineMetadata$2(dependencies2, Type, key);
  }
  return dependencies2;
};
const createInterface$1 = (configureOrName, configuror) => {
  const configure2 = isFunction(configureOrName) ? configureOrName : configuror;
  const friendlyName = (isString(configureOrName) ? configureOrName : void 0) ?? "(anonymous)";
  const Interface = {
    // Old code kept with the hope that the argument decorator proposal will be standardized by TC39 (https://github.com/tc39/proposal-class-method-parameter-decorators)
    // function(_target: Injectable | AbstractInjectable, _property: string | symbol | undefined, _index: number | undefined): void {
    //    if (target == null || new.target !== undefined) {
    //     throw createMappedError(ErrorNames.no_registration_for_interface, friendlyName);
    //    }
    //    const annotationParamtypes = getOrCreateAnnotationParamTypes(target as Injectable);
    //    annotationParamtypes[index!] = Interface;
    // },
    $isInterface: true,
    friendlyName,
    toString: () => `InterfaceSymbol<${friendlyName}>`,
    register: configure2 != null ? (container, key) => configure2(new ResolverBuilder(container, key ?? Interface)) : void 0
  };
  return Interface;
};
const inject = (...dependencies2) => {
  return (decorated, context) => {
    switch (context.kind) {
      case "class": {
        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);
        let dep;
        let i = 0;
        for (; i < dependencies2.length; ++i) {
          dep = dependencies2[i];
          if (dep !== void 0) {
            annotationParamtypes[i] = dep;
          }
        }
        break;
      }
      case "field": {
        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);
        const dep = dependencies2[0];
        if (dep !== void 0) {
          annotationParamtypes[context.name] = dep;
        }
        break;
      }
      // TODO(sayan): support getter injection - new feature
      // TODO:
      //    support method parameter injection when the class-method-parameter-decorators proposal (https://github.com/tc39/proposal-class-method-parameter-decorators)
      //    reaches stage 4 and/or implemented by TS.
      default:
        throw createMappedError$4(22, String(context.name), context.kind);
    }
  };
};
const DI = /* @__PURE__ */ (() => {
  initializeTC39Metadata();
  return {
    createContainer: createContainer$1,
    getDesignParamtypes,
    // getAnnotationParamtypes,
    // getOrCreateAnnotationParamTypes,
    getDependencies,
    /**
     * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.
     * ```ts
     * const ILogger = DI.createInterface<Logger>('Logger');
     * container.register(Registration.singleton(ILogger, getSomeLogger()));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * you can also build default registrations into your interface.
     * ```ts
     * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * but these default registrations won't work the same with other decorators that take keys, for example
     * ```ts
     * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));
     * class Foo {
     *   constructor( @optional(MyStr) public readonly str: string ) {
     *   }
     * }
     * container.get(Foo).str; // returns undefined
     * ```
     * to fix this add this line somewhere before you do a `get`
     * ```ts
     * container.register(MyStr);
     * container.get(Foo).str; // returns 'somestring'
     * ```
     *
     * - @param configureOrName - supply a string to improve error messaging
     */
    createInterface: createInterface$1,
    inject,
    /**
     * Registers the `target` class as a transient dependency; each time the dependency is resolved
     * a new instance will be created.
     *
     * @param target - The class / constructor function to register as transient.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     *
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.transient(Foo);
     *
     * // Inline declaration
     * const Foo = DI.transient(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    transient(target) {
      target.register = function(container) {
        const registration = transientRegistation(target, target);
        return registration.register(container, target);
      };
      target.registerInRequestor = false;
      return target;
    },
    /**
     * Registers the `target` class as a singleton dependency; the class will only be created once. Each
     * consecutive time the dependency is resolved, the same instance will be returned.
     *
     * @param target - The class / constructor function to register as a singleton.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.singleton(Foo);
     *
     * // Inline declaration
     * const Foo = DI.singleton(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    singleton(target, options = defaultSingletonOptions) {
      target.register = function(container) {
        const registration = singletonRegistration$2(target, target);
        return registration.register(container, target);
      };
      target.registerInRequestor = options.scoped;
      return target;
    }
  };
})();
const IContainer = /* @__PURE__ */ createInterface$1("IContainer");
const IServiceLocator = IContainer;
function transientDecorator(target, context) {
  return DI.transient(target);
}
function transient(target, context) {
  return target == null ? transientDecorator : transientDecorator(target);
}
const defaultSingletonOptions = { scoped: false };
class Resolver {
  get $isResolver() {
    return true;
  }
  constructor(key, strategy, state) {
    this._resolving = false;
    this._cachedFactory = null;
    this._key = key;
    this._strategy = strategy;
    this._state = state;
  }
  register(container, key) {
    return container.registerResolver(key || this._key, this);
  }
  resolve(handler, requestor) {
    switch (this._strategy) {
      case 0:
        return this._state;
      case 1: {
        if (this._resolving) {
          throw createMappedError$4(3, this._state.name);
        }
        this._resolving = true;
        this._state = (this._cachedFactory = handler.getFactory(this._state)).construct(requestor);
        this._strategy = 0;
        this._resolving = false;
        return this._state;
      }
      case 2: {
        const factory = handler.getFactory(this._state);
        if (factory === null) {
          throw createMappedError$4(4, this._key);
        }
        return factory.construct(requestor);
      }
      case 3:
        return this._state(handler, requestor, this);
      case 4:
        return this._state[0].resolve(handler, requestor);
      case 5:
        return requestor.get(this._state);
      default:
        throw createMappedError$4(5, this._strategy);
    }
  }
  getFactory(container) {
    switch (this._strategy) {
      case 1:
      case 2:
        return container.getFactory(this._state);
      case 5:
        return container.getResolver(this._state)?.getFactory?.(container) ?? null;
      case 0:
        return this._cachedFactory;
      default:
        return null;
    }
  }
}
class InstanceProvider {
  get friendlyName() {
    return this._name;
  }
  constructor(name2, instance = null, Type = null) {
    this._name = name2;
    this._instance = instance;
    this._Type = Type;
  }
  prepare(instance) {
    this._instance = instance;
  }
  get $isResolver() {
    return true;
  }
  resolve() {
    if (this._instance == null) {
      throw createMappedError$4(13, this._name);
    }
    return this._instance;
  }
  getFactory(container) {
    return this._Type == null ? null : container.getFactory(this._Type);
  }
  dispose() {
    this._instance = null;
  }
}
class ParameterizedRegistry {
  constructor(key, params) {
    this.key = key;
    this.params = params;
  }
  register(container) {
    if (container.has(this.key, true)) {
      const registry = container.get(this.key);
      registry.register(container, ...this.params);
    } else {
      container.register(...this.params.filter((x) => typeof x === "object"));
    }
  }
}
const emptyArray = objectFreeze$1([]);
const emptyObject = objectFreeze$1({});
function noop() {
}
const IPlatform$1 = /* @__PURE__ */ createInterface$1("IPlatform");
function createResolver(getter) {
  return function(key) {
    function Resolver2(target, context) {
      inject(Resolver2)(target, context);
    }
    Resolver2.$isResolver = true;
    Resolver2.resolve = function(handler, requestor) {
      return getter(key, handler, requestor);
    };
    return Resolver2;
  };
}
const all = (key, searchAncestors = false) => {
  function resolver(decorated, context) {
    inject(resolver)(decorated, context);
  }
  resolver.$isResolver = true;
  resolver.resolve = (handler, requestor) => requestor.getAll(key, searchAncestors);
  return resolver;
};
const optional = /* @__PURE__ */ createResolver((key, handler, requestor) => {
  if (requestor.has(key, true)) {
    return requestor.get(key);
  } else {
    return void 0;
  }
});
const own = /* @__PURE__ */ createResolver((key, handler, requestor) => {
  return requestor.has(key, false) ? requestor.get(key) : void 0;
});
const resource = /* @__PURE__ */ createResolver((key, handler, requestor) => requestor.has(key, false) ? requestor.get(key) : requestor.root.get(key));
const optionalResource = /* @__PURE__ */ createResolver((key, handler, requestor) => requestor.has(key, false) ? requestor.get(key) : requestor.root.has(key, false) ? requestor.root.get(key) : void 0);
const allResources = /* @__PURE__ */ createResolver((key, handler, requestor) => (
  // prevent duplicate retrieval
  requestor === requestor.root ? requestor.getAll(key, false) : requestor.has(key, false) ? requestor.getAll(key, false).concat(requestor.root.getAll(key, false)) : requestor.root.getAll(key, false)
));
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {};
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers$3(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
const trace$1 = 0;
const debug$1 = 1;
const info = 2;
const warn$1 = 3;
const error$1 = 4;
const fatal = 5;
const none$1 = 6;
const LogLevel = objectFreeze$1({
  /**
   * The most detailed information about internal app state.
   *
   * Disabled by default and should never be enabled in a production environment.
   */
  trace: trace$1,
  /**
   * Information that is useful for debugging during development and has no long-term value.
   */
  debug: debug$1,
  /**
   * Information about the general flow of the application that has long-term value.
   */
  info,
  /**
   * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.
   */
  warn: warn$1,
  /**
   * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.
   */
  error: error$1,
  /**
   * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.
   */
  fatal,
  /**
   * No messages should be written.
   */
  none: none$1
});
const ILogConfig = /* @__PURE__ */ createInterface$1("ILogConfig", (x) => x.instance(new LogConfig("no-colors", warn$1)));
const ISink = /* @__PURE__ */ createInterface$1("ISink");
const ILogEventFactory = /* @__PURE__ */ createInterface$1("ILogEventFactory", (x) => x.singleton(DefaultLogEventFactory));
const ILogger = /* @__PURE__ */ createInterface$1("ILogger", (x) => x.singleton(DefaultLogger));
const ILogScopes = /* @__PURE__ */ createInterface$1("ILogScope");
const LoggerSink = /* @__PURE__ */ objectFreeze$1({
  key: getAnnotationKeyFor$1("logger-sink-handles"),
  define(target, definition) {
    defineMetadata$2(definition.handles, target, this.key);
  },
  getHandles(target) {
    return getMetadata$2(this.key, target.constructor);
  }
});
const format = toLookup({
  red(str) {
    return `\x1B[31m${str}\x1B[39m`;
  },
  green(str) {
    return `\x1B[32m${str}\x1B[39m`;
  },
  yellow(str) {
    return `\x1B[33m${str}\x1B[39m`;
  },
  blue(str) {
    return `\x1B[34m${str}\x1B[39m`;
  },
  magenta(str) {
    return `\x1B[35m${str}\x1B[39m`;
  },
  cyan(str) {
    return `\x1B[36m${str}\x1B[39m`;
  },
  white(str) {
    return `\x1B[37m${str}\x1B[39m`;
  },
  grey(str) {
    return `\x1B[90m${str}\x1B[39m`;
  }
});
class LogConfig {
  constructor(colorOptions, level) {
    this.colorOptions = colorOptions;
    this.level = level;
  }
}
const getLogLevelString = (function() {
  const logLevelString = {
    "no-colors": toLookup({
      TRC: "TRC",
      DBG: "DBG",
      INF: "INF",
      WRN: "WRN",
      ERR: "ERR",
      FTL: "FTL",
      QQQ: "???"
    }),
    "colors": toLookup({
      TRC: format.grey("TRC"),
      DBG: format.grey("DBG"),
      INF: format.white("INF"),
      WRN: format.yellow("WRN"),
      ERR: format.red("ERR"),
      FTL: format.red("FTL"),
      QQQ: format.grey("???")
    })
  };
  return (level, colorOptions) => {
    if (level <= trace$1) {
      return logLevelString[colorOptions].TRC;
    }
    if (level <= debug$1) {
      return logLevelString[colorOptions].DBG;
    }
    if (level <= info) {
      return logLevelString[colorOptions].INF;
    }
    if (level <= warn$1) {
      return logLevelString[colorOptions].WRN;
    }
    if (level <= error$1) {
      return logLevelString[colorOptions].ERR;
    }
    if (level <= fatal) {
      return logLevelString[colorOptions].FTL;
    }
    return logLevelString[colorOptions].QQQ;
  };
})();
const getScopeString = (scope, colorOptions) => {
  if (colorOptions === "no-colors") {
    return scope.join(".");
  }
  return scope.map(format.cyan).join(".");
};
const getIsoString = (timestamp, colorOptions) => {
  if (colorOptions === "no-colors") {
    return new Date(timestamp).toISOString();
  }
  return format.grey(new Date(timestamp).toISOString());
};
class DefaultLogEvent {
  constructor(severity, message, optionalParams, scope, colorOptions, timestamp) {
    this.severity = severity;
    this.message = message;
    this.optionalParams = optionalParams;
    this.scope = scope;
    this.colorOptions = colorOptions;
    this.timestamp = timestamp;
  }
  toString() {
    const { severity, message, scope, colorOptions, timestamp } = this;
    if (scope.length === 0) {
      return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;
    }
    return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;
  }
  getFormattedLogInfo(forConsole = false) {
    const { severity, message: messageOrError, scope, colorOptions, timestamp, optionalParams } = this;
    let error2 = null;
    let message = "";
    if (forConsole && messageOrError instanceof Error) {
      error2 = messageOrError;
    } else {
      message = messageOrError;
    }
    const scopeInfo = scope.length === 0 ? "" : ` ${getScopeString(scope, colorOptions)}`;
    let msg = `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}${scopeInfo}] ${message}`;
    if (optionalParams === void 0 || optionalParams.length === 0) {
      return error2 === null ? [msg] : [msg, error2];
    }
    let offset2 = 0;
    while (msg.includes("%s")) {
      msg = msg.replace("%s", String(optionalParams[offset2++]));
    }
    return error2 !== null ? [msg, error2, ...optionalParams.slice(offset2)] : [msg, ...optionalParams.slice(offset2)];
  }
}
class DefaultLogEventFactory {
  constructor() {
    this.config = resolve(ILogConfig);
  }
  createLogEvent(logger, level, message, optionalParams) {
    return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());
  }
}
let DefaultLogger = (() => {
  var _a2;
  let _instanceExtraInitializers = [];
  let _trace_decorators;
  let _debug_decorators;
  let _info_decorators;
  let _warn_decorators;
  let _error_decorators;
  let _fatal_decorators;
  return _a2 = class DefaultLogger {
    /* eslint-disable default-param-last */
    constructor(config = resolve(ILogConfig), factory = resolve(ILogEventFactory), sinks = resolve(all(ISink)), scope = resolve(optional(ILogScopes)) ?? [], parent = null) {
      this.scope = (__runInitializers$3(this, _instanceExtraInitializers), scope);
      this._scopedLoggers = createLookup$1();
      let traceSinks;
      let debugSinks;
      let infoSinks;
      let warnSinks;
      let errorSinks;
      let fatalSinks;
      this.config = config;
      this._factory = factory;
      this.sinks = sinks;
      if (parent === null) {
        this.root = this;
        this.parent = this;
        traceSinks = this._traceSinks = [];
        debugSinks = this._debugSinks = [];
        infoSinks = this._infoSinks = [];
        warnSinks = this._warnSinks = [];
        errorSinks = this._errorSinks = [];
        fatalSinks = this._fatalSinks = [];
        for (const $sink of sinks) {
          const handles = LoggerSink.getHandles($sink);
          if (handles?.includes(trace$1) ?? true) {
            traceSinks.push($sink);
          }
          if (handles?.includes(debug$1) ?? true) {
            debugSinks.push($sink);
          }
          if (handles?.includes(info) ?? true) {
            infoSinks.push($sink);
          }
          if (handles?.includes(warn$1) ?? true) {
            warnSinks.push($sink);
          }
          if (handles?.includes(error$1) ?? true) {
            errorSinks.push($sink);
          }
          if (handles?.includes(fatal) ?? true) {
            fatalSinks.push($sink);
          }
        }
      } else {
        this.root = parent.root;
        this.parent = parent;
        traceSinks = this._traceSinks = parent._traceSinks;
        debugSinks = this._debugSinks = parent._debugSinks;
        infoSinks = this._infoSinks = parent._infoSinks;
        warnSinks = this._warnSinks = parent._warnSinks;
        errorSinks = this._errorSinks = parent._errorSinks;
        fatalSinks = this._fatalSinks = parent._fatalSinks;
      }
    }
    trace(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= trace$1) {
        this._emit(this._traceSinks, trace$1, messageOrGetMessage, optionalParams);
      }
    }
    debug(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= debug$1) {
        this._emit(this._debugSinks, debug$1, messageOrGetMessage, optionalParams);
      }
    }
    info(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= info) {
        this._emit(this._infoSinks, info, messageOrGetMessage, optionalParams);
      }
    }
    warn(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= warn$1) {
        this._emit(this._warnSinks, warn$1, messageOrGetMessage, optionalParams);
      }
    }
    error(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= error$1) {
        this._emit(this._errorSinks, error$1, messageOrGetMessage, optionalParams);
      }
    }
    fatal(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= fatal) {
        this._emit(this._fatalSinks, fatal, messageOrGetMessage, optionalParams);
      }
    }
    /**
     * Create a new logger with an additional permanent prefix added to the logging outputs.
     * When chained, multiple scopes are separated by a dot.
     *
     * This is preliminary API and subject to change before alpha release.
     *
     * @example
     *
     * ```ts
     * export class MyComponent {
     *   constructor(@ILogger private logger: ILogger) {
     *     this.logger.debug('before scoping');
     *     // console output: '[DBG] before scoping'
     *     this.logger = logger.scopeTo('MyComponent');
     *     this.logger.debug('after scoping');
     *     // console output: '[DBG MyComponent] after scoping'
     *   }
     *
     *   public doStuff(): void {
     *     const logger = this.logger.scopeTo('doStuff()');
     *     logger.debug('doing stuff');
     *     // console output: '[DBG MyComponent.doStuff()] doing stuff'
     *   }
     * }
     * ```
     */
    scopeTo(name2) {
      const scopedLoggers = this._scopedLoggers;
      let scopedLogger = scopedLoggers[name2];
      if (scopedLogger === void 0) {
        scopedLogger = scopedLoggers[name2] = new _a2(this.config, this._factory, null, this.scope.concat(name2), this);
      }
      return scopedLogger;
    }
    /** @internal */
    _emit(sinks, level, msgOrGetMsg, optionalParams) {
      const message = isFunction(msgOrGetMsg) ? msgOrGetMsg() : msgOrGetMsg;
      const event = this._factory.createLogEvent(this, level, message, optionalParams);
      for (let i = 0, ii = sinks.length; i < ii; ++i) {
        sinks[i].handleEvent(event);
      }
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _trace_decorators = [bound];
    _debug_decorators = [bound];
    _info_decorators = [bound];
    _warn_decorators = [bound];
    _error_decorators = [bound];
    _fatal_decorators = [bound];
    __esDecorate(_a2, null, _trace_decorators, { kind: "method", name: "trace", static: false, private: false, access: { has: (obj) => "trace" in obj, get: (obj) => obj.trace }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _debug_decorators, { kind: "method", name: "debug", static: false, private: false, access: { has: (obj) => "debug" in obj, get: (obj) => obj.debug }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _info_decorators, { kind: "method", name: "info", static: false, private: false, access: { has: (obj) => "info" in obj, get: (obj) => obj.info }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _warn_decorators, { kind: "method", name: "warn", static: false, private: false, access: { has: (obj) => "warn" in obj, get: (obj) => obj.warn }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _error_decorators, { kind: "method", name: "error", static: false, private: false, access: { has: (obj) => "error" in obj, get: (obj) => obj.error }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _fatal_decorators, { kind: "method", name: "fatal", static: false, private: false, access: { has: (obj) => "fatal" in obj, get: (obj) => obj.fatal }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a2, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a2;
})();
const IModuleLoader = /* @__PURE__ */ createInterface$1((x) => x.singleton(ModuleLoader));
const noTransform = (m3) => m3;
class ModuleTransformer {
  constructor(transform) {
    this._promiseCache = /* @__PURE__ */ new Map();
    this._objectCache = /* @__PURE__ */ new Map();
    this._transform = transform;
  }
  transform(objOrPromise) {
    if (objOrPromise instanceof Promise) {
      return this._transformPromise(objOrPromise);
    } else if (typeof objOrPromise === "object" && objOrPromise !== null) {
      return this._transformObject(objOrPromise);
    } else {
      throw createMappedError$4(21, objOrPromise);
    }
  }
  /** @internal */
  _transformPromise(promise) {
    if (this._promiseCache.has(promise)) {
      return this._promiseCache.get(promise);
    }
    const ret = promise.then((obj) => {
      return this._transformObject(obj);
    });
    this._promiseCache.set(promise, ret);
    void ret.then((value) => {
      this._promiseCache.set(promise, value);
    });
    return ret;
  }
  /** @internal */
  _transformObject(obj) {
    if (this._objectCache.has(obj)) {
      return this._objectCache.get(obj);
    }
    const ret = this._transform(this._analyze(obj));
    this._objectCache.set(obj, ret);
    if (ret instanceof Promise) {
      void ret.then((value) => {
        this._objectCache.set(obj, value);
      });
    }
    return ret;
  }
  /** @internal */
  _analyze(m3) {
    if (m3 == null)
      throw createMappedError$4(21, m3);
    if (typeof m3 !== "object")
      return new AnalyzedModule(m3, []);
    let value;
    let isRegistry2;
    let isConstructable;
    let definition;
    const items = [];
    for (const key in m3) {
      switch (typeof (value = m3[key])) {
        case "object":
          if (value === null) {
            continue;
          }
          isRegistry2 = isFunction(value.register);
          isConstructable = false;
          definition = null;
          break;
        case "function":
          isRegistry2 = isFunction(value.register);
          isConstructable = value.prototype !== void 0;
          definition = getMetadata$2(resourceBaseName, value) ?? null;
          break;
        default:
          continue;
      }
      items.push(new ModuleItem(key, value, isRegistry2, isConstructable, definition));
    }
    return new AnalyzedModule(m3, items);
  }
}
class ModuleLoader {
  constructor() {
    this.transformers = /* @__PURE__ */ new Map();
  }
  load(objOrPromise, transform = noTransform) {
    const transformers = this.transformers;
    let transformer = transformers.get(transform);
    if (transformer === void 0) {
      transformers.set(transform, transformer = new ModuleTransformer(transform));
    }
    return transformer.transform(objOrPromise);
  }
  dispose() {
    this.transformers.clear();
  }
}
class AnalyzedModule {
  constructor(raw, items) {
    this.raw = raw;
    this.items = items;
  }
}
class ModuleItem {
  constructor(key, value, isRegistry2, isConstructable, definition) {
    this.key = key;
    this.value = value;
    this.isRegistry = isRegistry2;
    this.isConstructable = isConstructable;
    this.definition = definition;
  }
}
class Handler {
  constructor(type, cb) {
    this.type = type;
    this.cb = cb;
  }
  handle(message) {
    if (message instanceof this.type) {
      this.cb.call(null, message);
    }
  }
}
const IEventAggregator = /* @__PURE__ */ createInterface$1("IEventAggregator", (x) => x.singleton(EventAggregator));
class EventAggregator {
  constructor() {
    this.eventLookup = {};
    this.messageHandlers = [];
  }
  publish(channelOrInstance, message) {
    if (!channelOrInstance) {
      throw createMappedError$4(18, channelOrInstance);
    }
    if (isString(channelOrInstance)) {
      let subscribers = this.eventLookup[channelOrInstance];
      if (subscribers !== void 0) {
        subscribers = subscribers.slice();
        const numSubscribers = subscribers.length;
        for (let i = 0; i < numSubscribers; i++) {
          subscribers[i](message, channelOrInstance);
        }
      }
    } else {
      const subscribers = this.messageHandlers.slice();
      const numSubscribers = subscribers.length;
      for (let i = 0; i < numSubscribers; i++) {
        subscribers[i].handle(channelOrInstance);
      }
    }
  }
  subscribe(channelOrType, callback) {
    if (!channelOrType) {
      throw createMappedError$4(19, channelOrType);
    }
    let handler;
    let subscribers;
    if (isString(channelOrType)) {
      if (this.eventLookup[channelOrType] === void 0) {
        this.eventLookup[channelOrType] = [];
      }
      handler = callback;
      subscribers = this.eventLookup[channelOrType];
    } else {
      handler = new Handler(channelOrType, callback);
      subscribers = this.messageHandlers;
    }
    subscribers.push(handler);
    return {
      dispose() {
        const idx = subscribers.indexOf(handler);
        if (idx !== -1) {
          subscribers.splice(idx, 1);
        }
      }
    };
  }
  subscribeOnce(channelOrType, callback) {
    const sub = this.subscribe(channelOrType, (message, event) => {
      sub.dispose();
      callback(message, event);
    });
    return sub;
  }
}
const ekAccessThis = "AccessThis";
const ekAccessBoundary = "AccessBoundary";
const ekAccessGlobal = "AccessGlobal";
const ekAccessScope = "AccessScope";
const ekArrayLiteral = "ArrayLiteral";
const ekObjectLiteral = "ObjectLiteral";
const ekPrimitiveLiteral = "PrimitiveLiteral";
const ekNew = "New";
const ekTemplate = "Template";
const ekUnary = "Unary";
const ekCallScope = "CallScope";
const ekCallMember = "CallMember";
const ekCallFunction = "CallFunction";
const ekCallGlobal = "CallGlobal";
const ekAccessMember = "AccessMember";
const ekAccessKeyed = "AccessKeyed";
const ekTaggedTemplate = "TaggedTemplate";
const ekBinary = "Binary";
const ekConditional = "Conditional";
const ekAssign = "Assign";
const ekArrowFunction = "ArrowFunction";
const ekValueConverter = "ValueConverter";
const ekBindingBehavior = "BindingBehavior";
const ekArrayBindingPattern = "ArrayBindingPattern";
const ekObjectBindingPattern = "ObjectBindingPattern";
const ekBindingIdentifier = "BindingIdentifier";
const ekForOfStatement = "ForOfStatement";
const ekInterpolation = "Interpolation";
const ekArrayDestructuring = "ArrayDestructuring";
const ekObjectDestructuring = "ObjectDestructuring";
const ekDestructuringAssignmentLeaf = "DestructuringAssignmentLeaf";
const ekCustom = "Custom";
class CustomExpression {
  constructor(value) {
    this.value = value;
    this.$kind = ekCustom;
  }
  evaluate(...params) {
    return this.value;
  }
  assign(...params) {
    return params;
  }
  bind(...params) {
  }
  unbind(...params) {
  }
  accept(_visitor) {
    return void 0;
  }
}
class BindingBehaviorExpression {
  constructor(expression, name2, args) {
    this.expression = expression;
    this.name = name2;
    this.args = args;
    this.$kind = ekBindingBehavior;
    this.key = `_bb_${name2}`;
  }
}
class ValueConverterExpression {
  constructor(expression, name2, args) {
    this.expression = expression;
    this.name = name2;
    this.args = args;
    this.$kind = ekValueConverter;
  }
}
class AssignExpression {
  constructor(target, value, op = "=") {
    this.target = target;
    this.value = value;
    this.op = op;
    this.$kind = ekAssign;
  }
}
class ConditionalExpression {
  constructor(condition, yes, no) {
    this.condition = condition;
    this.yes = yes;
    this.no = no;
    this.$kind = ekConditional;
  }
}
class AccessGlobalExpression {
  constructor(name2) {
    this.name = name2;
    this.$kind = ekAccessGlobal;
  }
}
class AccessThisExpression {
  constructor(ancestor = 0) {
    this.ancestor = ancestor;
    this.$kind = ekAccessThis;
  }
}
class AccessBoundaryExpression {
  constructor() {
    this.$kind = ekAccessBoundary;
  }
}
class AccessScopeExpression {
  constructor(name2, ancestor = 0) {
    this.name = name2;
    this.ancestor = ancestor;
    this.$kind = ekAccessScope;
  }
}
const isAccessGlobal = (ast) => ast.$kind === ekAccessGlobal || (ast.$kind === ekAccessMember || ast.$kind === ekAccessKeyed) && ast.accessGlobal;
class AccessMemberExpression {
  constructor(object, name2, optional2 = false) {
    this.object = object;
    this.name = name2;
    this.optional = optional2;
    this.$kind = ekAccessMember;
    this.accessGlobal = isAccessGlobal(object);
  }
}
class AccessKeyedExpression {
  constructor(object, key, optional2 = false) {
    this.object = object;
    this.key = key;
    this.optional = optional2;
    this.$kind = ekAccessKeyed;
    this.accessGlobal = isAccessGlobal(object);
  }
}
class NewExpression {
  constructor(func, args) {
    this.func = func;
    this.args = args;
    this.$kind = ekNew;
  }
}
class CallScopeExpression {
  constructor(name2, args, ancestor = 0, optional2 = false) {
    this.name = name2;
    this.args = args;
    this.ancestor = ancestor;
    this.optional = optional2;
    this.$kind = ekCallScope;
  }
}
class CallMemberExpression {
  constructor(object, name2, args, optionalMember = false, optionalCall = false) {
    this.object = object;
    this.name = name2;
    this.args = args;
    this.optionalMember = optionalMember;
    this.optionalCall = optionalCall;
    this.$kind = ekCallMember;
  }
}
class CallFunctionExpression {
  constructor(func, args, optional2 = false) {
    this.func = func;
    this.args = args;
    this.optional = optional2;
    this.$kind = ekCallFunction;
  }
}
class CallGlobalExpression {
  constructor(name2, args) {
    this.name = name2;
    this.args = args;
    this.$kind = ekCallGlobal;
  }
}
class BinaryExpression {
  constructor(operation, left2, right2) {
    this.operation = operation;
    this.left = left2;
    this.right = right2;
    this.$kind = ekBinary;
  }
}
class UnaryExpression {
  constructor(operation, expression, pos = 0) {
    this.operation = operation;
    this.expression = expression;
    this.pos = pos;
    this.$kind = ekUnary;
  }
}
class PrimitiveLiteralExpression {
  constructor(value) {
    this.value = value;
    this.$kind = ekPrimitiveLiteral;
  }
}
PrimitiveLiteralExpression.$undefined = new PrimitiveLiteralExpression(void 0);
PrimitiveLiteralExpression.$null = new PrimitiveLiteralExpression(null);
PrimitiveLiteralExpression.$true = new PrimitiveLiteralExpression(true);
PrimitiveLiteralExpression.$false = new PrimitiveLiteralExpression(false);
PrimitiveLiteralExpression.$empty = new PrimitiveLiteralExpression("");
class ArrayLiteralExpression {
  constructor(elements) {
    this.elements = elements;
    this.$kind = ekArrayLiteral;
  }
}
ArrayLiteralExpression.$empty = new ArrayLiteralExpression(emptyArray);
class ObjectLiteralExpression {
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
    this.$kind = ekObjectLiteral;
  }
}
ObjectLiteralExpression.$empty = new ObjectLiteralExpression(emptyArray, emptyArray);
class TemplateExpression {
  constructor(cooked, expressions = emptyArray) {
    this.cooked = cooked;
    this.expressions = expressions;
    this.$kind = ekTemplate;
  }
}
TemplateExpression.$empty = new TemplateExpression([""]);
class TaggedTemplateExpression {
  constructor(cooked, raw, func, expressions = emptyArray) {
    this.cooked = cooked;
    this.func = func;
    this.expressions = expressions;
    this.$kind = ekTaggedTemplate;
    cooked.raw = raw;
  }
}
class ArrayBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(elements) {
    this.elements = elements;
    this.$kind = ekArrayBindingPattern;
  }
}
class ObjectBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
    this.$kind = ekObjectBindingPattern;
  }
}
class BindingIdentifier {
  constructor(name2) {
    this.name = name2;
    this.$kind = ekBindingIdentifier;
  }
}
class ForOfStatement {
  constructor(declaration, iterable, semiIdx) {
    this.declaration = declaration;
    this.iterable = iterable;
    this.semiIdx = semiIdx;
    this.$kind = ekForOfStatement;
  }
}
class Interpolation {
  constructor(parts, expressions = emptyArray) {
    this.parts = parts;
    this.expressions = expressions;
    this.$kind = ekInterpolation;
    this.isMulti = expressions.length > 1;
    this.firstExpression = expressions[0];
  }
}
class DestructuringAssignmentExpression {
  constructor($kind, list, source, initializer) {
    this.$kind = $kind;
    this.list = list;
    this.source = source;
    this.initializer = initializer;
  }
}
class DestructuringAssignmentSingleExpression {
  constructor(target, source, initializer) {
    this.target = target;
    this.source = source;
    this.initializer = initializer;
    this.$kind = ekDestructuringAssignmentLeaf;
  }
}
class ArrowFunction {
  constructor(args, body, rest = false) {
    this.args = args;
    this.body = body;
    this.rest = rest;
    this.$kind = ekArrowFunction;
  }
}
const safeString$1 = String;
const createLookup = () => /* @__PURE__ */ Object.create(null);
const createMappedError$3 = (code, ...details) => new Error(`AUR${safeString$1(code).padStart(4, "0")}: ${getMessageByCode$3(code, ...details)}`);
const errorsMap$3 = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    151
    /* ErrorNames.parse_invalid_start */
  ]: `Expression error: invalid start: "{{0}}"`,
  [
    152
    /* ErrorNames.parse_no_spread */
  ]: `Expression error: spread operator is not supported: "{{0}}"`,
  [
    153
    /* ErrorNames.parse_expected_identifier */
  ]: `Expression error: expected identifier: "{{0}}"`,
  [
    154
    /* ErrorNames.parse_invalid_member_expr */
  ]: `Expression error: invalid member expression: "{{0}}"`,
  [
    155
    /* ErrorNames.parse_unexpected_end */
  ]: `Expression error: unexpected end of expression: "{{0}}"`,
  [
    156
    /* ErrorNames.parse_unconsumed_token */
  ]: `Expression error: unconsumed token: "{{0}}" at position {{1}} of "{{2}}"`,
  [
    157
    /* ErrorNames.parse_invalid_empty */
  ]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,
  [
    158
    /* ErrorNames.parse_left_hand_side_not_assignable */
  ]: `Expression error: left hand side of expression is not assignable: "{{0}}"`,
  [
    159
    /* ErrorNames.parse_expected_converter_identifier */
  ]: `Expression error: expected identifier to come after value converter operator: "{{0}}"`,
  [
    160
    /* ErrorNames.parse_expected_behavior_identifier */
  ]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,
  [
    161
    /* ErrorNames.parse_unexpected_keyword_of */
  ]: `Expression error: unexpected keyword "of": "{{0}}"`,
  [
    162
    /* ErrorNames.parse_unexpected_keyword_import */
  ]: `Expression error: unexpected keyword "import": "{{0}}"`,
  [
    163
    /* ErrorNames.parse_invalid_identifier_in_forof */
  ]: `Expression error: invalid BindingIdentifier at left hand side of "of": "{{0}}" | kind: {{1}}`,
  [
    164
    /* ErrorNames.parse_invalid_identifier_object_literal_key */
  ]: `Expression error: invalid or unsupported property definition in object literal: "{{0}}"`,
  [
    165
    /* ErrorNames.parse_unterminated_string */
  ]: `Expression error: unterminated quote in string literal: "{{0}}"`,
  [
    166
    /* ErrorNames.parse_unterminated_template_string */
  ]: `Expression error: unterminated template string: "{{0}}"`,
  [
    167
    /* ErrorNames.parse_missing_expected_token */
  ]: `Expression error: missing expected token "{{0}}" in "{{1}}"`,
  [
    168
    /* ErrorNames.parse_unexpected_character */
  ]: `Expression error: unexpected character: "{{0}}"`,
  [
    170
    /* ErrorNames.parse_unexpected_token_destructuring */
  ]: `Expression error: unexpected "{{0}}" at position "{{1}}" for destructuring assignment in "{{2}}"`,
  [
    171
    /* ErrorNames.parse_unexpected_token_optional_chain */
  ]: `Expression error: unexpected {{0}} at position "{{1}}" for optional chain in "{{2}}"`,
  [
    172
    /* ErrorNames.parse_invalid_tag_in_optional_chain */
  ]: `Expression error: invalid tagged template on optional chain in "{{1}}"`,
  [
    173
    /* ErrorNames.parse_invalid_arrow_params */
  ]: `Expression error: invalid arrow parameter list in "{{0}}"`,
  [
    174
    /* ErrorNames.parse_no_arrow_param_default_value */
  ]: `Expression error: arrow function with default parameters is not supported: "{{0}}"`,
  [
    175
    /* ErrorNames.parse_no_arrow_param_destructuring */
  ]: `Expression error: arrow function with destructuring parameters is not supported: "{{0}}"`,
  [
    176
    /* ErrorNames.parse_rest_must_be_last */
  ]: `Expression error: rest parameter must be last formal parameter in arrow function: "{{0}}"`,
  [
    178
    /* ErrorNames.parse_no_arrow_fn_body */
  ]: `Expression error: arrow function with function body is not supported: "{{0}}"`,
  [
    179
    /* ErrorNames.parse_unexpected_double_dot */
  ]: `Expression error: unexpected token '.' at position "{{1}}" in "{{0}}"`
};
const getMessageByCode$3 = (name2, ...details) => {
  let cooked = errorsMap$3[name2];
  for (let i = 0; i < details.length; ++i) {
    const regex = new RegExp(`{{${i}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i];
      if (value != null) {
        switch (method) {
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = safeString$1(value[method.slice(1)]);
            } else {
              value = safeString$1(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
const IExpressionParser = /* @__PURE__ */ DI.createInterface("IExpressionParser");
class ExpressionParser {
  constructor() {
    this._expressionLookup = createLookup();
    this._forOfLookup = createLookup();
    this._interpolationLookup = createLookup();
  }
  parse(expression, expressionType) {
    let found;
    switch (expressionType) {
      case etIsCustom:
        return new CustomExpression(expression);
      case etInterpolation$2:
        found = this._interpolationLookup[expression];
        if (found === void 0) {
          found = this._interpolationLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      case etIsIterator$1:
        found = this._forOfLookup[expression];
        if (found === void 0) {
          found = this._forOfLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      default: {
        if (expression.length === 0) {
          if (expressionType === etIsFunction$2 || expressionType === etIsProperty$2) {
            return PrimitiveLiteralExpression.$empty;
          }
          throw invalidEmptyExpression();
        }
        found = this._expressionLookup[expression];
        if (found === void 0) {
          found = this._expressionLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      }
    }
  }
  /** @internal */
  $parse(expression, expressionType) {
    $input = expression;
    $index = 0;
    $length = expression.length;
    $scopeDepth = 0;
    $startIndex = 0;
    $currentToken = 6291456;
    $tokenValue = "";
    $currentChar = $charCodeAt(0);
    $assignable = true;
    $optional = false;
    $accessGlobal = true;
    $semicolonIndex = -1;
    return parse(61, expressionType === void 0 ? etIsProperty$2 : expressionType);
  }
}
ExpressionParser.register = createImplementationRegister(IExpressionParser);
function unescapeCode(code) {
  switch (code) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return code;
  }
}
const $false = PrimitiveLiteralExpression.$false;
const $true = PrimitiveLiteralExpression.$true;
const $null = PrimitiveLiteralExpression.$null;
const $undefined = PrimitiveLiteralExpression.$undefined;
const $this = new AccessThisExpression(0);
const $parent = new AccessThisExpression(1);
const boundary = new AccessBoundaryExpression();
const etNone = "None";
const etInterpolation$2 = "Interpolation";
const etIsIterator$1 = "IsIterator";
const etIsChainable = "IsChainable";
const etIsFunction$2 = "IsFunction";
const etIsProperty$2 = "IsProperty";
const etIsCustom = "IsCustom";
let $input = "";
let $index = 0;
let $length = 0;
let $scopeDepth = 0;
let $startIndex = 0;
let $currentToken = 6291456;
let $tokenValue = "";
let $currentChar;
let $assignable = true;
let $optional = false;
let $accessGlobal = true;
let $semicolonIndex = -1;
const stringFromCharCode = String.fromCharCode;
const $charCodeAt = (index) => $input.charCodeAt(index);
const $tokenRaw = () => $input.slice($startIndex, $index);
const globalNames = "Infinity NaN isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent Array BigInt Boolean Date Map Number Object RegExp Set String JSON Math Intl".split(" ");
function parse(minPrecedence, expressionType) {
  if (expressionType === etIsCustom) {
    return new CustomExpression($input);
  }
  if ($index === 0) {
    if (expressionType === etInterpolation$2) {
      return parseInterpolation();
    }
    nextToken();
    if ($currentToken & 4194304) {
      throw invalidStartOfExpression();
    }
  }
  $assignable = 577 > minPrecedence;
  $optional = false;
  $accessGlobal = 579 > minPrecedence;
  let optionalThisTail = false;
  let result = void 0;
  let ancestor = 0;
  if ($currentToken & 131072) {
    const op = TokenValues[
      $currentToken & 63
      /* Token.Type */
    ];
    nextToken();
    result = new UnaryExpression(op, parse(579, expressionType));
    $assignable = false;
  } else {
    primary: switch ($currentToken) {
      case 12296:
        ancestor = $scopeDepth;
        $assignable = false;
        $accessGlobal = false;
        do {
          nextToken();
          ++ancestor;
          switch ($currentToken) {
            case 65547:
              nextToken();
              if (($currentToken & 12288) === 0) {
                throw expectedIdentifier();
              }
              break;
            case 12:
            case 13:
              throw expectedIdentifier();
            case 2162702:
              $optional = true;
              nextToken();
              if (($currentToken & 12288) === 0) {
                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);
                optionalThisTail = true;
                break primary;
              }
              break;
            default:
              if ($currentToken & 2097152) {
                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);
                break primary;
              }
              throw invalidMemberExpression();
          }
        } while ($currentToken === 12296);
      // falls through
      case 4096: {
        const id2 = $tokenValue;
        if (expressionType === etIsIterator$1) {
          result = new BindingIdentifier(id2);
        } else if ($accessGlobal && globalNames.includes(id2)) {
          result = new AccessGlobalExpression(id2);
        } else if ($accessGlobal && id2 === "import") {
          throw unexpectedImportKeyword();
        } else {
          result = new AccessScopeExpression(id2, ancestor);
        }
        $assignable = !$optional;
        nextToken();
        if (consumeOpt(
          53
          /* Token.Arrow */
        )) {
          if ($currentToken === 524298) {
            throw functionBodyInArrowFn();
          }
          const _optional = $optional;
          const _scopeDepth = $scopeDepth;
          ++$scopeDepth;
          const body = parse(62, etNone);
          $optional = _optional;
          $scopeDepth = _scopeDepth;
          $assignable = false;
          result = new ArrowFunction([new BindingIdentifier(id2)], body);
        }
        break;
      }
      case 12:
        throw unexpectedDoubleDot();
      case 13:
        throw invalidSpreadOp();
      case 12293:
        $assignable = false;
        nextToken();
        switch ($scopeDepth) {
          case 0:
            result = $this;
            break;
          case 1:
            result = $parent;
            break;
          default:
            result = new AccessThisExpression($scopeDepth);
            break;
        }
        break;
      case 12294:
        $assignable = false;
        nextToken();
        result = boundary;
        break;
      case 2688009:
        result = parseCoverParenthesizedExpressionAndArrowParameterList(expressionType);
        break;
      case 2688020:
        result = $input.search(/\s+of\s+/) > $index ? parseArrayDestructuring() : parseArrayLiteralExpression(expressionType);
        break;
      case 524298:
        result = parseObjectLiteralExpression(expressionType);
        break;
      case 2163762:
        result = new TemplateExpression([$tokenValue]);
        $assignable = false;
        nextToken();
        break;
      case 2163763:
        result = parseTemplate(expressionType, result, false);
        break;
      case 16384:
      case 32768:
        result = new PrimitiveLiteralExpression($tokenValue);
        $assignable = false;
        nextToken();
        break;
      case 8194:
      case 8195:
      case 8193:
      case 8192:
        result = TokenValues[
          $currentToken & 63
          /* Token.Type */
        ];
        $assignable = false;
        nextToken();
        break;
      case 8196: {
        nextToken();
        const callee = parse(578, expressionType);
        let args;
        if ($currentToken === 2688009) {
          args = parseArguments();
        } else {
          args = [];
          nextToken();
        }
        result = new NewExpression(callee, args);
        $assignable = false;
        break;
      }
      default:
        if ($index >= $length) {
          throw unexpectedEndOfExpression();
        } else {
          throw unconsumedToken();
        }
    }
    if (expressionType === etIsIterator$1) {
      return parseForOfStatement(result);
    }
    switch ($currentToken) {
      case 2228282:
      case 2228283:
        result = new UnaryExpression(TokenValues[
          $currentToken & 63
          /* Token.Type */
        ], result, 1);
        nextToken();
        $assignable = false;
        break;
    }
    if (579 < minPrecedence) {
      return result;
    }
    if ($currentToken === 12 || $currentToken === 13) {
      throw expectedIdentifier();
    }
    if (result.$kind === ekAccessThis) {
      switch ($currentToken) {
        case 2162702:
          $optional = true;
          $assignable = false;
          nextToken();
          if (($currentToken & 13312) === 0) {
            throw unexpectedTokenInOptionalChain();
          }
          if ($currentToken & 12288) {
            result = new AccessScopeExpression($tokenValue, result.ancestor);
            nextToken();
          } else if ($currentToken === 2688009) {
            result = new CallFunctionExpression(result, parseArguments(), true);
          } else if ($currentToken === 2688020) {
            result = parseKeyedExpression(result, true);
          } else {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          break;
        case 65547:
          $assignable = !$optional;
          nextToken();
          if (($currentToken & 12288) === 0) {
            throw expectedIdentifier();
          }
          result = new AccessScopeExpression($tokenValue, result.ancestor);
          nextToken();
          break;
        case 12:
        case 13:
          throw expectedIdentifier();
        case 2688009:
          result = new CallFunctionExpression(result, parseArguments(), optionalThisTail);
          break;
        case 2688020:
          result = parseKeyedExpression(result, optionalThisTail);
          break;
        case 2163762:
          result = createTemplateTail(result);
          break;
        case 2163763:
          result = parseTemplate(expressionType, result, true);
          break;
      }
    }
    while (($currentToken & 65536) > 0) {
      switch ($currentToken) {
        case 2162702:
          result = parseOptionalChainLHS(result);
          break;
        case 65547:
          nextToken();
          if (($currentToken & 12288) === 0) {
            throw expectedIdentifier();
          }
          result = parseMemberExpressionLHS(result, false);
          break;
        case 12:
        case 13:
          throw expectedIdentifier();
        case 2688009:
          if (578 === minPrecedence) {
            return result;
          }
          if (result.$kind === ekAccessScope) {
            result = new CallScopeExpression(result.name, parseArguments(), result.ancestor, false);
          } else if (result.$kind === ekAccessMember) {
            result = new CallMemberExpression(result.object, result.name, parseArguments(), result.optional, false);
          } else if (result.$kind === ekAccessGlobal) {
            result = new CallGlobalExpression(result.name, parseArguments());
          } else {
            result = new CallFunctionExpression(result, parseArguments(), false);
          }
          break;
        case 2688020:
          result = parseKeyedExpression(result, false);
          break;
        case 2163762:
          if ($optional) {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          result = createTemplateTail(result);
          break;
        case 2163763:
          if ($optional) {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          result = parseTemplate(expressionType, result, true);
          break;
      }
    }
  }
  if ($currentToken === 12 || $currentToken === 13) {
    throw expectedIdentifier();
  }
  if (577 < minPrecedence) {
    return result;
  }
  while (($currentToken & 262144) > 0) {
    const opToken = $currentToken;
    if ((opToken & 960) <= minPrecedence) {
      break;
    }
    nextToken();
    result = new BinaryExpression(TokenValues[
      opToken & 63
      /* Token.Type */
    ], result, parse(opToken & 960, expressionType));
    $assignable = false;
  }
  if (63 < minPrecedence) {
    return result;
  }
  if (consumeOpt(
    6291480
    /* Token.Question */
  )) {
    const yes = parse(62, expressionType);
    consume(
      6291478
      /* Token.Colon */
    );
    result = new ConditionalExpression(result, yes, parse(62, expressionType));
    $assignable = false;
  }
  if (62 < minPrecedence) {
    return result;
  }
  switch ($currentToken) {
    case 4194352:
    case 4194358:
    case 4194359:
    case 4194360:
    case 4194361: {
      if (!$assignable) {
        throw lhsNotAssignable();
      }
      const op = TokenValues[
        $currentToken & 63
        /* Token.Type */
      ];
      nextToken();
      result = new AssignExpression(result, parse(62, expressionType), op);
      break;
    }
  }
  if (61 < minPrecedence) {
    return result;
  }
  while (consumeOpt(
    6291482
    /* Token.Bar */
  )) {
    if ($currentToken === 6291456) {
      throw expectedValueConverterIdentifier();
    }
    const name2 = $tokenValue;
    nextToken();
    const args = new Array();
    while (consumeOpt(
      6291478
      /* Token.Colon */
    )) {
      args.push(parse(62, expressionType));
    }
    result = new ValueConverterExpression(result, name2, args);
  }
  while (consumeOpt(
    6291481
    /* Token.Ampersand */
  )) {
    if ($currentToken === 6291456) {
      throw expectedBindingBehaviorIdentifier();
    }
    const name2 = $tokenValue;
    nextToken();
    const args = new Array();
    while (consumeOpt(
      6291478
      /* Token.Colon */
    )) {
      args.push(parse(62, expressionType));
    }
    result = new BindingBehaviorExpression(result, name2, args);
  }
  if ($currentToken !== 6291456) {
    if (expressionType === etInterpolation$2 && $currentToken === 7340047) {
      return result;
    }
    if (expressionType === etIsChainable && $currentToken === 6291479) {
      if ($index === $length) {
        throw unconsumedToken();
      }
      $semicolonIndex = $index - 1;
      return result;
    }
    if ($tokenRaw() === "of") {
      throw unexpectedOfKeyword();
    }
    throw unconsumedToken();
  }
  return result;
}
function parseArrayDestructuring() {
  const items = [];
  const dae = new DestructuringAssignmentExpression(ekArrayDestructuring, items, void 0, void 0);
  let target = "";
  let $continue = true;
  let index = 0;
  while ($continue) {
    nextToken();
    switch ($currentToken) {
      case 7340053:
        $continue = false;
        addItem();
        break;
      case 6291475:
        addItem();
        break;
      case 4096:
        target = $tokenRaw();
        break;
      default:
        throw unexpectedTokenInDestructuring();
    }
  }
  consume(
    7340053
    /* Token.CloseBracket */
  );
  return dae;
  function addItem() {
    if (target !== "") {
      items.push(new DestructuringAssignmentSingleExpression(new AccessMemberExpression($this, target), new AccessKeyedExpression($this, new PrimitiveLiteralExpression(index++)), void 0));
      target = "";
    } else {
      index++;
    }
  }
}
function parseArguments() {
  const _optional = $optional;
  nextToken();
  const args = [];
  while ($currentToken !== 7340048) {
    args.push(parse(62, etNone));
    if (!consumeOpt(
      6291475
      /* Token.Comma */
    )) {
      break;
    }
  }
  consume(
    7340048
    /* Token.CloseParen */
  );
  $assignable = false;
  $optional = _optional;
  return args;
}
function parseKeyedExpression(result, optional2) {
  const _optional = $optional;
  nextToken();
  result = new AccessKeyedExpression(result, parse(62, etNone), optional2);
  consume(
    7340053
    /* Token.CloseBracket */
  );
  $assignable = !_optional;
  $optional = _optional;
  return result;
}
function parseOptionalChainLHS(lhs) {
  $optional = true;
  $assignable = false;
  nextToken();
  if (($currentToken & 13312) === 0) {
    throw unexpectedTokenInOptionalChain();
  }
  if ($currentToken & 12288) {
    return parseMemberExpressionLHS(lhs, true);
  }
  if ($currentToken === 2688009) {
    if (lhs.$kind === ekAccessScope) {
      return new CallScopeExpression(lhs.name, parseArguments(), lhs.ancestor, true);
    } else if (lhs.$kind === ekAccessMember) {
      return new CallMemberExpression(lhs.object, lhs.name, parseArguments(), lhs.optional, true);
    } else {
      return new CallFunctionExpression(lhs, parseArguments(), true);
    }
  }
  if ($currentToken === 2688020) {
    return parseKeyedExpression(lhs, true);
  }
  throw invalidTaggedTemplateOnOptionalChain();
}
function parseMemberExpressionLHS(lhs, optional2) {
  const rhs = $tokenValue;
  switch ($currentToken) {
    case 2162702: {
      $optional = true;
      $assignable = false;
      const indexSave = $index;
      const startIndexSave = $startIndex;
      const currentTokenSave = $currentToken;
      const currentCharSave = $currentChar;
      const tokenValueSave = $tokenValue;
      const assignableSave = $assignable;
      const optionalSave = $optional;
      nextToken();
      if (($currentToken & 13312) === 0) {
        throw unexpectedTokenInOptionalChain();
      }
      if ($currentToken === 2688009) {
        return new CallMemberExpression(lhs, rhs, parseArguments(), optional2, true);
      }
      $index = indexSave;
      $startIndex = startIndexSave;
      $currentToken = currentTokenSave;
      $currentChar = currentCharSave;
      $tokenValue = tokenValueSave;
      $assignable = assignableSave;
      $optional = optionalSave;
      return new AccessMemberExpression(lhs, rhs, optional2);
    }
    case 2688009: {
      $assignable = false;
      return new CallMemberExpression(lhs, rhs, parseArguments(), optional2, false);
    }
    default: {
      $assignable = !$optional;
      nextToken();
      return new AccessMemberExpression(lhs, rhs, optional2);
    }
  }
}
function parseCoverParenthesizedExpressionAndArrowParameterList(expressionType) {
  nextToken();
  const indexSave = $index;
  const startIndexSave = $startIndex;
  const currentTokenSave = $currentToken;
  const currentCharSave = $currentChar;
  const tokenValueSave = $tokenValue;
  const optionalSave = $optional;
  const arrowParams = [];
  let paramsState = 1;
  let isParamList = false;
  loop: while (true) {
    if ($currentToken === 13) {
      nextToken();
      if ($currentToken !== 4096) {
        throw expectedIdentifier();
      }
      arrowParams.push(new BindingIdentifier($tokenValue));
      nextToken();
      if ($currentToken === 6291475) {
        throw restParamsMustBeLastParam();
      }
      if ($currentToken !== 7340048) {
        throw invalidSpreadOp();
      }
      nextToken();
      if ($currentToken !== 53) {
        throw invalidSpreadOp();
      }
      nextToken();
      const _optional2 = $optional;
      const _scopeDepth = $scopeDepth;
      ++$scopeDepth;
      const body = parse(62, etNone);
      $optional = _optional2;
      $scopeDepth = _scopeDepth;
      $assignable = false;
      return new ArrowFunction(arrowParams, body, true);
    }
    switch ($currentToken) {
      case 4096:
        arrowParams.push(new BindingIdentifier($tokenValue));
        nextToken();
        break;
      case 7340048:
        nextToken();
        break loop;
      /* eslint-disable */
      case 524298:
      // ({     - may be a valid parenthesized expression
      case 2688020:
        nextToken();
        paramsState = 4;
        break;
      /* eslint-enable */
      case 6291475:
        paramsState = 2;
        isParamList = true;
        break loop;
      case 2688009:
        paramsState = 2;
        break loop;
      default:
        nextToken();
        paramsState = 2;
        break;
    }
    switch ($currentToken) {
      case 6291475:
        nextToken();
        isParamList = true;
        if (paramsState === 1) {
          break;
        }
        break loop;
      case 7340048:
        nextToken();
        break loop;
      case 4194352:
        if (paramsState === 1) {
          paramsState = 3;
        }
        break loop;
      case 53:
        if (isParamList) {
          throw invalidArrowParameterList();
        }
        nextToken();
        paramsState = 2;
        break loop;
      default:
        if (paramsState === 1) {
          paramsState = 2;
        }
        break loop;
    }
  }
  if ($currentToken === 53) {
    if (paramsState === 1) {
      nextToken();
      if ($currentToken === 524298) {
        throw functionBodyInArrowFn();
      }
      const _optional2 = $optional;
      const _scopeDepth = $scopeDepth;
      ++$scopeDepth;
      const body = parse(62, etNone);
      $optional = _optional2;
      $scopeDepth = _scopeDepth;
      $assignable = false;
      return new ArrowFunction(arrowParams, body);
    }
    throw invalidArrowParameterList();
  } else if (paramsState === 1 && arrowParams.length === 0) {
    throw missingExpectedToken(
      53
      /* Token.Arrow */
    );
  }
  if (isParamList) {
    switch (paramsState) {
      case 2:
        throw invalidArrowParameterList();
      case 3:
        throw defaultParamsInArrowFn();
      case 4:
        throw destructuringParamsInArrowFn();
    }
  }
  $index = indexSave;
  $startIndex = startIndexSave;
  $currentToken = currentTokenSave;
  $currentChar = currentCharSave;
  $tokenValue = tokenValueSave;
  $optional = optionalSave;
  const _optional = $optional;
  const expr = parse(62, expressionType);
  $optional = _optional;
  consume(
    7340048
    /* Token.CloseParen */
  );
  if ($currentToken === 53) {
    switch (paramsState) {
      case 2:
        throw invalidArrowParameterList();
      case 3:
        throw defaultParamsInArrowFn();
      case 4:
        throw destructuringParamsInArrowFn();
    }
  }
  return expr;
}
function parseArrayLiteralExpression(expressionType) {
  const _optional = $optional;
  nextToken();
  const elements = new Array();
  while ($currentToken !== 7340053) {
    if (consumeOpt(
      6291475
      /* Token.Comma */
    )) {
      elements.push($undefined);
      if ($currentToken === 7340053) {
        break;
      }
    } else {
      elements.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
      if (consumeOpt(
        6291475
        /* Token.Comma */
      )) {
        if ($currentToken === 7340053) {
          break;
        }
      } else {
        break;
      }
    }
  }
  $optional = _optional;
  consume(
    7340053
    /* Token.CloseBracket */
  );
  if (expressionType === etIsIterator$1) {
    return new ArrayBindingPattern(elements);
  } else {
    $assignable = false;
    return new ArrayLiteralExpression(elements);
  }
}
const allowedForExprKinds = [ekArrayBindingPattern, ekObjectBindingPattern, ekBindingIdentifier, ekArrayDestructuring, ekObjectDestructuring];
function parseForOfStatement(result) {
  if (!allowedForExprKinds.includes(result.$kind)) {
    throw invalidLHSBindingIdentifierInForOf(result.$kind);
  }
  if ($currentToken !== 4204596) {
    throw invalidLHSBindingIdentifierInForOf(result.$kind);
  }
  nextToken();
  const declaration = result;
  const statement = parse(61, etIsChainable);
  return new ForOfStatement(declaration, statement, $semicolonIndex);
}
function parseObjectLiteralExpression(expressionType) {
  const _optional = $optional;
  const keys = new Array();
  const values = new Array();
  nextToken();
  while ($currentToken !== 7340047) {
    keys.push($tokenValue);
    if ($currentToken & 49152) {
      nextToken();
      consume(
        6291478
        /* Token.Colon */
      );
      values.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
    } else if ($currentToken & 12288) {
      const currentChar = $currentChar;
      const currentToken = $currentToken;
      const index = $index;
      nextToken();
      if (consumeOpt(
        6291478
        /* Token.Colon */
      )) {
        values.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
      } else {
        $currentChar = currentChar;
        $currentToken = currentToken;
        $index = index;
        values.push(parse(580, expressionType === etIsIterator$1 ? etNone : expressionType));
      }
    } else {
      throw invalidPropDefInObjLiteral();
    }
    if ($currentToken !== 7340047) {
      consume(
        6291475
        /* Token.Comma */
      );
    }
  }
  $optional = _optional;
  consume(
    7340047
    /* Token.CloseBrace */
  );
  if (expressionType === etIsIterator$1) {
    return new ObjectBindingPattern(keys, values);
  } else {
    $assignable = false;
    return new ObjectLiteralExpression(keys, values);
  }
}
function parseInterpolation() {
  const parts = [];
  const expressions = [];
  const length = $length;
  let result = "";
  while ($index < length) {
    switch ($currentChar) {
      case 36:
        if ($charCodeAt($index + 1) === 123) {
          parts.push(result);
          result = "";
          $index += 2;
          $currentChar = $charCodeAt($index);
          nextToken();
          const expression = parse(61, etInterpolation$2);
          expressions.push(expression);
          continue;
        } else {
          result += "$";
        }
        break;
      case 92:
        result += stringFromCharCode(unescapeCode(nextChar()));
        break;
      default:
        result += stringFromCharCode($currentChar);
    }
    nextChar();
  }
  if (expressions.length) {
    parts.push(result);
    return new Interpolation(parts, expressions);
  }
  return null;
}
function parseTemplate(expressionType, result, tagged) {
  const _optional = $optional;
  const cooked = [$tokenValue];
  consume(
    2163763
    /* Token.TemplateContinuation */
  );
  const expressions = [parse(62, expressionType)];
  while (($currentToken = scanTemplateTail()) !== 2163762) {
    cooked.push($tokenValue);
    consume(
      2163763
      /* Token.TemplateContinuation */
    );
    expressions.push(parse(62, expressionType));
  }
  cooked.push($tokenValue);
  $assignable = false;
  $optional = _optional;
  if (tagged) {
    nextToken();
    return new TaggedTemplateExpression(cooked, cooked, result, expressions);
  } else {
    nextToken();
    return new TemplateExpression(cooked, expressions);
  }
}
function createTemplateTail(result) {
  $assignable = false;
  const strings = [$tokenValue];
  nextToken();
  return new TaggedTemplateExpression(strings, strings, result);
}
function nextToken() {
  while ($index < $length) {
    $startIndex = $index;
    if (($currentToken = CharScanners[$currentChar]()) != null) {
      return;
    }
  }
  $currentToken = 6291456;
}
function nextChar() {
  return $currentChar = $charCodeAt(++$index);
}
function scanIdentifier() {
  while (IdParts[nextChar()])
    ;
  const token = KeywordLookup[$tokenValue = $tokenRaw()];
  return token === void 0 ? 4096 : token;
}
function scanNumber(isFloat) {
  let char = $currentChar;
  if (isFloat === false) {
    do {
      char = nextChar();
    } while (char <= 57 && char >= 48);
    if (char !== 46) {
      $tokenValue = parseInt($tokenRaw(), 10);
      return 32768;
    }
    char = nextChar();
    if ($index >= $length) {
      $tokenValue = parseInt($tokenRaw().slice(0, -1), 10);
      return 32768;
    }
  }
  if (char <= 57 && char >= 48) {
    do {
      char = nextChar();
    } while (char <= 57 && char >= 48);
  } else {
    $currentChar = $charCodeAt(--$index);
  }
  $tokenValue = parseFloat($tokenRaw());
  return 32768;
}
function scanString() {
  const quote = $currentChar;
  nextChar();
  let unescaped = 0;
  const buffer = new Array();
  let marker = $index;
  while ($currentChar !== quote) {
    if ($currentChar === 92) {
      buffer.push($input.slice(marker, $index));
      nextChar();
      unescaped = unescapeCode($currentChar);
      nextChar();
      buffer.push(stringFromCharCode(unescaped));
      marker = $index;
    } else if ($index >= $length) {
      throw unterminatedStringLiteral();
    } else {
      nextChar();
    }
  }
  const last = $input.slice(marker, $index);
  nextChar();
  buffer.push(last);
  const unescapedStr = buffer.join("");
  $tokenValue = unescapedStr;
  return 16384;
}
function scanTemplate() {
  let tail = true;
  let result = "";
  while (nextChar() !== 96) {
    if ($currentChar === 36) {
      if ($index + 1 < $length && $charCodeAt($index + 1) === 123) {
        $index++;
        tail = false;
        break;
      } else {
        result += "$";
      }
    } else if ($currentChar === 92) {
      result += stringFromCharCode(unescapeCode(nextChar()));
    } else {
      if ($index >= $length) {
        throw unterminatedTemplateLiteral();
      }
      result += stringFromCharCode($currentChar);
    }
  }
  nextChar();
  $tokenValue = result;
  if (tail) {
    return 2163762;
  }
  return 2163763;
}
const scanTemplateTail = () => {
  if ($index >= $length) {
    throw unterminatedTemplateLiteral();
  }
  $index--;
  return scanTemplate();
};
const consumeOpt = (token) => {
  if ($currentToken === token) {
    nextToken();
    return true;
  }
  return false;
};
const consume = (token) => {
  if ($currentToken === token) {
    nextToken();
  } else {
    throw missingExpectedToken(token);
  }
};
const invalidStartOfExpression = () => createMappedError$3(151, $input);
const invalidSpreadOp = () => createMappedError$3(152, $input);
const expectedIdentifier = () => createMappedError$3(153, $input);
const invalidMemberExpression = () => createMappedError$3(154, $input);
const unexpectedEndOfExpression = () => createMappedError$3(155, $input);
const unconsumedToken = () => createMappedError$3(156, $tokenRaw(), $index, $input);
const invalidEmptyExpression = () => createMappedError$3(
  157
  /* ErrorNames.parse_invalid_empty */
);
const lhsNotAssignable = () => createMappedError$3(158, $input);
const expectedValueConverterIdentifier = () => createMappedError$3(159, $input);
const expectedBindingBehaviorIdentifier = () => createMappedError$3(160, $input);
const unexpectedOfKeyword = () => createMappedError$3(161, $input);
const unexpectedImportKeyword = () => createMappedError$3(162, $input);
const invalidLHSBindingIdentifierInForOf = (kind) => createMappedError$3(163, $input, kind);
const invalidPropDefInObjLiteral = () => createMappedError$3(164, $input);
const unterminatedStringLiteral = () => createMappedError$3(165, $input);
const unterminatedTemplateLiteral = () => createMappedError$3(166, $input);
const missingExpectedToken = (token) => createMappedError$3(167, TokenValues[
  token & 63
  /* Token.Type */
], $input);
const unexpectedTokenInDestructuring = () => createMappedError$3(170, $tokenRaw(), $index, $input);
const unexpectedTokenInOptionalChain = () => createMappedError$3(171, $tokenRaw(), $index - 1, $input);
const invalidTaggedTemplateOnOptionalChain = () => createMappedError$3(172, $input);
const invalidArrowParameterList = () => createMappedError$3(173, $input);
const defaultParamsInArrowFn = () => createMappedError$3(174, $input);
const destructuringParamsInArrowFn = () => createMappedError$3(175, $input);
const restParamsMustBeLastParam = () => createMappedError$3(176, $input);
const functionBodyInArrowFn = () => createMappedError$3(178, $input);
const unexpectedDoubleDot = () => createMappedError$3(179, $index - 1, $input);
const TokenValues = [
  $false,
  $true,
  $null,
  $undefined,
  "new",
  "this",
  "$this",
  null,
  "$parent",
  "(",
  "{",
  ".",
  "..",
  "...",
  "?.",
  "}",
  ")",
  ",",
  "[",
  "]",
  ":",
  ";",
  "?",
  "'",
  '"',
  "&",
  "|",
  "??",
  "||",
  "&&",
  "==",
  "!=",
  "===",
  "!==",
  "<",
  ">",
  "<=",
  ">=",
  "in",
  "instanceof",
  "+",
  "-",
  "typeof",
  "void",
  "*",
  "%",
  "/",
  "**",
  "=",
  "!",
  2163762,
  2163763,
  "of",
  "=>",
  "+=",
  "-=",
  "*=",
  "/=",
  "++",
  "--"
];
const KeywordLookup = /* @__PURE__ */ Object.assign(createLookup(), {
  true: 8193,
  null: 8194,
  false: 8192,
  undefined: 8195,
  new: 8196,
  this: 12294,
  $this: 12293,
  $parent: 12296,
  in: 6562214,
  instanceof: 6562215,
  typeof: 139306,
  void: 139307,
  of: 4204596
});
const { CharScanners, IdParts } = /* @__PURE__ */ (() => {
  const unexpectedCharacter = () => {
    throw createMappedError$3(168, $input);
  };
  unexpectedCharacter.notMapped = true;
  const codes = {
    IdStart: (
      /* IdentifierStart */
      [36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490, 8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371]
    ),
    Digit: (
      /* DecimalNumber */
      [48, 58]
    ),
    Skip: (
      /* Skippable */
      [0, 33, 127, 161]
    )
  };
  const decompress = (lookup2, $set, compressed, value) => {
    const rangeCount = compressed.length;
    for (let i = 0; i < rangeCount; i += 2) {
      const start2 = compressed[i];
      let end2 = compressed[i + 1];
      end2 = end2 > 0 ? end2 : start2 + 1;
      if (lookup2) {
        lookup2.fill(value, start2, end2);
      }
    }
  };
  const IdParts2 = /* @__PURE__ */ ((IdParts3) => {
    decompress(IdParts3, null, codes.IdStart, 1);
    decompress(IdParts3, null, codes.Digit, 1);
    return IdParts3;
  })(new Uint8Array(65535));
  const returnToken = (token) => () => {
    nextChar();
    return token;
  };
  const CharScanners2 = new Array(65535);
  CharScanners2.fill(unexpectedCharacter, 0, 65535);
  decompress(CharScanners2, null, codes.Skip, () => {
    nextChar();
    return null;
  });
  decompress(CharScanners2, null, codes.IdStart, scanIdentifier);
  decompress(CharScanners2, null, codes.Digit, () => scanNumber(false));
  CharScanners2[
    34
    /* Char.DoubleQuote */
  ] = CharScanners2[
    39
    /* Char.SingleQuote */
  ] = () => {
    return scanString();
  };
  CharScanners2[
    96
    /* Char.Backtick */
  ] = () => {
    return scanTemplate();
  };
  CharScanners2[
    33
    /* Char.Exclamation */
  ] = () => {
    if (nextChar() !== 61) {
      return 131121;
    }
    if (nextChar() !== 61) {
      return 6553951;
    }
    nextChar();
    return 6553953;
  };
  CharScanners2[
    61
    /* Char.Equals */
  ] = () => {
    if (nextChar() === 62) {
      nextChar();
      return 53;
    }
    if ($currentChar !== 61) {
      return 4194352;
    }
    if (nextChar() !== 61) {
      return 6553950;
    }
    nextChar();
    return 6553952;
  };
  CharScanners2[
    38
    /* Char.Ampersand */
  ] = () => {
    if (nextChar() !== 38) {
      return 6291481;
    }
    nextChar();
    return 6553885;
  };
  CharScanners2[
    124
    /* Char.Bar */
  ] = () => {
    if (nextChar() !== 124) {
      return 6291482;
    }
    nextChar();
    return 6553820;
  };
  CharScanners2[
    63
    /* Char.Question */
  ] = () => {
    if (nextChar() === 46) {
      const peek = $charCodeAt($index + 1);
      if (peek <= 48 || peek >= 57) {
        nextChar();
        return 2162702;
      }
      return 6291480;
    }
    if ($currentChar !== 63) {
      return 6291480;
    }
    nextChar();
    return 6553755;
  };
  CharScanners2[
    46
    /* Char.Dot */
  ] = () => {
    if (nextChar() <= 57 && $currentChar >= 48) {
      return scanNumber(true);
    }
    if ($currentChar === 46) {
      if (nextChar() !== 46) {
        return 12;
      }
      nextChar();
      return 13;
    }
    return 65547;
  };
  CharScanners2[
    60
    /* Char.LessThan */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554018;
    }
    nextChar();
    return 6554020;
  };
  CharScanners2[
    62
    /* Char.GreaterThan */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554019;
    }
    nextChar();
    return 6554021;
  };
  CharScanners2[
    37
    /* Char.Percent */
  ] = returnToken(
    6554157
    /* Token.Percent */
  );
  CharScanners2[
    40
    /* Char.OpenParen */
  ] = returnToken(
    2688009
    /* Token.OpenParen */
  );
  CharScanners2[
    41
    /* Char.CloseParen */
  ] = returnToken(
    7340048
    /* Token.CloseParen */
  );
  CharScanners2[
    42
    /* Char.Asterisk */
  ] = () => {
    if (nextChar() === 61) {
      nextChar();
      return 4194360;
    }
    if ($currentChar === 42) {
      nextChar();
      return 6554223;
    }
    return 6554156;
  };
  CharScanners2[
    43
    /* Char.Plus */
  ] = () => {
    if (nextChar() === 43) {
      nextChar();
      return 2228282;
    }
    if ($currentChar !== 61) {
      return 2490856;
    }
    nextChar();
    return 4194358;
  };
  CharScanners2[
    44
    /* Char.Comma */
  ] = returnToken(
    6291475
    /* Token.Comma */
  );
  CharScanners2[
    45
    /* Char.Minus */
  ] = () => {
    if (nextChar() === 45) {
      nextChar();
      return 2228283;
    }
    if ($currentChar !== 61) {
      return 2490857;
    }
    nextChar();
    return 4194359;
  };
  CharScanners2[
    47
    /* Char.Slash */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554158;
    }
    nextChar();
    return 4194361;
  };
  CharScanners2[
    58
    /* Char.Colon */
  ] = returnToken(
    6291478
    /* Token.Colon */
  );
  CharScanners2[
    59
    /* Char.Semicolon */
  ] = returnToken(
    6291479
    /* Token.Semicolon */
  );
  CharScanners2[
    91
    /* Char.OpenBracket */
  ] = returnToken(
    2688020
    /* Token.OpenBracket */
  );
  CharScanners2[
    93
    /* Char.CloseBracket */
  ] = returnToken(
    7340053
    /* Token.CloseBracket */
  );
  CharScanners2[
    123
    /* Char.OpenBrace */
  ] = returnToken(
    524298
    /* Token.OpenBrace */
  );
  CharScanners2[
    125
    /* Char.CloseBrace */
  ] = returnToken(
    7340047
    /* Token.CloseBrace */
  );
  return { CharScanners: CharScanners2, IdParts: IdParts2 };
})();
const tcCreateInterface = DI.createInterface;
const tcObjectFreeze = Object.freeze;
const { aliasTo: aliasRegistration$1, singleton: singletonRegistration$1 } = Registration;
const etInterpolation$1 = "Interpolation";
const etIsFunction$1 = "IsFunction";
const etIsProperty$1 = "IsProperty";
const definitionTypeElement = "custom-element";
const BindingMode = /* @__PURE__ */ tcObjectFreeze({
  /**
   * Unspecified mode, bindings may act differently with this mode
   */
  default: 0,
  oneTime: 1,
  toView: 2,
  fromView: 4,
  twoWay: 6
});
const ITemplateCompiler = /* @__PURE__ */ tcCreateInterface("ITemplateCompiler");
const IAttrMapper = /* @__PURE__ */ tcCreateInterface("IAttrMapper");
const createMappedError$2 = (code, ...details) => {
  const paddedCode = String(code).padStart(4, "0");
  const message = getMessageByCode$2(code, ...details);
  const link = `https://docs.aurelia.io/developer-guides/error-messages/0088-to-0723/aur${paddedCode}`;
  return new Error(`AUR${paddedCode}: ${message}

For more information, see: ${link}`);
};
const errorsMap$2 = {
  [
    88
    /* ErrorNames.attribute_pattern_already_initialized */
  ]: "AttributeParser is already initialized; cannot add patterns after initialization.",
  [
    89
    /* ErrorNames.attribute_pattern_duplicate */
  ]: 'Attribute pattern "{{0}}" has already been registered.',
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    157
    /* ErrorNames.binding_command_existed */
  ]: `Binding command {{0}} has already been registered.`,
  [
    701
    /* ErrorNames.compiler_root_is_local */
  ]: `Template compilation error in element "{{0:name}}": the root <template> cannot be a local element template.`,
  [
    702
    /* ErrorNames.compiler_invalid_surrogate_attr */
  ]: `Template compilation error: attribute "{{0}}" is invalid on element surrogate.`,
  [
    703
    /* ErrorNames.compiler_no_tc_on_surrogate */
  ]: `Template compilation error: template controller "{{0}}" is invalid on element surrogate.`,
  [
    704
    /* ErrorNames.compiler_invalid_let_command */
  ]: `Template compilation error: Invalid command "{{0:.command}}" for <let>. Only to-view/bind supported.`,
  [
    706
    /* ErrorNames.compiler_au_slot_on_non_element */
  ]: `Template compilation error: detected projection with [au-slot="{{0}}"] attempted on a non custom element {{1}}.`,
  [
    707
    /* ErrorNames.compiler_binding_to_non_bindable */
  ]: `Template compilation error: creating binding to non-bindable property {{0}} on {{1}}.`,
  [
    708
    /* ErrorNames.compiler_template_only_local_template */
  ]: `Template compilation error: the custom element "{{0}}" does not have any content other than local template(s).`,
  [
    709
    /* ErrorNames.compiler_local_el_not_under_root */
  ]: `Template compilation error: local element template needs to be defined directly under root of element "{{0}}".`,
  [
    710
    /* ErrorNames.compiler_local_el_bindable_not_under_root */
  ]: `Template compilation error: bindable properties of local element "{{0}}" template needs to be defined directly under <template>.`,
  [
    711
    /* ErrorNames.compiler_local_el_bindable_name_missing */
  ]: `Template compilation error: the attribute 'property' is missing in {{0:outerHTML}} in local element "{{1}}"`,
  [
    712
    /* ErrorNames.compiler_local_el_bindable_duplicate */
  ]: `Template compilation error: Bindable property and attribute needs to be unique; found property: {{0}}, attribute: {{1}}`,
  [
    713
    /* ErrorNames.compiler_unknown_binding_command */
  ]: `Template compilation error: unknown binding command: "{{0}}".{{0:bindingCommandHelp}}`,
  [
    714
    /* ErrorNames.compiler_primary_already_existed */
  ]: `Template compilation error: primary already exists on element/attribute "{{0}}"`,
  [
    715
    /* ErrorNames.compiler_local_name_empty */
  ]: `Template compilation error: the value of "as-custom-element" attribute cannot be empty for local element in element "{{0}}"`,
  [
    716
    /* ErrorNames.compiler_duplicate_local_name */
  ]: `Template compilation error: duplicate definition of the local template named "{{0}} in element {{1}}"`,
  [
    717
    /* ErrorNames.compiler_slot_without_shadowdom */
  ]: `Template compilation error: detected a usage of "<slot>" element without specifying shadow DOM options in element: {{0}}`,
  [
    718
    /* ErrorNames.compiler_no_spread_tc */
  ]: `Spreading template controller "{{0}}" is not supported.`,
  [
    719
    /* ErrorNames.compiler_attr_mapper_duplicate_mapping */
  ]: `Attribute {{0}} has been already registered for {{1:element}}`,
  [
    720
    /* ErrorNames.compiler_no_reserved_spread_syntax */
  ]: `Spreading syntax "...xxx" is reserved. Encountered "...{{0}}"`,
  [
    721
    /* ErrorNames.compiler_no_reserved_$bindable */
  ]: `Usage of $bindables is only allowed on custom element. Encountered: <{{0}} {{1}}="{{2}}">`,
  [
    722
    /* ErrorNames.compiler_no_dom_api */
  ]: "Invalid platform object provided to the compilation, no DOM API found.",
  [
    723
    /* ErrorNames.compiler_invalid_class_binding_syntax */
  ]: `Template compilation error: Invalid comma-separated class binding syntax in {{0}}. It resulted in no valid class names after parsing.`,
  [
    9998
    /* ErrorNames.no_spread_template_controller */
  ]: "Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?"
};
const getMessageByCode$2 = (name2, ...details) => {
  let cooked = errorsMap$2[name2];
  for (let i = 0; i < details.length; ++i) {
    const regex = new RegExp(`{{${i}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i];
      if (value != null) {
        switch (method) {
          case "nodeName":
            value = value.nodeName.toLowerCase();
            break;
          case "name":
            value = value.name;
            break;
          case "typeof":
            value = typeof value;
            break;
          case "ctor":
            value = value.constructor.name;
            break;
          case "controller":
            value = value.controller.name;
            break;
          case "target@property":
            value = `${value.target}@${value.targetProperty}`;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "bindingCommandHelp":
            value = getBindingCommandHelp$1(value);
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = String(value[method.slice(1)]);
            } else {
              value = String(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
function getBindingCommandHelp$1(name2) {
  switch (name2) {
    case "delegate":
      return `
The ".delegate" binding command has been removed in v2. Binding command ".trigger" should be used instead. If you are migrating v1 application, install compat package to add back the ".delegate" binding command for ease of migration.`;
    case "call":
      return `
The ".call" binding command has been removed in v2. If you want to pass a callback that preserves the context of the function call, you can use lambda instead. Refer to lambda expression doc for more details.`;
    default:
      return "";
  }
}
var _a$1, _b$1, _c$1, _d, _e$2;
class CharSpec {
  constructor(chars, repeat, isSymbol2, isInverted) {
    this.chars = chars;
    this.repeat = repeat;
    this.isSymbol = isSymbol2;
    this.isInverted = isInverted;
    if (isInverted) {
      switch (chars.length) {
        case 0:
          this.has = this._hasOfNoneInverse;
          break;
        case 1:
          this.has = this._hasOfSingleInverse;
          break;
        default:
          this.has = this._hasOfMultipleInverse;
      }
    } else {
      switch (chars.length) {
        case 0:
          this.has = this._hasOfNone;
          break;
        case 1:
          this.has = this._hasOfSingle;
          break;
        default:
          this.has = this._hasOfMultiple;
      }
    }
  }
  equals(other) {
    return this.chars === other.chars && this.repeat === other.repeat && this.isSymbol === other.isSymbol && this.isInverted === other.isInverted;
  }
  /** @internal */
  _hasOfMultiple(char) {
    return this.chars.includes(char);
  }
  /** @internal */
  _hasOfSingle(char) {
    return this.chars === char;
  }
  /** @internal */
  _hasOfNone(_char) {
    return false;
  }
  /** @internal */
  _hasOfMultipleInverse(char) {
    return !this.chars.includes(char);
  }
  /** @internal */
  _hasOfSingleInverse(char) {
    return this.chars !== char;
  }
  /** @internal */
  _hasOfNoneInverse(_char) {
    return true;
  }
}
class Interpretation {
  constructor() {
    this.parts = emptyArray;
    this._pattern = "";
    this._currentRecord = {};
    this._partsRecord = {};
  }
  get pattern() {
    const value = this._pattern;
    if (value === "") {
      return null;
    } else {
      return value;
    }
  }
  set pattern(value) {
    if (value == null) {
      this._pattern = "";
      this.parts = emptyArray;
    } else {
      this._pattern = value;
      this.parts = this._partsRecord[value];
    }
  }
  append(pattern, ch) {
    const currentRecord = this._currentRecord;
    if (currentRecord[pattern] === void 0) {
      currentRecord[pattern] = ch;
    } else {
      currentRecord[pattern] += ch;
    }
  }
  next(pattern) {
    const currentRecord = this._currentRecord;
    let partsRecord;
    if (currentRecord[pattern] !== void 0) {
      partsRecord = this._partsRecord;
      if (partsRecord[pattern] === void 0) {
        partsRecord[pattern] = [currentRecord[pattern]];
      } else {
        partsRecord[pattern].push(currentRecord[pattern]);
      }
      currentRecord[pattern] = void 0;
    }
  }
}
class AttrParsingState {
  get _pattern() {
    return this._isEndpoint ? this._patterns[0] : null;
  }
  constructor(charSpec, ...patterns) {
    this.charSpec = charSpec;
    this._nextStates = [];
    this._types = null;
    this._isEndpoint = false;
    this._patterns = patterns;
  }
  findChild(charSpec) {
    const nextStates = this._nextStates;
    const len = nextStates.length;
    let child = null;
    let i = 0;
    for (; i < len; ++i) {
      child = nextStates[i];
      if (charSpec.equals(child.charSpec)) {
        return child;
      }
    }
    return null;
  }
  append(charSpec, pattern) {
    const patterns = this._patterns;
    if (!patterns.includes(pattern)) {
      patterns.push(pattern);
    }
    let state = this.findChild(charSpec);
    if (state == null) {
      state = new AttrParsingState(charSpec, pattern);
      this._nextStates.push(state);
      if (charSpec.repeat) {
        state._nextStates.push(state);
      }
    }
    return state;
  }
  findMatches(ch, interpretation) {
    const results = [];
    const nextStates = this._nextStates;
    const len = nextStates.length;
    let childLen = 0;
    let child = null;
    let i = 0;
    let j = 0;
    for (; i < len; ++i) {
      child = nextStates[i];
      if (child.charSpec.has(ch)) {
        results.push(child);
        childLen = child._patterns.length;
        j = 0;
        if (child.charSpec.isSymbol) {
          for (; j < childLen; ++j) {
            interpretation.next(child._patterns[j]);
          }
        } else {
          for (; j < childLen; ++j) {
            interpretation.append(child._patterns[j], ch);
          }
        }
      }
    }
    return results;
  }
}
let StaticSegment$1 = class StaticSegment {
  constructor(text) {
    this.text = text;
    const len = this._len = text.length;
    const specs = this._specs = [];
    let i = 0;
    for (; len > i; ++i) {
      specs.push(new CharSpec(text[i], false, false, false));
    }
  }
  eachChar(callback) {
    const len = this._len;
    const specs = this._specs;
    let i = 0;
    for (; len > i; ++i) {
      callback(specs[i]);
    }
  }
};
let DynamicSegment$1 = class DynamicSegment {
  constructor(symbols) {
    this.text = "PART";
    this._spec = new CharSpec(symbols, true, false, true);
  }
  eachChar(callback) {
    callback(this._spec);
  }
};
class SymbolSegment {
  constructor(text) {
    this.text = text;
    this._spec = new CharSpec(text, false, true, false);
  }
  eachChar(callback) {
    callback(this._spec);
  }
}
class SegmentTypes {
  constructor() {
    this.statics = 0;
    this.dynamics = 0;
    this.symbols = 0;
  }
}
const ISyntaxInterpreter = /* @__PURE__ */ tcCreateInterface("ISyntaxInterpreter", (x) => x.singleton(SyntaxInterpreter));
class SyntaxInterpreter {
  constructor() {
    this._rootState = new AttrParsingState(null);
    this._initialStates = [this._rootState];
  }
  // todo: this only works if this method is ever called only once
  add(defs) {
    defs = defs.slice(0).sort((d1, d22) => d1.pattern > d22.pattern ? 1 : -1);
    const ii = defs.length;
    let currentState;
    let def2;
    let pattern;
    let types;
    let segments;
    let len;
    let charSpecCb;
    let i = 0;
    let j;
    while (ii > i) {
      currentState = this._rootState;
      def2 = defs[i];
      pattern = def2.pattern;
      types = new SegmentTypes();
      segments = this._parse(def2, types);
      len = segments.length;
      charSpecCb = (ch) => currentState = currentState.append(ch, pattern);
      for (j = 0; len > j; ++j) {
        segments[j].eachChar(charSpecCb);
      }
      currentState._types = types;
      currentState._isEndpoint = true;
      ++i;
    }
  }
  interpret(name2) {
    const interpretation = new Interpretation();
    const len = name2.length;
    let states = this._initialStates;
    let i = 0;
    let state;
    for (; i < len; ++i) {
      states = this._getNextStates(states, name2.charAt(i), interpretation);
      if (states.length === 0) {
        break;
      }
    }
    states = states.filter(isEndpoint);
    if (states.length > 0) {
      states.sort(sortEndpoint);
      state = states[0];
      if (!state.charSpec.isSymbol) {
        interpretation.next(state._pattern);
      }
      interpretation.pattern = state._pattern;
    }
    return interpretation;
  }
  /** @internal */
  _getNextStates(states, ch, interpretation) {
    const nextStates = [];
    let state = null;
    const len = states.length;
    let i = 0;
    for (; i < len; ++i) {
      state = states[i];
      nextStates.push(...state.findMatches(ch, interpretation));
    }
    return nextStates;
  }
  /** @internal */
  _parse(def2, types) {
    const result = [];
    const pattern = def2.pattern;
    const len = pattern.length;
    const symbols = def2.symbols;
    let i = 0;
    let start2 = 0;
    let c = "";
    while (i < len) {
      c = pattern.charAt(i);
      if (symbols.length === 0 || !symbols.includes(c)) {
        if (i === start2) {
          if (c === "P" && pattern.slice(i, i + 4) === "PART") {
            start2 = i = i + 4;
            result.push(new DynamicSegment$1(symbols));
            ++types.dynamics;
          } else {
            ++i;
          }
        } else {
          ++i;
        }
      } else if (i !== start2) {
        result.push(new StaticSegment$1(pattern.slice(start2, i)));
        ++types.statics;
        start2 = i;
      } else {
        result.push(new SymbolSegment(pattern.slice(start2, i + 1)));
        ++types.symbols;
        start2 = ++i;
      }
    }
    if (start2 !== i) {
      result.push(new StaticSegment$1(pattern.slice(start2, i)));
      ++types.statics;
    }
    return result;
  }
}
function isEndpoint(a) {
  return a._isEndpoint;
}
function sortEndpoint(a, b) {
  const aTypes = a._types;
  const bTypes = b._types;
  if (aTypes.statics !== bTypes.statics) {
    return bTypes.statics - aTypes.statics;
  }
  if (aTypes.dynamics !== bTypes.dynamics) {
    return bTypes.dynamics - aTypes.dynamics;
  }
  if (aTypes.symbols !== bTypes.symbols) {
    return bTypes.symbols - aTypes.symbols;
  }
  return 0;
}
class AttrSyntax {
  constructor(rawName, rawValue, target, command, parts = null) {
    this.rawName = rawName;
    this.rawValue = rawValue;
    this.target = target;
    this.command = command;
    this.parts = parts;
  }
}
const IAttributePattern = /* @__PURE__ */ tcCreateInterface("IAttributePattern");
const IAttributeParser = /* @__PURE__ */ tcCreateInterface("IAttributeParser", (x) => x.singleton(AttributeParser));
class AttributeParser {
  constructor() {
    this._cache = {};
    this._patterns = {};
    this._initialized = false;
    this._allDefinitions = [];
    this._interpreter = resolve(ISyntaxInterpreter);
    this._container = resolve(IContainer);
  }
  registerPattern(patterns, Type) {
    if (this._initialized)
      throw createMappedError$2(
        88
        /* ErrorNames.attribute_pattern_already_initialized */
      );
    const $patterns = this._patterns;
    for (const { pattern } of patterns) {
      if ($patterns[pattern] != null)
        throw createMappedError$2(89, pattern);
      $patterns[pattern] = { patternType: Type };
    }
    this._allDefinitions.push(...patterns);
  }
  /** @internal */
  _initialize() {
    this._interpreter.add(this._allDefinitions);
    const _container = this._container;
    for (const [, value] of Object.entries(this._patterns)) {
      value.pattern = _container.get(value.patternType);
    }
  }
  parse(name2, value) {
    if (!this._initialized) {
      this._initialize();
      this._initialized = true;
    }
    let interpretation = this._cache[name2];
    if (interpretation == null) {
      interpretation = this._cache[name2] = this._interpreter.interpret(name2);
    }
    const pattern = interpretation.pattern;
    if (pattern == null) {
      return new AttrSyntax(name2, value, name2, null, null);
    } else {
      return this._patterns[pattern].pattern[pattern](name2, value, interpretation.parts);
    }
  }
}
const AttributePattern = /* @__PURE__ */ tcObjectFreeze({
  name: getResourceKeyFor("attribute-pattern"),
  create(patternDefs, Type) {
    return {
      register(container) {
        container.get(IAttributeParser).registerPattern(patternDefs, Type);
        singletonRegistration$1(IAttributePattern, Type).register(container);
      }
    };
  }
});
class DotSeparatedAttributePattern {
  "PART.PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);
  }
  "PART.PART.PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, `${parts[0]}.${parts[1]}`, parts[2]);
  }
}
_a$1 = Symbol.metadata;
DotSeparatedAttributePattern[_a$1] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "PART.PART", symbols: "." },
    { pattern: "PART.PART.PART", symbols: "." }
  ], DotSeparatedAttributePattern)
};
class RefAttributePattern {
  "ref"(rawName, rawValue, _parts) {
    return new AttrSyntax(rawName, rawValue, "element", "ref");
  }
  "PART.ref"(rawName, rawValue, parts) {
    let target = parts[0];
    if (target === "view-model") {
      target = "component";
      {
        console.warn(`[aurelia] Detected view-model.ref usage: "${rawName}=${rawValue}". This is deprecated and component.ref should be used instead`);
      }
    }
    return new AttrSyntax(rawName, rawValue, target, "ref");
  }
}
_b$1 = Symbol.metadata;
RefAttributePattern[_b$1] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "ref", symbols: "" },
    { pattern: "PART.ref", symbols: "." }
  ], RefAttributePattern)
};
class EventAttributePattern {
  "PART.trigger:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger", parts);
  }
  "PART.capture:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "capture", parts);
  }
}
_c$1 = Symbol.metadata;
EventAttributePattern[_c$1] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "PART.trigger:PART", symbols: ".:" },
    { pattern: "PART.capture:PART", symbols: ".:" }
  ], EventAttributePattern)
};
class ColonPrefixedBindAttributePattern {
  ":PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "bind");
  }
}
_d = Symbol.metadata;
ColonPrefixedBindAttributePattern[_d] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([{ pattern: ":PART", symbols: ":" }], ColonPrefixedBindAttributePattern)
};
class AtPrefixedTriggerAttributePattern {
  "@PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger");
  }
  "@PART:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger", [parts[0], "trigger", ...parts.slice(1)]);
  }
}
_e$2 = Symbol.metadata;
AtPrefixedTriggerAttributePattern[_e$2] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "@PART", symbols: "@" },
    { pattern: "@PART:PART", symbols: "@:" }
  ], AtPrefixedTriggerAttributePattern)
};
const getMetadata$1 = Metadata.get;
const defineMetadata$1 = Metadata.define;
const hydrateElement = "ra";
const hydrateAttribute = "rb";
const hydrateTemplateController = "rc";
const hydrateLetElement = "rd";
const setProperty = "re";
const interpolation = "rf";
const propertyBinding = "rg";
const letBinding = "ri";
const refBinding = "rj";
const iteratorBinding = "rk";
const multiAttr = "rl";
const textBinding = "ha";
const listenerBinding = "hb";
const attributeBinding = "hc";
const stylePropertyBinding = "hd";
const setAttribute = "he";
const setClassAttribute = "hf";
const setStyleAttribute = "hg";
const spreadTransferedBinding = "hs";
const spreadElementProp = "hp";
const spreadValueBinding = "svb";
const InstructionType = /* @__PURE__ */ tcObjectFreeze({
  hydrateElement,
  hydrateAttribute,
  hydrateTemplateController,
  hydrateLetElement,
  setProperty,
  interpolation,
  propertyBinding,
  letBinding,
  refBinding,
  iteratorBinding,
  multiAttr,
  textBinding,
  listenerBinding,
  attributeBinding,
  stylePropertyBinding,
  setAttribute,
  setClassAttribute,
  setStyleAttribute,
  spreadTransferedBinding,
  spreadElementProp,
  spreadValueBinding
});
const IInstruction = /* @__PURE__ */ tcCreateInterface("Instruction");
class InterpolationInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = interpolation;
  }
}
class PropertyBindingInstruction {
  constructor(from, to, mode) {
    this.from = from;
    this.to = to;
    this.mode = mode;
    this.type = propertyBinding;
  }
}
class IteratorBindingInstruction {
  constructor(forOf, to, props2) {
    this.forOf = forOf;
    this.to = to;
    this.props = props2;
    this.type = iteratorBinding;
  }
}
class RefBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = refBinding;
  }
}
class SetPropertyInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
    this.type = setProperty;
  }
}
class MultiAttrInstruction {
  constructor(value, to, command) {
    this.value = value;
    this.to = to;
    this.command = command;
    this.type = multiAttr;
  }
}
class HydrateElementInstruction {
  constructor(res, props2, projections, containerless, captures, data) {
    this.res = res;
    this.props = props2;
    this.projections = projections;
    this.containerless = containerless;
    this.captures = captures;
    this.data = data;
    this.type = hydrateElement;
  }
}
class HydrateAttributeInstruction {
  constructor(res, alias, props2) {
    this.res = res;
    this.alias = alias;
    this.props = props2;
    this.type = hydrateAttribute;
  }
}
class HydrateTemplateController {
  constructor(def2, res, alias, props2) {
    this.def = def2;
    this.res = res;
    this.alias = alias;
    this.props = props2;
    this.type = hydrateTemplateController;
  }
}
class HydrateLetElementInstruction {
  constructor(instructions, toBindingContext) {
    this.instructions = instructions;
    this.toBindingContext = toBindingContext;
    this.type = hydrateLetElement;
  }
}
class LetBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = letBinding;
  }
}
class TextBindingInstruction {
  constructor(from) {
    this.from = from;
    this.type = textBinding;
  }
}
class ListenerBindingInstruction {
  constructor(from, to, capture, modifier) {
    this.from = from;
    this.to = to;
    this.capture = capture;
    this.modifier = modifier;
    this.type = listenerBinding;
  }
}
class SetAttributeInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
    this.type = setAttribute;
  }
}
class SetClassAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = setClassAttribute;
  }
}
class SetStyleAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = setStyleAttribute;
  }
}
class AttributeBindingInstruction {
  constructor(attr, from, to) {
    this.attr = attr;
    this.from = from;
    this.to = to;
    this.type = attributeBinding;
  }
}
class SpreadTransferedBindingInstruction {
  constructor() {
    this.type = spreadTransferedBinding;
  }
}
class SpreadElementPropBindingInstruction {
  constructor(instruction) {
    this.instruction = instruction;
    this.type = spreadElementProp;
  }
}
class SpreadValueBindingInstruction {
  constructor(target, from) {
    this.target = target;
    this.from = from;
    this.type = spreadValueBinding;
  }
}
class BindingCommandDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new BindingCommandDefinition(Type, firstDefined(getCommandAnnotation(Type, "name"), name2), mergeArrays(getCommandAnnotation(Type, "aliases"), def2.aliases, Type.aliases), getCommandKeyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getCommandKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration$1($Type, $Type), aliasRegistration$1($Type, key), ...aliases.map((alias) => aliasRegistration$1($Type, getCommandKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError$2(157, this.name)}`);
    }
  }
}
const bindingCommandTypeName = "binding-command";
const cmdBaseName = /* @__PURE__ */ getResourceKeyFor(bindingCommandTypeName);
const getCommandKeyFrom = (name2) => `${cmdBaseName}:${name2}`;
const getCommandAnnotation = (Type, prop) => getMetadata$1(Protocol.annotation.keyFor(prop), Type);
const BindingCommand = /* @__PURE__ */ (() => {
  const staticResourceDefinitionMetadataKey = "__au_static_resource__";
  const getDefinitionFromStaticAu2 = (Type, typeName, createDef) => {
    let def2 = getMetadata$1(staticResourceDefinitionMetadataKey, Type);
    if (def2 == null) {
      if (Type.$au?.type === typeName) {
        def2 = createDef(Type.$au, Type);
        defineMetadata$1(def2, Type, staticResourceDefinitionMetadataKey);
      }
    }
    return def2;
  };
  return tcObjectFreeze({
    name: cmdBaseName,
    keyFrom: getCommandKeyFrom,
    // isType<T>(value: T): value is (T extends Constructable ? BindingCommandType<T> : never) {
    //   return isFunction(value) && hasOwnMetadata(cmdBaseName, value);
    // },
    define(nameOrDef, Type) {
      const definition = BindingCommandDefinition.create(nameOrDef, Type);
      const $Type = definition.Type;
      defineMetadata$1(definition, $Type, cmdBaseName, resourceBaseName);
      return $Type;
    },
    getAnnotation: getCommandAnnotation,
    find(container, name2) {
      const Type = container.find(bindingCommandTypeName, name2);
      return Type == null ? null : getMetadata$1(cmdBaseName, Type) ?? getDefinitionFromStaticAu2(Type, bindingCommandTypeName, BindingCommandDefinition.create) ?? null;
    },
    get(container, name2) {
      {
        try {
          return container.get(resource(getCommandKeyFrom(name2)));
        } catch (ex) {
          console.log(`


[DEV:aurelia] Cannot retrieve binding command with name




`, name2);
          throw ex;
        }
      }
      return container.get(resource(getCommandKeyFrom(name2)));
    }
  });
})();
class OneTimeBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = info2.attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      1
      /* InternalBindingMode.oneTime */
    );
  }
}
OneTimeBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "one-time"
};
class ToViewBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = info2.attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      2
      /* InternalBindingMode.toView */
    );
  }
}
ToViewBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "to-view"
};
class FromViewBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      4
      /* InternalBindingMode.fromView */
    );
  }
}
FromViewBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "from-view"
};
class TwoWayBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      6
      /* InternalBindingMode.twoWay */
    );
  }
}
TwoWayBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "two-way"
};
class DefaultBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    const bindable2 = info2.bindable;
    let value = attr.rawValue;
    let target = attr.target;
    let defDefaultMode;
    let mode;
    value = value === "" ? camelCase(target) : value;
    if (bindable2 == null) {
      mode = attrMapper.isTwoWay(info2.node, target) ? 6 : 2;
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      defDefaultMode = info2.def.defaultBindingMode ?? 0;
      mode = bindable2.mode === 0 || bindable2.mode == null ? defDefaultMode == null || defDefaultMode === 0 ? 2 : defDefaultMode : bindable2.mode;
      target = bindable2.name;
    }
    return new PropertyBindingInstruction(exprParser.parse(value, etIsProperty$1), target, isString(mode) ? BindingMode[mode] ?? 0 : mode);
  }
}
DefaultBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "bind"
};
class ForBindingCommand {
  constructor() {
    this._attrParser = resolve(IAttributeParser);
  }
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser) {
    const target = info2.bindable === null ? camelCase(info2.attr.target) : info2.bindable.name;
    const forOf = exprParser.parse(info2.attr.rawValue, "IsIterator");
    let props2 = emptyArray;
    if (forOf.semiIdx > -1) {
      const attr = info2.attr.rawValue.slice(forOf.semiIdx + 1);
      const i = attr.indexOf(":");
      if (i > -1) {
        const attrName = attr.slice(0, i).trim();
        const attrValue = attr.slice(i + 1).trim();
        const attrSyntax = this._attrParser.parse(attrName, attrValue);
        props2 = [new MultiAttrInstruction(attrValue, attrSyntax.target, attrSyntax.command)];
      }
    }
    return new IteratorBindingInstruction(forOf, target, props2);
  }
}
ForBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "for"
};
class TriggerBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new ListenerBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsFunction$1), info2.attr.target, false, info2.attr.parts?.[2] ?? null);
  }
}
TriggerBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "trigger"
};
class CaptureBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new ListenerBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsFunction$1), info2.attr.target, true, info2.attr.parts?.[2] ?? null);
  }
}
CaptureBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "capture"
};
class AttrBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    const attr = info2.attr;
    const target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    return new AttributeBindingInstruction(target, exprParser.parse(value, etIsProperty$1), target);
  }
}
AttrBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "attr"
};
class StyleBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new AttributeBindingInstruction("style", exprParser.parse(info2.attr.rawValue, etIsProperty$1), info2.attr.target);
  }
}
StyleBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "style"
};
class ClassBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    let target = info2.attr.target;
    if (target.includes(",")) {
      const classes = target.split(",").filter((c) => c.length > 0);
      if (classes.length === 0) {
        throw createMappedError$2(
          723
          /* ErrorNames.compiler_invalid_class_binding_syntax */
        );
      }
      target = classes.join(" ");
    }
    return new AttributeBindingInstruction("class", exprParser.parse(info2.attr.rawValue, etIsProperty$1), target);
  }
}
ClassBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "class"
};
class RefBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new RefBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsProperty$1), info2.attr.target);
  }
}
RefBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "ref"
};
class SpreadValueBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2) {
    return new SpreadValueBindingInstruction(info2.attr.target, info2.attr.rawValue);
  }
}
SpreadValueBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "spread"
};
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
const ITemplateElementFactory = /* @__PURE__ */ tcCreateInterface("ITemplateElementFactory", (x) => x.singleton(TemplateElementFactory));
const markupCache = {};
class TemplateElementFactory {
  constructor() {
    this.p = resolve(IPlatform$1);
    this._template = this.t();
  }
  t() {
    return this.p.document.createElement("template");
  }
  createTemplate(input) {
    if (isString(input)) {
      let result = markupCache[input];
      if (result === void 0) {
        const template2 = this._template;
        template2.innerHTML = input;
        const node = template2.content.firstElementChild;
        if (needsWrapping(node)) {
          this._template = this.t();
          result = template2;
        } else {
          template2.content.removeChild(node);
          result = node;
        }
        markupCache[input] = result;
      }
      return result.cloneNode(true);
    }
    if (input.nodeName !== "TEMPLATE") {
      const template2 = this.t();
      template2.content.appendChild(input);
      return template2;
    }
    input.parentNode?.removeChild(input);
    return input.cloneNode(true);
    function needsWrapping(node) {
      if (node == null)
        return true;
      if (node.nodeName !== "TEMPLATE")
        return true;
      const nextElementSibling = node.nextElementSibling;
      if (nextElementSibling != null)
        return true;
      const prevSibling = node.previousSibling;
      if (prevSibling != null) {
        switch (prevSibling.nodeType) {
          // The previous sibling cannot be an element, because the node is the first element in the template.
          case 3:
            return prevSibling.textContent.trim().length > 0;
        }
      }
      const nextSibling = node.nextSibling;
      if (nextSibling != null) {
        switch (nextSibling.nodeType) {
          // element is already checked above
          case 3:
            return nextSibling.textContent.trim().length > 0;
        }
      }
      return false;
    }
  }
}
const auLocationStart = "au-start";
const auLocationEnd = "au-end";
const insertBefore = (parent, newChildNode, target) => {
  return parent.insertBefore(newChildNode, target);
};
const insertManyBefore$1 = (parent, target, newChildNodes) => {
  if (parent === null) {
    return;
  }
  const ii = newChildNodes.length;
  let i = 0;
  while (ii > i) {
    parent.insertBefore(newChildNodes[i], target);
    ++i;
  }
};
const appendToTemplate = (parent, child) => {
  return parent.content.appendChild(child);
};
const appendManyToTemplate = (parent, children) => {
  const ii = children.length;
  let i = 0;
  while (ii > i) {
    parent.content.appendChild(children[i]);
    ++i;
  }
};
const isElement$2 = (node) => node.nodeType === 1;
const isTextNode = (node) => node.nodeType === 3;
const auslotAttr$1 = "au-slot";
const defaultSlotName$1 = "default";
const generateElementName$1 = /* @__PURE__ */ ((id2) => () => `anonymous-${++id2}`)(0);
class TemplateCompiler {
  constructor() {
    this.debug = false;
    this.resolveResources = true;
  }
  compile(definition, container) {
    if (definition.template == null || definition.needsCompile === false) {
      return definition;
    }
    const context = new CompilationContext(definition, container, null, null, void 0);
    const template2 = isString(definition.template) || !definition.enhance ? context._templateFactory.createTemplate(definition.template) : definition.template;
    const isTemplateElement = template2.nodeName === TEMPLATE_NODE_NAME && template2.content != null;
    const content = isTemplateElement ? template2.content : template2;
    const hooks = TemplateCompilerHooks.findAll(container);
    const ii = hooks.length;
    let i = 0;
    if (ii > 0) {
      while (ii > i) {
        hooks[i].compiling?.(template2);
        ++i;
      }
    }
    if (template2.hasAttribute(localTemplateIdentifier)) {
      throw createMappedError$2(701, definition);
    }
    this._compileLocalElement(content, context);
    this._compileNode(content, context);
    const compiledDef = {
      ...definition,
      name: definition.name || generateElementName$1(),
      dependencies: (definition.dependencies ?? emptyArray).concat(context.deps ?? emptyArray),
      instructions: context.rows,
      surrogates: isTemplateElement ? this._compileSurrogate(template2, context) : emptyArray,
      template: template2,
      hasSlots: context.hasSlot,
      needsCompile: false
    };
    return compiledDef;
  }
  compileSpread(requestor, attrSyntaxs, container, target, targetDef) {
    const context = new CompilationContext(requestor, container, null, null, void 0);
    const instructions = [];
    const elDef = targetDef ?? context._findElement(target.nodeName.toLowerCase());
    const isCustomElement = elDef !== null;
    const exprParser = context._exprParser;
    const ii = attrSyntaxs.length;
    let i = 0;
    let attrSyntax;
    let attrDef = null;
    let attrInstructions;
    let attrBindableInstructions;
    let bindablesInfo;
    let bindable2;
    let primaryBindable;
    let bindingCommand = null;
    let expr;
    let isMultiBindings;
    let attrTarget;
    let attrValue;
    for (; ii > i; ++i) {
      attrSyntax = attrSyntaxs[i];
      attrTarget = attrSyntax.target;
      attrValue = attrSyntax.rawValue;
      if (attrTarget === "...$attrs") {
        instructions.push(new SpreadTransferedBindingInstruction());
        continue;
      }
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null && bindingCommand.ignoreAttr) {
        commandBuildInfo.node = target;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        continue;
      }
      if (isCustomElement) {
        bindablesInfo = context._getBindables(elDef);
        bindable2 = bindablesInfo.attrs[attrTarget];
        if (bindable2 !== void 0) {
          if (bindingCommand == null) {
            expr = exprParser.parse(attrValue, etInterpolation$1);
            instructions.push(new SpreadElementPropBindingInstruction(expr == null ? new SetPropertyInstruction(attrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name)));
          } else {
            commandBuildInfo.node = target;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = bindable2;
            commandBuildInfo.def = elDef;
            instructions.push(new SpreadElementPropBindingInstruction(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)));
          }
          continue;
        }
      }
      attrDef = context._findAttr(attrTarget);
      if (attrDef !== null) {
        if (attrDef.isTemplateController) {
          throw createMappedError$2(9998, attrTarget);
        }
        bindablesInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(attrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(target, attrValue, attrDef, context);
        } else {
          primaryBindable = bindablesInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(attrValue, etInterpolation$1);
            attrBindableInstructions = [
              expr === null ? new SetPropertyInstruction(attrValue, primaryBindable.name) : new InterpolationInstruction(expr, primaryBindable.name)
            ];
          } else {
            commandBuildInfo.node = target;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        (attrInstructions ??= []).push(new HydrateAttributeInstruction(
          // todo: def/ def.Type or def.name should be configurable
          //       example: AOT/runtime can use def.Type, but there are situation
          //       where instructions need to be serialized, def.name should be used
          this.resolveResources ? attrDef : attrDef.name,
          attrDef.aliases != null && attrDef.aliases.includes(attrTarget) ? attrTarget : void 0,
          attrBindableInstructions
        ));
        continue;
      }
      if (bindingCommand == null) {
        expr = exprParser.parse(attrValue, etInterpolation$1);
        if (expr != null) {
          instructions.push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(target, attrTarget) ?? camelCase(attrTarget)
          ));
        } else {
          switch (attrTarget) {
            case "class":
              instructions.push(new SetClassAttributeInstruction(attrValue));
              break;
            case "style":
              instructions.push(new SetStyleAttributeInstruction(attrValue));
              break;
            default:
              instructions.push(new SetAttributeInstruction(attrValue, attrTarget));
          }
        }
      } else {
        commandBuildInfo.node = target;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      }
    }
    resetCommandBuildInfo();
    if (attrInstructions != null) {
      return attrInstructions.concat(instructions);
    }
    return instructions;
  }
  /** @internal */
  _compileSurrogate(el, context) {
    const instructions = [];
    const attrs = el.attributes;
    const exprParser = context._exprParser;
    let ii = attrs.length;
    let i = 0;
    let attr;
    let attrName;
    let attrValue;
    let attrSyntax;
    let attrDef = null;
    let attrInstructions;
    let attrBindableInstructions;
    let bindableInfo;
    let primaryBindable;
    let bindingCommand = null;
    let expr;
    let isMultiBindings;
    let realAttrTarget;
    let realAttrValue;
    for (; ii > i; ++i) {
      attr = attrs[i];
      attrName = attr.name;
      attrValue = attr.value;
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      if (invalidSurrogateAttribute[realAttrTarget]) {
        throw createMappedError$2(702, attrName);
      }
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null && bindingCommand.ignoreAttr) {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        continue;
      }
      attrDef = context._findAttr(realAttrTarget);
      if (attrDef !== null) {
        if (attrDef.isTemplateController) {
          throw createMappedError$2(703, realAttrTarget);
        }
        bindableInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(realAttrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);
        } else {
          primaryBindable = bindableInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            attrBindableInstructions = expr === null ? realAttrValue === "" ? [] : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)] : [new InterpolationInstruction(expr, primaryBindable.name)];
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        el.removeAttribute(attrName);
        --i;
        --ii;
        (attrInstructions ??= []).push(new HydrateAttributeInstruction(
          // todo: def/ def.Type or def.name should be configurable
          //       example: AOT/runtime can use def.Type, but there are situation
          //       where instructions need to be serialized, def.name should be used
          this.resolveResources ? attrDef : attrDef.name,
          attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,
          attrBindableInstructions
        ));
        continue;
      }
      if (bindingCommand === null) {
        expr = exprParser.parse(realAttrValue, etInterpolation$1);
        if (expr != null) {
          el.removeAttribute(attrName);
          --i;
          --ii;
          instructions.push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)
          ));
        } else {
          switch (attrName) {
            case "class":
              instructions.push(new SetClassAttributeInstruction(realAttrValue));
              break;
            case "style":
              instructions.push(new SetStyleAttributeInstruction(realAttrValue));
              break;
            default:
              instructions.push(new SetAttributeInstruction(realAttrValue, attrName));
          }
        }
      } else {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      }
    }
    resetCommandBuildInfo();
    if (attrInstructions != null) {
      return attrInstructions.concat(instructions);
    }
    return instructions;
  }
  // overall flow:
  // each of the method will be responsible for compiling its corresponding node type
  // and it should return the next node to be compiled
  /** @internal */
  _compileNode(node, context) {
    switch (node.nodeType) {
      case 1:
        switch (node.nodeName) {
          case "LET":
            return this._compileLet(node, context);
          // ------------------------------------
          // todo: possible optimization:
          // when two conditions below are met:
          // 1. there's no attribute on au slot,
          // 2. there's no projection
          //
          // -> flatten the au-slot into children as this is just a static template
          // ------------------------------------
          // case 'AU-SLOT':
          //   return this.auSlot(node as Element, container, context);
          default:
            return this._compileElement(node, context);
        }
      case 3:
        return this._compileText(node, context);
      case 11: {
        let current = node.firstChild;
        while (current !== null) {
          current = this._compileNode(current, context);
        }
        break;
      }
    }
    return node.nextSibling;
  }
  /** @internal */
  _compileLet(el, context) {
    const attrs = el.attributes;
    const ii = attrs.length;
    const letInstructions = [];
    const exprParser = context._exprParser;
    let toBindingContext = false;
    let i = 0;
    let attr;
    let attrSyntax;
    let attrName;
    let attrValue;
    let bindingCommand;
    let realAttrTarget;
    let realAttrValue;
    let expr;
    for (; ii > i; ++i) {
      attr = attrs[i];
      attrName = attr.name;
      attrValue = attr.value;
      if (attrName === "to-binding-context") {
        toBindingContext = true;
        continue;
      }
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null) {
        if (attrSyntax.command === "bind") {
          letInstructions.push(new LetBindingInstruction(exprParser.parse(realAttrValue, etIsProperty$1), camelCase(realAttrTarget)));
        } else {
          throw createMappedError$2(704, attrSyntax);
        }
        continue;
      }
      expr = exprParser.parse(realAttrValue, etInterpolation$1);
      if (expr === null) {
        {
          console.warn(`[DEV:aurelia] Property "${realAttrTarget}" is declared with literal string ${realAttrValue}. Did you mean ${realAttrTarget}.bind="${realAttrValue}"?`);
        }
      }
      letInstructions.push(new LetBindingInstruction(expr === null ? new PrimitiveLiteralExpression(realAttrValue) : expr, camelCase(realAttrTarget)));
    }
    context.rows.push([new HydrateLetElementInstruction(letInstructions, toBindingContext)]);
    return this._markAsTarget(el, context).nextSibling;
  }
  /** @internal */
  // eslint-disable-next-line
  _compileElement(el, context) {
    const nextSibling = el.nextSibling;
    const elName = (el.getAttribute("as-element") ?? el.nodeName).toLowerCase();
    const elDef = context._findElement(elName);
    const isCustomElement = elDef !== null;
    const isShadowDom = isCustomElement && elDef.shadowOptions != null;
    const capture = elDef?.capture;
    const hasCaptureFilter = capture != null && typeof capture !== "boolean";
    const captures = capture ? [] : emptyArray;
    const exprParser = context._exprParser;
    const removeAttr = this.debug ? noop : () => {
      el.removeAttribute(attrName);
      --i;
      --ii;
    };
    let attrs = el.attributes;
    let instructions;
    let ii = attrs.length;
    let i = 0;
    let attr;
    let attrName;
    let attrValue;
    let attrSyntax;
    let plainAttrInstructions;
    let elBindableInstructions;
    let attrDef = null;
    let isMultiBindings = false;
    let bindable2;
    let attrInstructions;
    let attrBindableInstructions;
    let tcInstructions;
    let tcInstruction;
    let expr;
    let elementInstruction;
    let bindingCommand = null;
    let bindablesInfo;
    let primaryBindable;
    let realAttrTarget;
    let realAttrValue;
    let processContentResult = true;
    let hasContainerless = false;
    let canCapture = false;
    let needsMarker = false;
    let elementMetadata;
    let spreadIndex = 0;
    if (elName === "slot") {
      if (context.root.def.shadowOptions == null) {
        throw createMappedError$2(717, context.root.def.name);
      }
      context.root.hasSlot = true;
    }
    if (isCustomElement) {
      elementMetadata = {};
      processContentResult = elDef.processContent?.call(elDef.Type, el, context.p, elementMetadata);
      attrs = el.attributes;
      ii = attrs.length;
    }
    for (; ii > i; ++i) {
      attr = attrs[i];
      attrName = attr.name;
      attrValue = attr.value;
      switch (attrName) {
        // ignore these 2 attributes
        case "as-element":
        case "containerless":
          removeAttr();
          hasContainerless = hasContainerless || attrName === "containerless";
          continue;
      }
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      bindingCommand = context._getCommand(attrSyntax);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      if (capture && (!hasCaptureFilter || hasCaptureFilter && capture(realAttrTarget))) {
        if (bindingCommand != null && bindingCommand.ignoreAttr) {
          removeAttr();
          captures.push(attrSyntax);
          continue;
        }
        canCapture = realAttrTarget !== auslotAttr$1 && realAttrTarget !== "slot" && ((spreadIndex = realAttrTarget.indexOf("...")) === -1 || spreadIndex === 0 && realAttrTarget === "...$attrs");
        if (canCapture) {
          bindablesInfo = context._getBindables(elDef);
          if (bindablesInfo.attrs[realAttrTarget] == null && !context._findAttr(realAttrTarget)?.isTemplateController) {
            removeAttr();
            captures.push(attrSyntax);
            continue;
          }
        }
      }
      if (realAttrTarget === "...$attrs") {
        (plainAttrInstructions ??= []).push(new SpreadTransferedBindingInstruction());
        removeAttr();
        continue;
      }
      if (bindingCommand?.ignoreAttr) {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        (plainAttrInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        removeAttr();
        continue;
      }
      if (realAttrTarget.indexOf("...") === 0) {
        if (isCustomElement && (realAttrTarget = realAttrTarget.slice(3)) !== "$element") {
          (elBindableInstructions ??= []).push(new SpreadValueBindingInstruction("$bindables", realAttrTarget === "$bindables" ? realAttrValue : realAttrTarget));
          removeAttr();
          continue;
        }
        {
          if (realAttrTarget === "$bindable" || realAttrTarget === "bindables") {
            console.warn(`[DEV:aurelia] Detected usage of ${realAttrTarget} on <${el.nodeName}>, did you mean "$bindables"?`);
          }
        }
        throw createMappedError$2(720, realAttrTarget);
      }
      if (isCustomElement) {
        bindablesInfo = context._getBindables(elDef);
        bindable2 = bindablesInfo.attrs[realAttrTarget];
        if (bindable2 !== void 0) {
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            (elBindableInstructions ??= []).push(expr == null ? new SetPropertyInstruction(realAttrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name));
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = bindable2;
            commandBuildInfo.def = elDef;
            (elBindableInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
          }
          removeAttr();
          {
            attrDef = context._findAttr(realAttrTarget);
            if (attrDef !== null) {
              console.warn(`[DEV:aurelia] Binding with bindable "${realAttrTarget}" on custom element "${elDef.name}" is ambiguous.There is a custom attribute with the same name.`);
            }
          }
          continue;
        }
        if (realAttrTarget === "$bindables") {
          if (bindingCommand != null) {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = null;
            commandBuildInfo.def = elDef;
            {
              const instruction = bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper);
              if (!(instruction instanceof SpreadValueBindingInstruction)) {
                console.warn(`[DEV:aurelia] Binding with "$bindables" on custom element "${elDef.name}" with command ${attrSyntax.command}  did not result in a spread binding instruction. This likely won't work as expected.`);
              }
              (elBindableInstructions ??= []).push(instruction);
            }
          } else {
            console.warn(`[DEV:aurelia] Usage of "$bindables" on custom element "<${elDef.name}>" is ignored.`);
          }
          removeAttr();
          continue;
        }
      }
      if (realAttrTarget === "$bindables") {
        throw createMappedError$2(721, el.nodeName, realAttrTarget, realAttrValue);
      }
      attrDef = context._findAttr(realAttrTarget);
      if (attrDef !== null) {
        bindablesInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(realAttrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);
        } else {
          primaryBindable = bindablesInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            attrBindableInstructions = expr === null ? realAttrValue === "" ? [] : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)] : [new InterpolationInstruction(expr, primaryBindable.name)];
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        removeAttr();
        if (attrDef.isTemplateController) {
          (tcInstructions ??= []).push(new HydrateTemplateController(
            voidDefinition,
            // todo: def/ def.Type or def.name should be configurable
            //       example: AOT/runtime can use def.Type, but there are situation
            //       where instructions need to be serialized, def.name should be used
            this.resolveResources ? attrDef : attrDef.name,
            void 0,
            attrBindableInstructions
          ));
        } else {
          (attrInstructions ??= []).push(new HydrateAttributeInstruction(
            // todo: def/ def.Type or def.name should be configurable
            //       example: AOT/runtime can use def.Type, but there are situation
            //       where instructions need to be serialized, def.name should be used
            this.resolveResources ? attrDef : attrDef.name,
            attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,
            attrBindableInstructions
          ));
        }
        continue;
      }
      if (bindingCommand === null) {
        expr = exprParser.parse(realAttrValue, etInterpolation$1);
        if (expr != null) {
          removeAttr();
          (plainAttrInstructions ??= []).push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)
          ));
        }
        continue;
      }
      commandBuildInfo.node = el;
      commandBuildInfo.attr = attrSyntax;
      commandBuildInfo.bindable = null;
      commandBuildInfo.def = null;
      (plainAttrInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      removeAttr();
    }
    resetCommandBuildInfo();
    if (this._shouldReorderAttrs(el, plainAttrInstructions) && plainAttrInstructions != null && plainAttrInstructions.length > 1) {
      this._reorder(el, plainAttrInstructions);
    }
    if (isCustomElement) {
      elementInstruction = new HydrateElementInstruction(
        // todo: def/ def.Type or def.name should be configurable
        //       example: AOT/runtime can use def.Type, but there are situation
        //       where instructions need to be serialized, def.name should be used
        this.resolveResources ? elDef : elDef.name,
        elBindableInstructions ?? emptyArray,
        null,
        hasContainerless,
        captures,
        elementMetadata
      );
    }
    if (plainAttrInstructions != null || elementInstruction != null || attrInstructions != null) {
      instructions = emptyArray.concat(elementInstruction ?? emptyArray, attrInstructions ?? emptyArray, plainAttrInstructions ?? emptyArray);
      needsMarker = true;
    }
    let shouldCompileContent;
    if (tcInstructions != null) {
      ii = tcInstructions.length - 1;
      i = ii;
      tcInstruction = tcInstructions[i];
      let template2;
      if (isMarker(el)) {
        template2 = context.t();
        appendManyToTemplate(template2, [
          // context.h(MARKER_NODE_NAME),
          context._marker(),
          context._comment(auLocationStart),
          context._comment(auLocationEnd)
        ]);
      } else {
        this._replaceByMarker(el, context);
        if (el.nodeName === "TEMPLATE") {
          template2 = el;
        } else {
          template2 = context.t();
          appendToTemplate(template2, el);
        }
      }
      const mostInnerTemplate = template2;
      const childContext = context._createChild(instructions == null ? [] : [instructions]);
      let childEl;
      let targetSlot;
      let hasAuSlot = false;
      let projections;
      let slotTemplateRecord;
      let slotTemplates;
      let slotTemplate;
      let marker;
      let projectionCompilationContext;
      let j = 0, jj = 0;
      let child = el.firstChild;
      let isEmptyTextNode = false;
      if (processContentResult !== false) {
        while (child !== null) {
          targetSlot = isElement$2(child) ? child.getAttribute(auslotAttr$1) : null;
          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;
          childEl = child.nextSibling;
          if (hasAuSlot) {
            if (!isCustomElement) {
              throw createMappedError$2(706, targetSlot, elName);
            }
            child.removeAttribute?.(auslotAttr$1);
            isEmptyTextNode = isTextNode(child) && child.textContent.trim() === "";
            if (!isEmptyTextNode) {
              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName$1] ??= []).push(child);
            }
            el.removeChild(child);
          }
          child = childEl;
        }
      }
      if (slotTemplateRecord != null) {
        projections = {};
        for (targetSlot in slotTemplateRecord) {
          template2 = context.t();
          slotTemplates = slotTemplateRecord[targetSlot];
          for (j = 0, jj = slotTemplates.length; jj > j; ++j) {
            slotTemplate = slotTemplates[j];
            if (slotTemplate.nodeName === "TEMPLATE") {
              if (slotTemplate.attributes.length > 0) {
                appendToTemplate(template2, slotTemplate);
              } else {
                appendToTemplate(template2, slotTemplate.content);
              }
            } else {
              appendToTemplate(template2, slotTemplate);
            }
          }
          projectionCompilationContext = context._createChild();
          this._compileNode(template2.content, projectionCompilationContext);
          projections[targetSlot] = {
            name: generateElementName$1(),
            type: definitionTypeElement,
            template: template2,
            instructions: projectionCompilationContext.rows,
            needsCompile: false
          };
        }
        elementInstruction.projections = projections;
      }
      if (needsMarker) {
        if (isCustomElement && (hasContainerless || elDef.containerless)) {
          this._replaceByMarker(el, context);
        } else {
          this._markAsTarget(el, context);
        }
      }
      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;
      if (shouldCompileContent) {
        if (el.nodeName === TEMPLATE_NODE_NAME) {
          this._compileNode(el.content, childContext);
        } else {
          child = el.firstChild;
          while (child !== null) {
            child = this._compileNode(child, childContext);
          }
        }
      }
      tcInstruction.def = {
        name: generateElementName$1(),
        type: definitionTypeElement,
        template: mostInnerTemplate,
        instructions: childContext.rows,
        needsCompile: false
      };
      while (i-- > 0) {
        tcInstruction = tcInstructions[i];
        template2 = context.t();
        marker = context._marker();
        appendManyToTemplate(template2, [
          marker,
          context._comment(auLocationStart),
          context._comment(auLocationEnd)
        ]);
        tcInstruction.def = {
          name: generateElementName$1(),
          type: definitionTypeElement,
          template: template2,
          needsCompile: false,
          instructions: [[tcInstructions[i + 1]]]
        };
      }
      context.rows.push([tcInstruction]);
    } else {
      if (instructions != null) {
        context.rows.push(instructions);
      }
      let child = el.firstChild;
      let childEl;
      let targetSlot;
      let hasAuSlot = false;
      let projections = null;
      let slotTemplateRecord;
      let slotTemplates;
      let slotTemplate;
      let template2;
      let projectionCompilationContext;
      let isEmptyTextNode = false;
      let j = 0, jj = 0;
      if (processContentResult !== false) {
        while (child !== null) {
          targetSlot = isElement$2(child) ? child.getAttribute(auslotAttr$1) : null;
          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;
          childEl = child.nextSibling;
          if (hasAuSlot) {
            if (!isCustomElement) {
              throw createMappedError$2(706, targetSlot, elName);
            }
            child.removeAttribute?.(auslotAttr$1);
            isEmptyTextNode = isTextNode(child) && child.textContent.trim() === "";
            if (!isEmptyTextNode) {
              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName$1] ??= []).push(child);
            }
            el.removeChild(child);
          }
          child = childEl;
        }
      }
      if (slotTemplateRecord != null) {
        projections = {};
        for (targetSlot in slotTemplateRecord) {
          template2 = context.t();
          slotTemplates = slotTemplateRecord[targetSlot];
          for (j = 0, jj = slotTemplates.length; jj > j; ++j) {
            slotTemplate = slotTemplates[j];
            if (slotTemplate.nodeName === TEMPLATE_NODE_NAME) {
              if (slotTemplate.attributes.length > 0) {
                appendToTemplate(template2, slotTemplate);
              } else {
                appendToTemplate(template2, slotTemplate.content);
              }
            } else {
              appendToTemplate(template2, slotTemplate);
            }
          }
          projectionCompilationContext = context._createChild();
          this._compileNode(template2.content, projectionCompilationContext);
          projections[targetSlot] = {
            name: generateElementName$1(),
            type: definitionTypeElement,
            template: template2,
            instructions: projectionCompilationContext.rows,
            needsCompile: false
          };
        }
        elementInstruction.projections = projections;
      }
      if (needsMarker) {
        if (isCustomElement && (hasContainerless || elDef.containerless)) {
          this._replaceByMarker(el, context);
        } else {
          this._markAsTarget(el, context);
        }
      }
      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;
      if (shouldCompileContent && el.childNodes.length > 0) {
        child = el.firstChild;
        while (child !== null) {
          child = this._compileNode(child, context);
        }
      }
    }
    return nextSibling;
  }
  /** @internal */
  _compileText(node, context) {
    const parent = node.parentNode;
    const expr = context._exprParser.parse(node.textContent, etInterpolation$1);
    const next = node.nextSibling;
    let parts;
    let expressions;
    let i;
    let ii;
    let part;
    if (expr !== null) {
      ({ parts, expressions } = expr);
      if (part = parts[0]) {
        insertBefore(parent, context._text(part), node);
      }
      for (i = 0, ii = expressions.length; ii > i; ++i) {
        insertManyBefore$1(parent, node, [
          // context.h(MARKER_NODE_NAME),
          context._marker(),
          // empty text node will not be cloned when doing fragment.cloneNode()
          // so give it an empty space instead
          context._text(" ")
        ]);
        if (part = parts[i + 1]) {
          insertBefore(parent, context._text(part), node);
        }
        context.rows.push([new TextBindingInstruction(expressions[i])]);
      }
      parent.removeChild(node);
    }
    return next;
  }
  /** @internal */
  _compileMultiBindings(node, attrRawValue, attrDef, context) {
    const bindableAttrsInfo = context._getBindables(attrDef);
    const valueLength = attrRawValue.length;
    const instructions = [];
    let attrName = void 0;
    let attrValue = void 0;
    let start2 = 0;
    let ch = 0;
    let expr;
    let attrSyntax;
    let command;
    let bindable2;
    for (let i = 0; i < valueLength; ++i) {
      ch = attrRawValue.charCodeAt(i);
      if (ch === 92) {
        ++i;
      } else if (ch === 58) {
        attrName = attrRawValue.slice(start2, i);
        while (attrRawValue.charCodeAt(++i) <= 32)
          ;
        start2 = i;
        for (; i < valueLength; ++i) {
          ch = attrRawValue.charCodeAt(i);
          if (ch === 92) {
            ++i;
          } else if (ch === 59) {
            attrValue = attrRawValue.slice(start2, i);
            break;
          }
        }
        if (attrValue === void 0) {
          attrValue = attrRawValue.slice(start2);
        }
        attrSyntax = context._attrParser.parse(attrName, attrValue);
        command = context._getCommand(attrSyntax);
        bindable2 = bindableAttrsInfo.attrs[attrSyntax.target];
        if (bindable2 == null) {
          throw createMappedError$2(707, attrSyntax.target, attrDef.name);
        }
        if (command === null) {
          expr = context._exprParser.parse(attrValue, etInterpolation$1);
          instructions.push(expr === null ? new SetPropertyInstruction(attrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name));
        } else {
          commandBuildInfo.node = node;
          commandBuildInfo.attr = attrSyntax;
          commandBuildInfo.bindable = bindable2;
          commandBuildInfo.def = attrDef;
          instructions.push(command.build(commandBuildInfo, context._exprParser, context._attrMapper));
        }
        while (i < valueLength && attrRawValue.charCodeAt(++i) <= 32)
          ;
        start2 = i;
        attrName = void 0;
        attrValue = void 0;
      }
    }
    resetCommandBuildInfo();
    return instructions;
  }
  /** @internal */
  _compileLocalElement(template2, context) {
    const elName = context.root.def.name;
    const root = template2;
    const localTemplates = toArray(root.querySelectorAll("template[as-custom-element]"));
    const numLocalTemplates = localTemplates.length;
    if (numLocalTemplates === 0) {
      return;
    }
    if (numLocalTemplates === root.childElementCount) {
      throw createMappedError$2(708, elName);
    }
    const localTemplateNames = /* @__PURE__ */ new Set();
    const localElementTypes = [];
    for (const localTemplate of localTemplates) {
      if (localTemplate.parentNode !== root) {
        throw createMappedError$2(709, elName);
      }
      const name2 = processTemplateName(elName, localTemplate, localTemplateNames);
      const content = localTemplate.content;
      const bindableEls = toArray(content.querySelectorAll("bindable"));
      const properties = /* @__PURE__ */ new Set();
      const attributes = /* @__PURE__ */ new Set();
      const bindables2 = bindableEls.reduce((allBindables, bindableEl) => {
        if (bindableEl.parentNode !== content) {
          throw createMappedError$2(710, name2);
        }
        const property = bindableEl.getAttribute(
          "name"
          /* LocalTemplateBindableAttributes.name */
        );
        if (property === null) {
          throw createMappedError$2(711, bindableEl, name2);
        }
        const attribute = bindableEl.getAttribute(
          "attribute"
          /* LocalTemplateBindableAttributes.attribute */
        );
        if (attribute !== null && attributes.has(attribute) || properties.has(property)) {
          throw createMappedError$2(712, properties, attribute);
        } else {
          if (attribute !== null) {
            attributes.add(attribute);
          }
          properties.add(property);
        }
        const ignoredAttributes = toArray(bindableEl.attributes).filter((attr) => !allowedLocalTemplateBindableAttributes.includes(attr.name));
        if (ignoredAttributes.length > 0) {
          console.warn(`[DEV:aurelia] The attribute(s) ${ignoredAttributes.map((attr) => attr.name).join(", ")} will be ignored for ${bindableEl.outerHTML}. Only ${allowedLocalTemplateBindableAttributes.join(", ")} are processed.`);
        }
        bindableEl.remove();
        allBindables[property] = {
          name: property,
          attribute: attribute ?? void 0,
          mode: bindableEl.getAttribute(
            "mode"
            /* LocalTemplateBindableAttributes.mode */
          ) ?? "default"
        };
        return allBindables;
      }, {});
      class LocalDepType {
      }
      LocalDepType.$au = {
        type: definitionTypeElement,
        name: name2,
        template: localTemplate,
        bindables: bindables2
      };
      Reflect.defineProperty(LocalDepType, "name", { value: pascalCase(name2) });
      localElementTypes.push(LocalDepType);
      root.removeChild(localTemplate);
    }
    const compilationDeps = (context.root.def.dependencies ?? []).concat(context.root.def.Type == null ? emptyArray : [context.root.def.Type]);
    for (const localElementType of localElementTypes) {
      localElementType.dependencies = compilationDeps.concat(localElementTypes.filter((d3) => d3 !== localElementType));
      context._addLocalDep(localElementType);
    }
  }
  /** @internal */
  _shouldReorderAttrs(el, instructions) {
    const nodeName = el.nodeName;
    return nodeName === "INPUT" && orderSensitiveInputType[el.type] === 1 || nodeName === "SELECT" && (el.hasAttribute("multiple") || instructions?.some((i) => i.type === propertyBinding && i.to === "multiple"));
  }
  /** @internal */
  _reorder(el, instructions) {
    switch (el.nodeName) {
      case "INPUT": {
        const _instructions = instructions;
        let modelOrValueOrMatcherIndex = void 0;
        let checkedIndex = void 0;
        let found = 0;
        let instruction;
        for (let i = 0; i < _instructions.length && found < 3; i++) {
          instruction = _instructions[i];
          switch (instruction.to) {
            case "model":
            case "value":
            case "matcher":
              modelOrValueOrMatcherIndex = i;
              found++;
              break;
            case "checked":
              checkedIndex = i;
              found++;
              break;
          }
        }
        if (checkedIndex !== void 0 && modelOrValueOrMatcherIndex !== void 0 && checkedIndex < modelOrValueOrMatcherIndex) {
          [_instructions[modelOrValueOrMatcherIndex], _instructions[checkedIndex]] = [_instructions[checkedIndex], _instructions[modelOrValueOrMatcherIndex]];
        }
        break;
      }
      case "SELECT": {
        const _instructions = instructions;
        let valueIndex = 0;
        let multipleIndex = 0;
        let found = 0;
        let instruction;
        for (let i = 0; i < _instructions.length && found < 2; ++i) {
          instruction = _instructions[i];
          switch (instruction.to) {
            case "multiple":
              multipleIndex = i;
              found++;
              break;
            case "value":
              valueIndex = i;
              found++;
              break;
          }
          if (found === 2 && valueIndex < multipleIndex) {
            [_instructions[multipleIndex], _instructions[valueIndex]] = [_instructions[valueIndex], _instructions[multipleIndex]];
          }
        }
      }
    }
  }
  /**
   * Mark an element as target with a special css class
   * and return it
   *
   * @internal
   */
  _markAsTarget(el, context) {
    insertBefore(el.parentNode, context._comment("au*"), el);
    return el;
  }
  /**
   * Replace an element with a marker, and return the marker
   *
   * @internal
   */
  _replaceByMarker(node, context) {
    if (isMarker(node)) {
      return node;
    }
    const parent = node.parentNode;
    const marker = context._marker();
    insertManyBefore$1(parent, node, [
      marker,
      context._comment(auLocationStart),
      context._comment(auLocationEnd)
    ]);
    parent.removeChild(node);
    return marker;
  }
}
TemplateCompiler.register = createImplementationRegister(ITemplateCompiler);
const TEMPLATE_NODE_NAME = "TEMPLATE";
const isMarker = (el) => el.nodeValue === "au*";
class CompilationContext {
  constructor(def2, container, parent, root, instructions) {
    this.hasSlot = false;
    this.deps = null;
    const hasParent = parent !== null;
    this.c = container;
    this.root = root === null ? this : root;
    this.def = def2;
    this.parent = parent;
    this._resourceResolver = hasParent ? parent._resourceResolver : container.get(IResourceResolver);
    this._commandResolver = hasParent ? parent._commandResolver : container.get(IBindingCommandResolver);
    this._templateFactory = hasParent ? parent._templateFactory : container.get(ITemplateElementFactory);
    this._attrParser = hasParent ? parent._attrParser : container.get(IAttributeParser);
    this._exprParser = hasParent ? parent._exprParser : container.get(IExpressionParser);
    this._attrMapper = hasParent ? parent._attrMapper : container.get(IAttrMapper);
    this._logger = hasParent ? parent._logger : container.get(ILogger);
    if (typeof (this.p = hasParent ? parent.p : container.get(IPlatform$1)).document?.nodeType !== "number") {
      throw createMappedError$2(
        722
        /* ErrorNames.compiler_no_dom_api */
      );
    }
    this.localEls = hasParent ? parent.localEls : /* @__PURE__ */ new Set();
    this.rows = instructions ?? [];
  }
  _addLocalDep(Type) {
    (this.root.deps ??= []).push(Type);
    this.root.c.register(Type);
    return this;
  }
  _text(text) {
    return this.p.document.createTextNode(text);
  }
  _comment(text) {
    return this.p.document.createComment(text);
  }
  _marker() {
    return this._comment("au*");
  }
  h(name2) {
    const el = this.p.document.createElement(name2);
    if (name2 === "template") {
      this.p.document.adoptNode(el.content);
    }
    return el;
  }
  t() {
    return this.h("template");
  }
  /**
   * Find the custom element definition of a given name
   */
  _findElement(name2) {
    return this._resourceResolver.el(this.c, name2);
  }
  /**
   * Find the custom attribute definition of a given name
   */
  _findAttr(name2) {
    return this._resourceResolver.attr(this.c, name2);
  }
  _getBindables(def2) {
    return this._resourceResolver.bindables(def2);
  }
  /**
   * Create a new child compilation context
   */
  _createChild(instructions) {
    return new CompilationContext(this.def, this.c, this, this.root, instructions);
  }
  /**
   * Retrieve a binding command resource instance.
   *
   * @param name - The parsed `AttrSyntax`
   *
   * @returns An instance of the command if it exists, or `null` if it does not exist.
   */
  _getCommand(syntax) {
    const name2 = syntax.command;
    if (name2 === null) {
      return null;
    }
    return this._commandResolver.get(this.c, name2);
  }
}
const hasInlineBindings = (rawValue) => {
  const len = rawValue.length;
  let ch = 0;
  let i = 0;
  while (len > i) {
    ch = rawValue.charCodeAt(i);
    if (ch === 92) {
      ++i;
    } else if (ch === 58) {
      return true;
    } else if (ch === 36 && rawValue.charCodeAt(i + 1) === 123) {
      return false;
    }
    ++i;
  }
  return false;
};
const resetCommandBuildInfo = () => {
  commandBuildInfo.node = commandBuildInfo.attr = commandBuildInfo.bindable = commandBuildInfo.def = null;
};
const voidDefinition = { name: "unnamed", type: definitionTypeElement };
const commandBuildInfo = {
  node: null,
  attr: null,
  bindable: null,
  def: null
};
const invalidSurrogateAttribute = {
  "id": true,
  "name": true,
  "au-slot": true,
  "as-element": true
};
const orderSensitiveInputType = {
  checkbox: 1,
  radio: 1
  // todo: range is also sensitive to order, for min/max
};
const IResourceResolver = /* @__PURE__ */ tcCreateInterface("IResourceResolver");
const IBindingCommandResolver = /* @__PURE__ */ tcCreateInterface("IBindingCommandResolver", (x) => {
  class DefaultBindingCommandResolver {
    constructor() {
      this._cache = /* @__PURE__ */ new WeakMap();
    }
    get(c, name2) {
      let record = this._cache.get(c);
      if (!record) {
        this._cache.set(c, record = {});
      }
      return name2 in record ? record[name2] : record[name2] = BindingCommand.get(c, name2);
    }
  }
  return x.singleton(DefaultBindingCommandResolver);
});
const allowedLocalTemplateBindableAttributes = tcObjectFreeze([
  "name",
  "attribute",
  "mode"
  /* LocalTemplateBindableAttributes.mode */
]);
const localTemplateIdentifier = "as-custom-element";
const processTemplateName = (owningElementName, localTemplate, localTemplateNames) => {
  const name2 = localTemplate.getAttribute(localTemplateIdentifier);
  if (name2 === null || name2 === "") {
    throw createMappedError$2(715, owningElementName);
  }
  if (localTemplateNames.has(name2)) {
    throw createMappedError$2(716, name2, owningElementName);
  } else {
    localTemplateNames.add(name2);
    localTemplate.removeAttribute(localTemplateIdentifier);
  }
  return name2;
};
const ITemplateCompilerHooks = /* @__PURE__ */ tcCreateInterface("ITemplateCompilerHooks");
const TemplateCompilerHooks = tcObjectFreeze({
  name: /* @__PURE__ */ getResourceKeyFor("compiler-hooks"),
  define(Type) {
    return {
      register(container) {
        singletonRegistration$1(ITemplateCompilerHooks, Type).register(container);
      }
    };
  },
  findAll(container) {
    return container.get(allResources(ITemplateCompilerHooks));
  }
});
const hasOwnProp = Object.prototype.hasOwnProperty;
const rtDef = Reflect.defineProperty;
function rtDefineHiddenProp(obj, key, value) {
  rtDef(obj, key, {
    configurable: true,
    writable: true,
    value
  });
  return value;
}
function ensureProto(proto, key, defaultValue) {
  if (!(key in proto)) {
    rtDefineHiddenProp(proto, key, defaultValue);
  }
}
const rtObjectAssign = Object.assign;
const rtObjectFreeze = Object.freeze;
const rtSafeString = String;
const rtCreateInterface = DI.createInterface;
const rtGetMetadata = Metadata.get;
const rtDefineMetadata = Metadata.define;
const createMappedError$1 = (code, ...details) => new Error(`AUR${rtSafeString(code).padStart(4, "0")}: ${getMessageByCode$1(code, ...details)}`);
const errorsMap$1 = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    113
    /* ErrorNames.ast_increment_infinite_loop */
  ]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,
  [
    114
    /* ErrorNames.ast_nullish_member_access */
  ]: `Ast eval error: cannot access property "{{0}}" of {{1}}.`,
  [
    115
    /* ErrorNames.ast_nullish_keyed_access */
  ]: `Ast eval error: cannot access key "{{0}}" of {{1}}.`,
  [
    116
    /* ErrorNames.ast_nullish_assignment */
  ]: `Ast eval error: cannot assign value to property "{{0}}" of null/undefined.`,
  [
    151
    /* ErrorNames.parse_invalid_start */
  ]: `Expression error: invalid start: "{{0}}"`,
  [
    152
    /* ErrorNames.parse_no_spread */
  ]: `Expression error: spread operator is not supported: "{{0}}"`,
  [
    153
    /* ErrorNames.parse_expected_identifier */
  ]: `Expression error: expected identifier: "{{0}}"`,
  [
    154
    /* ErrorNames.parse_invalid_member_expr */
  ]: `Expression error: invalid member expression: "{{0}}"`,
  [
    155
    /* ErrorNames.parse_unexpected_end */
  ]: `Expression error: unexpected end of expression: "{{0}}"`,
  [
    156
    /* ErrorNames.parse_unconsumed_token */
  ]: `Expression error: unconsumed token: "{{0}}" at position {{1}} of "{{2}}"`,
  [
    157
    /* ErrorNames.parse_invalid_empty */
  ]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,
  [
    158
    /* ErrorNames.parse_left_hand_side_not_assignable */
  ]: `Expression error: left hand side of expression is not assignable: "{{0}}"`,
  [
    159
    /* ErrorNames.parse_expected_converter_identifier */
  ]: `Expression error: expected identifier to come after value converter operator: "{{0}}"`,
  [
    160
    /* ErrorNames.parse_expected_behavior_identifier */
  ]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,
  [
    161
    /* ErrorNames.parse_unexpected_keyword_of */
  ]: `Expression error: unexpected keyword "of": "{{0}}"`,
  [
    162
    /* ErrorNames.parse_unexpected_keyword_import */
  ]: `Expression error: unexpected keyword "import": "{{0}}"`,
  [
    163
    /* ErrorNames.parse_invalid_identifier_in_forof */
  ]: `Expression error: invalid BindingIdentifier at left hand side of "of": "{{0}}" | kind: {{1}}`,
  [
    164
    /* ErrorNames.parse_invalid_identifier_object_literal_key */
  ]: `Expression error: invalid or unsupported property definition in object literal: "{{0}}"`,
  [
    165
    /* ErrorNames.parse_unterminated_string */
  ]: `Expression error: unterminated quote in string literal: "{{0}}"`,
  [
    166
    /* ErrorNames.parse_unterminated_template_string */
  ]: `Expression error: unterminated template string: "{{0}}"`,
  [
    167
    /* ErrorNames.parse_missing_expected_token */
  ]: `Expression error: missing expected token "{{0}}" in "{{1}}"`,
  [
    168
    /* ErrorNames.parse_unexpected_character */
  ]: `Expression error: unexpected character: "{{0}}"`,
  [
    170
    /* ErrorNames.parse_unexpected_token_destructuring */
  ]: `Expression error: unexpected "{{0}}" at position "{{1}}" for destructuring assignment in "{{2}}"`,
  [
    171
    /* ErrorNames.parse_unexpected_token_optional_chain */
  ]: `Expression error: unexpected {{0}} at position "{{1}}" for optional chain in "{{2}}"`,
  [
    172
    /* ErrorNames.parse_invalid_tag_in_optional_chain */
  ]: `Expression error: invalid tagged template on optional chain in "{{1}}"`,
  [
    173
    /* ErrorNames.parse_invalid_arrow_params */
  ]: `Expression error: invalid arrow parameter list in "{{0}}"`,
  [
    174
    /* ErrorNames.parse_no_arrow_param_default_value */
  ]: `Expression error: arrow function with default parameters is not supported: "{{0}}"`,
  [
    175
    /* ErrorNames.parse_no_arrow_param_destructuring */
  ]: `Expression error: arrow function with destructuring parameters is not supported: "{{0}}"`,
  [
    176
    /* ErrorNames.parse_rest_must_be_last */
  ]: `Expression error: rest parameter must be last formal parameter in arrow function: "{{0}}"`,
  [
    178
    /* ErrorNames.parse_no_arrow_fn_body */
  ]: `Expression error: arrow function with function body is not supported: "{{0}}"`,
  [
    179
    /* ErrorNames.parse_unexpected_double_dot */
  ]: `Expression error: unexpected token '.' at position "{{1}}" in "{{0}}"`,
  [
    199
    /* ErrorNames.observing_null_undefined */
  ]: `Trying to observe property {{0}} on null/undefined`,
  [
    203
    /* ErrorNames.null_scope */
  ]: `Trying to retrieve a property or build a scope from a null/undefined scope`,
  [
    204
    /* ErrorNames.create_scope_with_null_context */
  ]: "Trying to create a scope with null/undefined binding context",
  [
    206
    /* ErrorNames.switch_on_null_connectable */
  ]: `Trying to switch to a null/undefined connectable`,
  [
    207
    /* ErrorNames.switch_active_connectable */
  ]: `Trying to enter an active connectable`,
  [
    208
    /* ErrorNames.switch_off_null_connectable */
  ]: `Trying to pop a null/undefined connectable`,
  [
    209
    /* ErrorNames.switch_off_inactive_connectable */
  ]: `Trying to exit an inactive connectable`,
  [
    210
    /* ErrorNames.non_recognisable_collection_type */
  ]: `Unrecognised collection type {{0:toString}}.`,
  [
    217
    /* ErrorNames.dirty_check_no_handler */
  ]: "There is no registration for IDirtyChecker interface. If you want to use your own dirty checker, make sure you register it.",
  [
    218
    /* ErrorNames.dirty_check_not_allowed */
  ]: `Dirty checked is not permitted in this application. Property key {{0}} is being dirty checked.`,
  [
    219
    /* ErrorNames.dirty_check_setter_not_allowed */
  ]: `Trying to set value for property {{0}} in dirty checker`,
  [
    220
    /* ErrorNames.assign_readonly_size */
  ]: `Map/Set "size" is a readonly property`,
  [
    221
    /* ErrorNames.assign_readonly_readonly_property_from_computed */
  ]: `Trying to assign value to readonly property "{{0}}" through computed observer.`,
  [
    224
    /* ErrorNames.invalid_observable_decorator_usage */
  ]: `Invalid @observable decorator usage, cannot determine property name`,
  [
    225
    /* ErrorNames.stopping_a_stopped_effect */
  ]: `Trying to stop an effect that has already been stopped`,
  [
    226
    /* ErrorNames.effect_maximum_recursion_reached */
  ]: `Maximum number of recursive effect run reached. Consider handle effect dependencies differently.`
};
const getMessageByCode$1 = (name2, ...details) => {
  let cooked = errorsMap$1[name2];
  for (let i = 0; i < details.length; ++i) {
    const regex = new RegExp(`{{${i}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i];
      if (value != null) {
        switch (method) {
          case "typeof":
            value = typeof value;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = rtSafeString(value[method.slice(1)]);
            } else {
              value = rtSafeString(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
class Scope {
  constructor(parent, bindingContext, overrideContext, isBoundary) {
    this.parent = parent;
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
    this.isBoundary = isBoundary;
  }
  static getContext(scope, name2, ancestor) {
    if (scope == null) {
      throw createMappedError$1(
        203
        /* ErrorNames.null_scope */
      );
    }
    let overrideContext = scope.overrideContext;
    let currentScope = scope;
    if (ancestor > 0) {
      while (ancestor > 0) {
        ancestor--;
        currentScope = currentScope.parent;
        if (currentScope == null) {
          return void 0;
        }
      }
      overrideContext = currentScope.overrideContext;
      return name2 in overrideContext ? overrideContext : currentScope.bindingContext;
    }
    while (currentScope != null && !currentScope.isBoundary && !(name2 in currentScope.overrideContext) && !(name2 in currentScope.bindingContext)) {
      currentScope = currentScope.parent;
    }
    if (currentScope == null) {
      return scope.bindingContext;
    }
    overrideContext = currentScope.overrideContext;
    return name2 in overrideContext ? overrideContext : currentScope.bindingContext;
  }
  static create(bc, oc, isBoundary) {
    if (bc == null) {
      throw createMappedError$1(
        204
        /* ErrorNames.create_scope_with_null_context */
      );
    }
    return new Scope(null, bc, oc ?? new OverrideContext(), isBoundary ?? false);
  }
  static fromParent(ps, bc, oc = new OverrideContext()) {
    if (ps == null) {
      throw createMappedError$1(
        203
        /* ErrorNames.null_scope */
      );
    }
    return new Scope(ps, bc, oc, false);
  }
}
class BindingContext {
  constructor(key, value) {
    if (key !== void 0) {
      this[key] = value;
    }
  }
}
class OverrideContext {
}
const { astAssign, astEvaluate, astBind, astUnbind } = /* @__PURE__ */ (() => {
  const ekAccessThis2 = "AccessThis";
  const ekAccessBoundary2 = "AccessBoundary";
  const ekAccessGlobal2 = "AccessGlobal";
  const ekAccessScope2 = "AccessScope";
  const ekArrayLiteral2 = "ArrayLiteral";
  const ekObjectLiteral2 = "ObjectLiteral";
  const ekPrimitiveLiteral2 = "PrimitiveLiteral";
  const ekNew2 = "New";
  const ekTemplate2 = "Template";
  const ekUnary2 = "Unary";
  const ekCallScope2 = "CallScope";
  const ekCallMember2 = "CallMember";
  const ekCallFunction2 = "CallFunction";
  const ekCallGlobal2 = "CallGlobal";
  const ekAccessMember2 = "AccessMember";
  const ekAccessKeyed2 = "AccessKeyed";
  const ekTaggedTemplate2 = "TaggedTemplate";
  const ekBinary2 = "Binary";
  const ekConditional2 = "Conditional";
  const ekAssign2 = "Assign";
  const ekArrowFunction2 = "ArrowFunction";
  const ekValueConverter2 = "ValueConverter";
  const ekBindingBehavior2 = "BindingBehavior";
  const ekArrayBindingPattern2 = "ArrayBindingPattern";
  const ekObjectBindingPattern2 = "ObjectBindingPattern";
  const ekBindingIdentifier2 = "BindingIdentifier";
  const ekForOfStatement2 = "ForOfStatement";
  const ekInterpolation2 = "Interpolation";
  const ekArrayDestructuring2 = "ArrayDestructuring";
  const ekObjectDestructuring2 = "ObjectDestructuring";
  const ekDestructuringAssignmentLeaf2 = "DestructuringAssignmentLeaf";
  const ekCustom2 = "Custom";
  const getContext = Scope.getContext;
  function astEvaluate2(ast, s, e, c) {
    switch (ast.$kind) {
      case ekAccessThis2: {
        let oc = s.overrideContext;
        let currentScope = s;
        let i = ast.ancestor;
        while (i-- && oc) {
          currentScope = currentScope.parent;
          oc = currentScope?.overrideContext ?? null;
        }
        return i < 1 && currentScope ? currentScope.bindingContext : void 0;
      }
      case ekAccessBoundary2: {
        let currentScope = s;
        while (currentScope != null && !currentScope.isBoundary) {
          currentScope = currentScope.parent;
        }
        return currentScope ? currentScope.bindingContext : void 0;
      }
      case ekAccessScope2: {
        const obj = getContext(s, ast.name, ast.ancestor);
        if (c !== null) {
          c.observe(obj, ast.name);
        }
        const evaluatedValue = obj[ast.name];
        if (evaluatedValue == null) {
          if (ast.name === "$host") {
            throw createMappedError$1(
              105
              /* ErrorNames.ast_$host_not_found */
            );
          }
          return evaluatedValue;
        }
        return e?.boundFn && isFunction(evaluatedValue) ? evaluatedValue.bind(obj) : evaluatedValue;
      }
      case ekAccessGlobal2:
        return globalThis[ast.name];
      case ekCallGlobal2: {
        const func = globalThis[ast.name];
        if (isFunction(func)) {
          return func(...ast.args.map((a) => astEvaluate2(a, s, e, c)));
        }
        if (!e?.strict && func == null) {
          return void 0;
        }
        throw createMappedError$1(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekArrayLiteral2:
        return ast.elements.map((expr) => astEvaluate2(expr, s, e, c));
      case ekObjectLiteral2: {
        const instance = {};
        for (let i = 0; i < ast.keys.length; ++i) {
          instance[ast.keys[i]] = astEvaluate2(ast.values[i], s, e, c);
        }
        return instance;
      }
      case ekPrimitiveLiteral2:
        return ast.value;
      case ekNew2: {
        const func = astEvaluate2(ast.func, s, e, c);
        if (isFunction(func)) {
          return new func(...ast.args.map((a) => astEvaluate2(a, s, e, c)));
        }
        throw createMappedError$1(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekTemplate2: {
        let result = ast.cooked[0];
        for (let i = 0; i < ast.expressions.length; ++i) {
          result += rtSafeString(astEvaluate2(ast.expressions[i], s, e, c));
          result += ast.cooked[i + 1];
        }
        return result;
      }
      case ekUnary2: {
        const value = astEvaluate2(ast.expression, s, e, c);
        switch (ast.operation) {
          case "void":
            return void value;
          case "typeof":
            return typeof value;
          case "!":
            return !value;
          case "-":
            return -value;
          case "+":
            return +value;
          case "--":
            if (c != null)
              throw createMappedError$1(
                113
                /* ErrorNames.ast_increment_infinite_loop */
              );
            return astAssign2(ast.expression, s, e, c, value - 1) + ast.pos;
          case "++":
            if (c != null)
              throw createMappedError$1(
                113
                /* ErrorNames.ast_increment_infinite_loop */
              );
            return astAssign2(ast.expression, s, e, c, value + 1) - ast.pos;
          default:
            throw createMappedError$1(109, ast.operation);
        }
      }
      case ekCallScope2: {
        const context = getContext(s, ast.name, ast.ancestor);
        if (context == null) {
          if (e?.strict) {
            throw createMappedError$1(114, ast.name, context);
          }
          return void 0;
        }
        const fn2 = context[ast.name];
        if (isFunction(fn2)) {
          return fn2.apply(context, ast.args.map((a) => astEvaluate2(a, s, e, c)));
        }
        if (fn2 == null) {
          if (e?.strict && !ast.optional) {
            throw createMappedError$1(111, ast.name);
          }
          return void 0;
        }
        throw createMappedError$1(111, ast.name);
      }
      case ekCallMember2: {
        const instance = astEvaluate2(ast.object, s, e, c);
        if (instance == null) {
          if (e?.strict && !ast.optionalMember) {
            throw createMappedError$1(114, ast.name, instance);
          }
        }
        const fn2 = instance?.[ast.name];
        if (fn2 == null) {
          if (!ast.optionalCall && e?.strict) {
            throw createMappedError$1(111, ast.name);
          }
          return void 0;
        }
        if (!isFunction(fn2)) {
          throw createMappedError$1(111, ast.name);
        }
        const ret = fn2.apply(instance, ast.args.map((a) => astEvaluate2(a, s, e, c)));
        if (isArray(instance) && autoObserveArrayMethods.includes(ast.name)) {
          c?.observeCollection(instance);
        }
        return ret;
      }
      case ekCallFunction2: {
        const func = astEvaluate2(ast.func, s, e, c);
        if (isFunction(func)) {
          return func(...ast.args.map((a) => astEvaluate2(a, s, e, c)));
        }
        if (func == null) {
          if (!ast.optional && e?.strict) {
            throw createMappedError$1(
              107
              /* ErrorNames.ast_not_a_function */
            );
          }
          return void 0;
        }
        throw createMappedError$1(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekArrowFunction2: {
        const func = (...args) => {
          const params = ast.args;
          const rest = ast.rest;
          const lastIdx = params.length - 1;
          const context = params.reduce((map, param, i) => {
            if (rest && i === lastIdx) {
              map[param.name] = args.slice(i);
            } else {
              map[param.name] = args[i];
            }
            return map;
          }, {});
          const functionScope = Scope.fromParent(s, context);
          return astEvaluate2(ast.body, functionScope, e, c);
        };
        return func;
      }
      case ekAccessMember2: {
        const instance = astEvaluate2(ast.object, s, e, c);
        if (instance == null) {
          if (!ast.optional && e?.strict) {
            throw createMappedError$1(114, ast.name, instance);
          }
          return void 0;
        }
        if (c !== null && !ast.accessGlobal) {
          c.observe(instance, ast.name);
        }
        const ret = instance[ast.name];
        return e?.boundFn && isFunction(ret) ? ret.bind(instance) : ret;
      }
      case ekAccessKeyed2: {
        const instance = astEvaluate2(ast.object, s, e, c);
        const key = astEvaluate2(ast.key, s, e, c);
        if (instance == null) {
          if (!ast.optional && e?.strict) {
            throw createMappedError$1(115, key, instance);
          }
          return void 0;
        }
        if (c !== null && !ast.accessGlobal) {
          c.observe(instance, key);
        }
        return instance[key];
      }
      case ekTaggedTemplate2: {
        const results = ast.expressions.map((expr) => astEvaluate2(expr, s, e, c));
        const func = astEvaluate2(ast.func, s, e, c);
        if (!isFunction(func)) {
          throw createMappedError$1(
            110
            /* ErrorNames.ast_tagged_not_a_function */
          );
        }
        return func(ast.cooked, ...results);
      }
      case ekBinary2: {
        const left2 = ast.left;
        const right2 = ast.right;
        switch (ast.operation) {
          case "&&":
            return astEvaluate2(left2, s, e, c) && astEvaluate2(right2, s, e, c);
          case "||":
            return astEvaluate2(left2, s, e, c) || astEvaluate2(right2, s, e, c);
          case "??":
            return astEvaluate2(left2, s, e, c) ?? astEvaluate2(right2, s, e, c);
          case "==":
            return astEvaluate2(left2, s, e, c) == astEvaluate2(right2, s, e, c);
          case "===":
            return astEvaluate2(left2, s, e, c) === astEvaluate2(right2, s, e, c);
          case "!=":
            return astEvaluate2(left2, s, e, c) != astEvaluate2(right2, s, e, c);
          case "!==":
            return astEvaluate2(left2, s, e, c) !== astEvaluate2(right2, s, e, c);
          case "instanceof": {
            const $right = astEvaluate2(right2, s, e, c);
            if (isFunction($right)) {
              return astEvaluate2(left2, s, e, c) instanceof $right;
            }
            return false;
          }
          case "in": {
            const $right = astEvaluate2(right2, s, e, c);
            if (isObjectOrFunction($right)) {
              return astEvaluate2(left2, s, e, c) in $right;
            }
            return false;
          }
          case "+":
            return astEvaluate2(left2, s, e, c) + astEvaluate2(right2, s, e, c);
          case "-":
            return astEvaluate2(left2, s, e, c) - astEvaluate2(right2, s, e, c);
          case "*":
            return astEvaluate2(left2, s, e, c) * astEvaluate2(right2, s, e, c);
          case "/":
            return astEvaluate2(left2, s, e, c) / astEvaluate2(right2, s, e, c);
          case "%":
            return astEvaluate2(left2, s, e, c) % astEvaluate2(right2, s, e, c);
          case "**":
            return astEvaluate2(left2, s, e, c) ** astEvaluate2(right2, s, e, c);
          case "<":
            return astEvaluate2(left2, s, e, c) < astEvaluate2(right2, s, e, c);
          case ">":
            return astEvaluate2(left2, s, e, c) > astEvaluate2(right2, s, e, c);
          case "<=":
            return astEvaluate2(left2, s, e, c) <= astEvaluate2(right2, s, e, c);
          case ">=":
            return astEvaluate2(left2, s, e, c) >= astEvaluate2(right2, s, e, c);
          default:
            throw createMappedError$1(108, ast.operation);
        }
      }
      case ekConditional2:
        return astEvaluate2(ast.condition, s, e, c) ? astEvaluate2(ast.yes, s, e, c) : astEvaluate2(ast.no, s, e, c);
      case ekAssign2: {
        let value = astEvaluate2(ast.value, s, e, c);
        if (ast.op !== "=") {
          if (c != null) {
            throw createMappedError$1(
              113
              /* ErrorNames.ast_increment_infinite_loop */
            );
          }
          const target = astEvaluate2(ast.target, s, e, c);
          switch (ast.op) {
            case "/=":
              value = target / value;
              break;
            case "*=":
              value = target * value;
              break;
            case "+=":
              value = target + value;
              break;
            case "-=":
              value = target - value;
              break;
            default:
              throw createMappedError$1(108, ast.op);
          }
        }
        return astAssign2(ast.target, s, e, c, value);
      }
      case ekValueConverter2: {
        return e?.useConverter?.(ast.name, "toView", astEvaluate2(ast.expression, s, e, c), ast.args.map((a) => astEvaluate2(a, s, e, c)));
      }
      case ekBindingBehavior2:
        return astEvaluate2(ast.expression, s, e, c);
      case ekBindingIdentifier2:
        return ast.name;
      case ekForOfStatement2:
        return astEvaluate2(ast.iterable, s, e, c);
      case ekInterpolation2:
        if (ast.isMulti) {
          let result = ast.parts[0];
          let i = 0;
          for (; i < ast.expressions.length; ++i) {
            result += rtSafeString(astEvaluate2(ast.expressions[i], s, e, c));
            result += ast.parts[i + 1];
          }
          return result;
        } else {
          return `${ast.parts[0]}${astEvaluate2(ast.firstExpression, s, e, c)}${ast.parts[1]}`;
        }
      case ekDestructuringAssignmentLeaf2:
        return astEvaluate2(ast.target, s, e, c);
      case ekArrayDestructuring2: {
        return ast.list.map((x) => astEvaluate2(x, s, e, c));
      }
      // TODO: this should come after batch
      // as a destructuring expression like [x, y] = value
      //
      // should only trigger change only once:
      // batch(() => {
      //   object.x = value[0]
      //   object.y = value[1]
      // })
      //
      // instead of twice:
      // object.x = value[0]
      // object.y = value[1]
      case ekArrayBindingPattern2:
      // TODO
      // similar to array binding ast, this should only come after batch
      // for a single notification per destructing,
      // regardless number of property assignments on the scope binding context
      case ekObjectBindingPattern2:
      case ekObjectDestructuring2:
      default:
        return void 0;
      case ekCustom2:
        return ast.evaluate(s, e, c);
    }
  }
  function astAssign2(ast, s, e, c, val) {
    switch (ast.$kind) {
      case ekAccessScope2: {
        if (ast.name === "$host") {
          throw createMappedError$1(
            106
            /* ErrorNames.ast_no_assign_$host */
          );
        }
        const obj = getContext(s, ast.name, ast.ancestor);
        return obj[ast.name] = val;
      }
      case ekAccessMember2: {
        const obj = astEvaluate2(ast.object, s, e, c);
        if (obj == null) {
          if (e?.strict) {
            throw createMappedError$1(116, ast.name);
          }
          astAssign2(ast.object, s, e, c, { [ast.name]: val });
        } else if (isObjectOrFunction(obj)) {
          if (ast.name === "length" && isArray(obj) && !isNaN(val)) {
            obj.splice(val);
          } else {
            obj[ast.name] = val;
          }
        } else ;
        return val;
      }
      case ekAccessKeyed2: {
        const instance = astEvaluate2(ast.object, s, e, c);
        const key = astEvaluate2(ast.key, s, e, c);
        if (instance == null) {
          if (e?.strict) {
            throw createMappedError$1(116, key);
          }
          astAssign2(ast.object, s, e, c, { [key]: val });
          return val;
        }
        if (isArray(instance)) {
          if (key === "length" && !isNaN(val)) {
            instance.splice(val);
            return val;
          }
          if (isArrayIndex(key)) {
            instance.splice(key, 1, val);
            return val;
          }
        }
        return instance[key] = val;
      }
      case ekAssign2:
        astAssign2(ast.value, s, e, c, val);
        return astAssign2(ast.target, s, e, c, val);
      case ekValueConverter2: {
        val = e?.useConverter?.(ast.name, "fromView", val, ast.args.map((a) => astEvaluate2(a, s, e, c)));
        return astAssign2(ast.expression, s, e, c, val);
      }
      case ekBindingBehavior2:
        return astAssign2(ast.expression, s, e, c, val);
      case ekArrayDestructuring2:
      case ekObjectDestructuring2: {
        const list = ast.list;
        const len = list.length;
        let i;
        let item;
        for (i = 0; i < len; i++) {
          item = list[i];
          switch (item.$kind) {
            case ekDestructuringAssignmentLeaf2:
              astAssign2(item, s, e, c, val);
              break;
            case ekArrayDestructuring2:
            case ekObjectDestructuring2: {
              if (typeof val !== "object" || val === null) {
                throw createMappedError$1(
                  112
                  /* ErrorNames.ast_destruct_null */
                );
              }
              let source = astEvaluate2(item.source, Scope.create(val), e, null);
              if (source === void 0 && item.initializer) {
                source = astEvaluate2(item.initializer, s, e, null);
              }
              astAssign2(item, s, e, c, source);
              break;
            }
          }
        }
        break;
      }
      case ekDestructuringAssignmentLeaf2: {
        if (ast instanceof DestructuringAssignmentSingleExpression) {
          if (val == null) {
            return;
          }
          if (typeof val !== "object") {
            throw createMappedError$1(
              112
              /* ErrorNames.ast_destruct_null */
            );
          }
          let source = astEvaluate2(ast.source, Scope.create(val), e, c);
          if (source === void 0 && ast.initializer) {
            source = astEvaluate2(ast.initializer, s, e, c);
          }
          astAssign2(ast.target, s, e, c, source);
        } else {
          if (val == null) {
            return;
          }
          if (typeof val !== "object") {
            throw createMappedError$1(
              112
              /* ErrorNames.ast_destruct_null */
            );
          }
          const indexOrProperties = ast.indexOrProperties;
          let restValue;
          if (isArrayIndex(indexOrProperties)) {
            if (!Array.isArray(val)) {
              throw createMappedError$1(
                112
                /* ErrorNames.ast_destruct_null */
              );
            }
            restValue = val.slice(indexOrProperties);
          } else {
            restValue = Object.entries(val).reduce((acc, [k, v]) => {
              if (!indexOrProperties.includes(k)) {
                acc[k] = v;
              }
              return acc;
            }, {});
          }
          astAssign2(ast.target, s, e, c, restValue);
        }
        break;
      }
      case ekCustom2:
        return ast.assign(s, e, val);
      default:
        return void 0;
    }
  }
  function astBind2(ast, s, b) {
    switch (ast.$kind) {
      case ekBindingBehavior2: {
        b.bindBehavior?.(ast.name, s, ast.args.map((a) => astEvaluate2(a, s, b, null)));
        astBind2(ast.expression, s, b);
        break;
      }
      case ekValueConverter2: {
        b.bindConverter?.(ast.name);
        astBind2(ast.expression, s, b);
        break;
      }
      case ekForOfStatement2: {
        astBind2(ast.iterable, s, b);
        break;
      }
      case ekCustom2: {
        ast.bind?.(s, b);
      }
    }
  }
  function astUnbind2(ast, s, b) {
    switch (ast.$kind) {
      case ekBindingBehavior2: {
        b.unbindBehavior?.(ast.name, s);
        astUnbind2(ast.expression, s, b);
        break;
      }
      case ekValueConverter2: {
        b.unbindConverter?.(ast.name);
        astUnbind2(ast.expression, s, b);
        break;
      }
      case ekForOfStatement2: {
        astUnbind2(ast.iterable, s, b);
        break;
      }
      case ekCustom2: {
        ast.unbind?.(s, b);
      }
    }
  }
  const autoObserveArrayMethods = "at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort".split(" ");
  return {
    astEvaluate: astEvaluate2,
    astAssign: astAssign2,
    astBind: astBind2,
    astUnbind: astUnbind2
  };
})();
const mixinNoopAstEvaluator = /* @__PURE__ */ (() => (target) => {
  const proto = target.prototype;
  ["bindBehavior", "unbindBehavior", "bindConverter", "unbindConverter", "useConverter"].forEach((name2) => {
    rtDefineHiddenProp(proto, name2, () => {
      throw createMappedError$1(99, name2);
    });
  });
})();
const tsPending$2 = "pending";
const tsRunning$2 = "running";
const tsCompleted$1 = "completed";
const tsCanceled$1 = "canceled";
const resolvedPromise = Promise.resolve();
let runScheduled = false;
let isAutoRun = false;
const queue = [];
let pendingAsyncCount = 0;
let settlePromise = null;
let taskErrors = [];
let settlePromiseResolve = null;
let settlePromiseReject = null;
const requestRun = () => {
  if (!runScheduled) {
    runScheduled = true;
    void resolvedPromise.then(() => {
      runScheduled = false;
      isAutoRun = true;
      runTasks();
    });
  }
};
const signalSettled = (hasPerformedWork) => {
  if (settlePromise && queue.length === 0 && pendingAsyncCount === 0) {
    settlePromise = null;
    if (taskErrors.length > 0) {
      const errors = taskErrors;
      taskErrors = [];
      if (errors.length === 1) {
        settlePromiseReject(errors[0]);
      } else {
        settlePromiseReject(new AggregateError(errors, "One or more tasks failed."));
      }
    } else {
      settlePromiseResolve(hasPerformedWork);
    }
  }
};
const runTasks = () => {
  const isManualRun = !isAutoRun;
  isAutoRun = false;
  settlePromise ??= new Promise((resolve2, reject) => {
    settlePromiseResolve = resolve2;
    settlePromiseReject = reject;
  });
  let extraTaskCount = -queue.length;
  const isEmpty = queue.length === 0;
  while (queue.length > 0) {
    if (++extraTaskCount > 1e4) {
      const error2 = new Error(`Potential deadlock detected. More than 10000 extra tasks were queued from within tasks.`);
      queue.length = 0;
      settlePromiseReject?.(error2);
      settlePromise = null;
      throw error2;
    }
    const task = queue.shift();
    if (typeof task === "function") {
      try {
        task();
      } catch (err) {
        taskErrors.push(err);
      }
    } else {
      task.run();
    }
  }
  const errors = taskErrors.slice();
  signalSettled(!isEmpty);
  if (isManualRun && errors.length > 0) {
    if (errors.length === 1) {
      throw errors[0];
    } else {
      throw new AggregateError(errors, "One or more tasks failed.");
    }
  }
};
const tasksSettled = () => {
  if (settlePromise) {
    return settlePromise;
  }
  if (queue.length > 0 || pendingAsyncCount > 0) {
    return settlePromise ??= new Promise((resolve2, reject) => {
      settlePromiseResolve = resolve2;
      settlePromiseReject = reject;
    });
  }
  return resolvedPromise.then(() => {
    if (queue.length > 0 || pendingAsyncCount > 0) {
      return settlePromise ??= new Promise((resolve2, reject) => {
        settlePromiseResolve = resolve2;
        settlePromiseReject = reject;
      });
    }
    return false;
  });
};
const queueTask = (callback) => {
  requestRun();
  queue.push(callback);
};
const queueAsyncTask = (callback, options) => {
  const task = new Task$1(callback, options?.delay);
  if (task.delay != null && task.delay > 0) {
    ++pendingAsyncCount;
    task._timerId = setTimeout(() => {
      --pendingAsyncCount;
      task._timerId = void 0;
      if (task.status === tsCanceled$1) {
        signalSettled(true);
        return;
      }
      queue.push(task);
      requestRun();
    }, task.delay);
  } else {
    queue.push(task);
    requestRun();
  }
  return task;
};
let TaskAbortError$1 = class TaskAbortError extends Error {
  constructor(task) {
    super(`Task ${task.id} was canceled.`);
    this.task = task;
  }
};
let Task$1 = class Task {
  /**
   * A promise that:
   * * **fulfils** with the callback's return value, or
   * * **rejects** with:
   *   * whatever error the callback throws,
   *   * whatever rejection the callback's promise yields, or
   *   * a {@link TaskAbortError} if the task is canceled before it starts.
   *
   * Consumers typically `await` this to know when *their* task is done without
   * caring about unrelated work still queued.
   *
   * @example
   * ```ts
   * const toastTask = queueAsyncTask(showToast, { delay: 5000 });
   * await toastTask.result; // waits 5 s then resolves
   * ```
   */
  get result() {
    return this._result;
  }
  /**
   * Current immutable status of the task.
   *
   * @example
   * ```ts
   * const task = queueAsyncTask(() => 123);
   * console.log(task.status); // "pending"
   * await task.result;
   * console.log(task.status); // "completed"
   * ```
   */
  get status() {
    return this._status;
  }
  constructor(callback, delay) {
    this.callback = callback;
    this.delay = delay;
    this.id = ++Task._taskId;
    this._status = tsPending$2;
    this._result = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
    });
  }
  /** @internal */
  run() {
    if (this._status !== tsPending$2) {
      throw new Error(`Cannot run task in ${this._status} state`);
    }
    this._status = tsRunning$2;
    let ret;
    try {
      ret = this.callback();
    } catch (err) {
      this._status = tsCanceled$1;
      this._reject(err);
      taskErrors.push(err);
      return;
    }
    if (ret instanceof Promise) {
      ++pendingAsyncCount;
      ret.then((result) => {
        this._status = tsCompleted$1;
        this._resolve(result);
      }).catch((err) => {
        this._status = tsCanceled$1;
        this._reject(err);
        taskErrors.push(err);
      }).finally(() => {
        --pendingAsyncCount;
        signalSettled(true);
      });
    } else {
      this._status = tsCompleted$1;
      this._resolve(ret);
    }
  }
  /**
   * Attempt to cancel the task **before it runs**.
   *
   * * If the task is still `"pending"` **and**:
   *   * waiting in a `setTimeout`  the timer is cleared.
   *   * sitting in the queue      it is removed.
   *   The task transitions to `"canceled"` and `result` rejects with
   *   {@link TaskAbortError}.
   * * If the task is already `"running"` or `"completed"` nothing happens.
   *
   * @returns `true` when the task was successfully canceled,
   *          otherwise `false`.
   *
   * @example
   * ```ts
   * const t = queueAsyncTask(fetchData, { delay: 300 });
   * // user typed again before the debounce expired
   * if (t.cancel()) console.log('Previous fetch aborted');
   * ```
   */
  cancel() {
    if (this._timerId !== void 0) {
      clearTimeout(this._timerId);
      --pendingAsyncCount;
      this._timerId = void 0;
      this._status = tsCanceled$1;
      const abortErr = new TaskAbortError$1(this);
      this._reject(abortErr);
      void this._result.catch(noop);
      signalSettled(true);
      return true;
    }
    if (this._status === tsPending$2) {
      const idx = queue.indexOf(this);
      if (idx > -1) {
        queue.splice(idx, 1);
        this._status = tsCanceled$1;
        const abortErr = new TaskAbortError$1(this);
        this._reject(abortErr);
        void this._result.catch(noop);
        signalSettled(true);
        return true;
      }
    }
    return false;
  }
};
Task$1._taskId = 0;
const queueRecurringTask = (callback, opts) => {
  const task = new RecurringTask(callback, Math.max(opts?.interval, 0));
  task._start();
  return task;
};
class RecurringTask {
  constructor(_callback, _interval) {
    this._callback = _callback;
    this._interval = _interval;
    this.id = ++RecurringTask._nextId;
    this._canceled = false;
    this._nextResolvers = [];
  }
  /** @internal */
  run() {
    try {
      this._callback();
    } catch (err) {
      taskErrors.push(err);
      return;
    }
  }
  /** @internal */
  _start() {
    if (this._canceled) {
      return;
    }
    this._timerId = setTimeout(() => {
      this._tick();
      if (!this._canceled) {
        this._start();
      }
    }, this._interval);
  }
  /** @internal */
  _tick() {
    queue.push(this);
    requestRun();
    const resolvers = this._nextResolvers.splice(0);
    for (const resolver of resolvers) {
      resolver();
    }
  }
  /**
   * Returns a promise that resolves after the next time the task's callback
   * is queued for execution.
   *
   * This is useful for synchronizing other work with the task's interval,
   * especially in tests. If the task has already been canceled, it returns an
   * immediately-resolved promise.
   *
   * @returns A promise that resolves when the next interval occurs.
   *
   * @example
   * Synchronizing with a polling task in a test
   * ```ts
   * it('updates data on a polling interval', async () => {
   *   let count = 0;
   *   const poller = queueRecurringTask(() => count++, { interval: 100 });
   *
   *   await poller.next();
   *   await tasksSettled();
   *   expect(count).toBe(1);
   *
   *   await poller.next();
   *   await tasksSettled();
   *   expect(count).toBe(2);
   *
   *   poller.cancel();
   * });
   * ```
   */
  next() {
    if (this._canceled) {
      return Promise.resolve();
    }
    return new Promise((resolve2) => this._nextResolvers.push(resolve2));
  }
  /**
   * Permanently stops the recurring task.
   *
   * This action clears any pending timer, prevents future executions, removes
   * the task from the scheduler's list of recurring tasks, and immediately
   * resolves any pending promises created by `next()`.
   *
   * Once canceled, a recurring task cannot be restarted.
   */
  cancel() {
    this._canceled = true;
    if (this._timerId !== void 0) {
      clearTimeout(this._timerId);
      this._timerId = void 0;
    }
    const resolvers = this._nextResolvers.splice(0);
    for (const resolve2 of resolvers) {
      resolve2();
    }
  }
}
RecurringTask._nextId = 0;
const ICoercionConfiguration = /* @__PURE__ */ DI.createInterface("ICoercionConfiguration");
const atNone = 0;
const atObserver$1 = 1;
const atNode$1 = 2;
const atLayout$1 = 4;
const AccessorType = /* @__PURE__ */ rtObjectFreeze({
  None: atNone,
  Observer: atObserver$1,
  Node: atNode$1,
  // misc characteristic of accessors/observers when update
  //
  // by default, everything is synchronous
  // except changes that are supposed to cause reflow/heavy computation
  // an observer can use this flag to signal binding that don't carelessly tell it to update
  // queue it instead
  // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
  // todo: https://csstriggers.com/
  Layout: atLayout$1
});
function createIndexMap(length = 0) {
  const arr = Array(length);
  let i = 0;
  while (i < length) {
    arr[i] = i++;
  }
  arr.deletedIndices = [];
  arr.deletedItems = [];
  arr.isIndexMap = true;
  return arr;
}
let batching = false;
const subscriberCollection = /* @__PURE__ */ (() => {
  function subscriberCollection2(target, context) {
    return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target);
  }
  function getSubscriberRecord() {
    return rtDefineHiddenProp(this, "subs", new SubscriberRecord());
  }
  function addSubscriber(subscriber) {
    return this.subs.add(subscriber);
  }
  function removeSubscriber(subscriber) {
    return this.subs.remove(subscriber);
  }
  const decoratedTarget = /* @__PURE__ */ new WeakSet();
  function subscriberCollectionDeco(target, context) {
    if (!decoratedTarget.has(target)) {
      decoratedTarget.add(target);
      const proto = target.prototype;
      rtDef(proto, "subs", { get: getSubscriberRecord });
      ensureProto(proto, "subscribe", addSubscriber);
      ensureProto(proto, "unsubscribe", removeSubscriber);
    }
    return target;
  }
  class SubscriberRecord {
    constructor() {
      this.count = 0;
      this._subs = [];
      this._requestDirtySubs = [];
      this._hasDirtySubs = false;
    }
    add(subscriber) {
      if (this._subs.includes(subscriber)) {
        return false;
      }
      this._subs[this._subs.length] = subscriber;
      if ("handleDirty" in subscriber) {
        this._requestDirtySubs[this._requestDirtySubs.length] = subscriber;
        this._hasDirtySubs = true;
      }
      ++this.count;
      return true;
    }
    remove(subscriber) {
      let idx = this._subs.indexOf(subscriber);
      if (idx !== -1) {
        this._subs.splice(idx, 1);
        idx = this._requestDirtySubs.indexOf(subscriber);
        if (idx !== -1) {
          this._requestDirtySubs.splice(idx, 1);
          this._hasDirtySubs = this._requestDirtySubs.length > 0;
        }
        --this.count;
        return true;
      }
      return false;
    }
    notify(val, oldVal) {
      for (const sub of this._subs.slice(0)) {
        sub.handleChange(val, oldVal);
      }
    }
    notifyCollection(collection, indexMap) {
      const _subs = this._subs.slice(0);
      const len = _subs.length;
      let i = 0;
      for (; i < len; ++i) {
        _subs[i].handleCollectionChange(collection, indexMap);
      }
      return;
    }
    notifyDirty() {
      if (this._hasDirtySubs) {
        for (const dirtySub of this._requestDirtySubs.slice(0)) {
          dirtySub.handleDirty();
        }
      }
    }
  }
  return subscriberCollection2;
})();
class CollectionLengthObserver {
  constructor(owner) {
    this.owner = owner;
    this.type = atObserver$1;
    this._value = (this._obj = owner.collection).length;
  }
  getValue() {
    return this._obj.length;
  }
  setValue(newValue) {
    if (newValue !== this._value) {
      if (!Number.isNaN(newValue)) {
        this._obj.splice(newValue);
        this._value = this._obj.length;
      } else {
        console.warn(`Invalid value "${newValue}" for array length`);
      }
    }
  }
  handleDirty() {
    if (this._value !== this._obj.length) {
      this.subs.notifyDirty();
    }
  }
  handleCollectionChange(_arr, _) {
    const oldValue = this._value;
    const value = this._obj.length;
    if ((this._value = value) !== oldValue) {
      this.subs.notifyDirty();
      this.subs.notify(this._value, oldValue);
    }
  }
}
(() => {
  implementLengthObserver(CollectionLengthObserver);
})();
class CollectionSizeObserver {
  constructor(owner) {
    this.owner = owner;
    this.type = atObserver$1;
    this._value = (this._obj = owner.collection).size;
  }
  getValue() {
    return this._obj.size;
  }
  setValue() {
    throw createMappedError$1(
      220
      /* ErrorNames.assign_readonly_size */
    );
  }
  handleDirty() {
    if (this._value !== this._obj.size) {
      this.subs.notifyDirty();
    }
  }
  handleCollectionChange(_collection, _) {
    const oldValue = this._value;
    const value = this._obj.size;
    if ((this._value = value) !== oldValue) {
      this.subs.notify(this._value, oldValue);
    }
  }
}
(() => {
  implementLengthObserver(CollectionSizeObserver);
})();
function implementLengthObserver(klass) {
  const proto = klass.prototype;
  ensureProto(proto, "subscribe", subscribe);
  ensureProto(proto, "unsubscribe", unsubscribe);
  return subscriberCollection(klass, null);
}
function subscribe(subscriber) {
  if (this.subs.add(subscriber) && this.subs.count === 1) {
    this.owner.subscribe(this);
  }
}
function unsubscribe(subscriber) {
  if (this.subs.remove(subscriber) && this.subs.count === 0) {
    this.owner.subscribe(this);
  }
}
const getArrayObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_arr_obs__");
  const observerLookup = Array[lookupMetadataKey] ?? rtDefineHiddenProp(Array, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  function sortCompare(x, y3) {
    if (x === y3) {
      return 0;
    }
    x = x === null ? "null" : x.toString();
    y3 = y3 === null ? "null" : y3.toString();
    return x < y3 ? -1 : 1;
  }
  function preSortCompare(x, y3) {
    if (x === void 0) {
      if (y3 === void 0) {
        return 0;
      } else {
        return 1;
      }
    }
    if (y3 === void 0) {
      return -1;
    }
    return 0;
  }
  function insertionSort(arr, indexMap, from, to, compareFn) {
    let velement, ielement, vtmp, itmp, order2;
    let i, j;
    for (i = from + 1; i < to; i++) {
      velement = arr[i];
      ielement = indexMap[i];
      for (j = i - 1; j >= from; j--) {
        vtmp = arr[j];
        itmp = indexMap[j];
        order2 = compareFn(vtmp, velement);
        if (order2 > 0) {
          arr[j + 1] = vtmp;
          indexMap[j + 1] = itmp;
        } else {
          break;
        }
      }
      arr[j + 1] = velement;
      indexMap[j + 1] = ielement;
    }
  }
  function quickSort(arr, indexMap, from, to, compareFn) {
    let thirdIndex = 0, i = 0;
    let v0, v1, v2;
    let i0, i1, i2;
    let c01, c02, c12;
    let vtmp, itmp;
    let vpivot, ipivot, lowEnd, highStart;
    let velement, ielement, order2, vtopElement;
    while (true) {
      if (to - from <= 10) {
        insertionSort(arr, indexMap, from, to, compareFn);
        return;
      }
      thirdIndex = from + (to - from >> 1);
      v0 = arr[from];
      i0 = indexMap[from];
      v1 = arr[to - 1];
      i1 = indexMap[to - 1];
      v2 = arr[thirdIndex];
      i2 = indexMap[thirdIndex];
      c01 = compareFn(v0, v1);
      if (c01 > 0) {
        vtmp = v0;
        itmp = i0;
        v0 = v1;
        i0 = i1;
        v1 = vtmp;
        i1 = itmp;
      }
      c02 = compareFn(v0, v2);
      if (c02 >= 0) {
        vtmp = v0;
        itmp = i0;
        v0 = v2;
        i0 = i2;
        v2 = v1;
        i2 = i1;
        v1 = vtmp;
        i1 = itmp;
      } else {
        c12 = compareFn(v1, v2);
        if (c12 > 0) {
          vtmp = v1;
          itmp = i1;
          v1 = v2;
          i1 = i2;
          v2 = vtmp;
          i2 = itmp;
        }
      }
      arr[from] = v0;
      indexMap[from] = i0;
      arr[to - 1] = v2;
      indexMap[to - 1] = i2;
      vpivot = v1;
      ipivot = i1;
      lowEnd = from + 1;
      highStart = to - 1;
      arr[thirdIndex] = arr[lowEnd];
      indexMap[thirdIndex] = indexMap[lowEnd];
      arr[lowEnd] = vpivot;
      indexMap[lowEnd] = ipivot;
      partition: for (i = lowEnd + 1; i < highStart; i++) {
        velement = arr[i];
        ielement = indexMap[i];
        order2 = compareFn(velement, vpivot);
        if (order2 < 0) {
          arr[i] = arr[lowEnd];
          indexMap[i] = indexMap[lowEnd];
          arr[lowEnd] = velement;
          indexMap[lowEnd] = ielement;
          lowEnd++;
        } else if (order2 > 0) {
          do {
            highStart--;
            if (highStart == i) {
              break partition;
            }
            vtopElement = arr[highStart];
            order2 = compareFn(vtopElement, vpivot);
          } while (order2 > 0);
          arr[i] = arr[highStart];
          indexMap[i] = indexMap[highStart];
          arr[highStart] = velement;
          indexMap[highStart] = ielement;
          if (order2 < 0) {
            velement = arr[i];
            ielement = indexMap[i];
            arr[i] = arr[lowEnd];
            indexMap[i] = indexMap[lowEnd];
            arr[lowEnd] = velement;
            indexMap[lowEnd] = ielement;
            lowEnd++;
          }
        }
      }
      if (to - highStart < lowEnd - from) {
        quickSort(arr, indexMap, highStart, to, compareFn);
        to = lowEnd;
      } else {
        quickSort(arr, indexMap, from, lowEnd, compareFn);
        from = highStart;
      }
    }
  }
  const proto = Array.prototype;
  const methods = ["push", "unshift", "pop", "shift", "splice", "reverse", "sort"];
  let observe;
  function overrideArrayPrototypes() {
    const $push = proto.push;
    const $unshift = proto.unshift;
    const $pop = proto.pop;
    const $shift = proto.shift;
    const $splice = proto.splice;
    const $reverse = proto.reverse;
    const $sort = proto.sort;
    observe = {
      // https://tc39.github.io/ecma262/#sec-array.prototype.push
      push: function(...args) {
        const o = observerLookup.get(this);
        if (o === void 0) {
          return $push.apply(this, args);
        }
        const len = this.length;
        const argCount = args.length;
        if (argCount === 0) {
          return len;
        }
        this.length = o.indexMap.length = len + argCount;
        let i = len;
        while (i < this.length) {
          this[i] = args[i - len];
          o.indexMap[i] = -2;
          i++;
        }
        o.notify();
        return this.length;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.unshift
      unshift: function(...args) {
        const o = observerLookup.get(this);
        if (o === void 0) {
          return $unshift.apply(this, args);
        }
        const argCount = args.length;
        const inserts = new Array(argCount);
        let i = 0;
        while (i < argCount) {
          inserts[i++] = -2;
        }
        $unshift.apply(o.indexMap, inserts);
        const len = $unshift.apply(this, args);
        o.notify();
        return len;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.pop
      pop: function() {
        const o = observerLookup.get(this);
        if (o === void 0) {
          return $pop.call(this);
        }
        const indexMap = o.indexMap;
        const element = $pop.call(this);
        const index = indexMap.length - 1;
        if (indexMap[index] > -1) {
          indexMap.deletedIndices.push(indexMap[index]);
          indexMap.deletedItems.push(element);
        }
        $pop.call(indexMap);
        o.notify();
        return element;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.shift
      shift: function() {
        const o = observerLookup.get(this);
        if (o === void 0) {
          return $shift.call(this);
        }
        const indexMap = o.indexMap;
        const element = $shift.call(this);
        if (indexMap[0] > -1) {
          indexMap.deletedIndices.push(indexMap[0]);
          indexMap.deletedItems.push(element);
        }
        $shift.call(indexMap);
        o.notify();
        return element;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.splice
      splice: function(...args) {
        const start2 = args[0];
        const deleteCount = args[1];
        const o = observerLookup.get(this);
        if (o === void 0) {
          return $splice.apply(this, args);
        }
        const len = this.length;
        const relativeStart = start2 | 0;
        const actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        const indexMap = o.indexMap;
        const argCount = args.length;
        const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;
        let i = actualStart;
        if (actualDeleteCount > 0) {
          const to = i + actualDeleteCount;
          while (i < to) {
            if (indexMap[i] > -1) {
              indexMap.deletedIndices.push(indexMap[i]);
              indexMap.deletedItems.push(this[i]);
            }
            i++;
          }
        }
        i = 0;
        if (argCount > 2) {
          const itemCount = argCount - 2;
          const inserts = new Array(itemCount);
          while (i < itemCount) {
            inserts[i++] = -2;
          }
          $splice.call(indexMap, start2, deleteCount, ...inserts);
        } else {
          $splice.apply(indexMap, args);
        }
        const deleted = $splice.apply(this, args);
        if (actualDeleteCount > 0 || i > 0) {
          o.notify();
        }
        return deleted;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
      reverse: function() {
        const o = observerLookup.get(this);
        if (o === void 0) {
          $reverse.call(this);
          return this;
        }
        const len = this.length;
        const middle = len / 2 | 0;
        let lower = 0;
        while (lower !== middle) {
          const upper = len - lower - 1;
          const lowerValue = this[lower];
          const lowerIndex = o.indexMap[lower];
          const upperValue = this[upper];
          const upperIndex = o.indexMap[upper];
          this[lower] = upperValue;
          o.indexMap[lower] = upperIndex;
          this[upper] = lowerValue;
          o.indexMap[upper] = lowerIndex;
          lower++;
        }
        o.notify();
        return this;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.sort
      // https://github.com/v8/v8/blob/master/src/js/array.js
      sort: function(compareFn) {
        const o = observerLookup.get(this);
        if (o === void 0) {
          $sort.call(this, compareFn);
          return this;
        }
        let len = this.length;
        if (len < 2) {
          return this;
        }
        quickSort(this, o.indexMap, 0, len, preSortCompare);
        let i = 0;
        while (i < len) {
          if (this[i] === void 0) {
            break;
          }
          i++;
        }
        if (compareFn === void 0 || !isFunction(compareFn)) {
          compareFn = sortCompare;
        }
        quickSort(this, o.indexMap, 0, i, compareFn);
        let shouldNotify = false;
        for (i = 0, len = o.indexMap.length; len > i; ++i) {
          if (o.indexMap[i] !== i) {
            shouldNotify = true;
            break;
          }
        }
        if (shouldNotify || batching) {
          o.notify();
        }
        return this;
      }
    };
    for (const method of methods) {
      rtDef(observe[method], "observing", { value: true });
    }
  }
  let enableArrayObservationCalled = false;
  const observationEnabledKey = "__au_arr_on__";
  function enableArrayObservation() {
    if (observe === void 0) {
      overrideArrayPrototypes();
    }
    if (!(rtGetMetadata(observationEnabledKey, Array) ?? false)) {
      rtDefineMetadata(true, Array, observationEnabledKey);
      for (const method of methods) {
        if (proto[method].observing !== true) {
          rtDefineHiddenProp(proto, method, observe[method]);
        }
      }
    }
  }
  class ArrayObserverImpl {
    constructor(array) {
      this.type = atObserver$1;
      if (!enableArrayObservationCalled) {
        enableArrayObservationCalled = true;
        enableArrayObservation();
      }
      this.indexObservers = {};
      this.collection = array;
      this.indexMap = createIndexMap(array.length);
      this.lenObs = void 0;
      observerLookup.set(array, this);
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const arr = this.collection;
      const length = arr.length;
      this.indexMap = createIndexMap(length);
      subs.notifyCollection(arr, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionLengthObserver(this);
    }
    getIndexObserver(index) {
      return this.indexObservers[index] ??= new ArrayIndexObserverImpl(this, index);
    }
  }
  (() => {
    subscriberCollection(ArrayObserverImpl, null);
  })();
  class ArrayIndexObserverImpl {
    constructor(owner, index) {
      this.owner = owner;
      this.index = index;
      this.doNotCache = true;
      this.value = this.getValue();
    }
    getValue() {
      return this.owner.collection[this.index];
    }
    setValue(newValue) {
      if (newValue === this.getValue()) {
        return;
      }
      const arrayObserver = this.owner;
      const index = this.index;
      const indexMap = arrayObserver.indexMap;
      if (indexMap[index] > -1) {
        indexMap.deletedIndices.push(indexMap[index]);
      }
      indexMap[index] = -2;
      arrayObserver.collection[index] = newValue;
      arrayObserver.notify();
    }
    handleDirty() {
      if (this.value !== this.getValue()) {
        this.subs.notifyDirty();
      }
    }
    /**
     * From interface `ICollectionSubscriber`
     */
    handleCollectionChange(_arr, indexMap) {
      const index = this.index;
      const noChange = indexMap[index] === index;
      if (noChange) {
        return;
      }
      const prevValue = this.value;
      const currValue = this.value = this.getValue();
      if (prevValue !== currValue) {
        this.subs.notify(currValue, prevValue);
      }
    }
    subscribe(subscriber) {
      if (this.subs.add(subscriber) && this.subs.count === 1) {
        this.owner.subscribe(this);
      }
    }
    unsubscribe(subscriber) {
      if (this.subs.remove(subscriber) && this.subs.count === 0) {
        this.owner.unsubscribe(this);
      }
    }
  }
  (() => {
    subscriberCollection(ArrayIndexObserverImpl, null);
  })();
  return function getArrayObserver2(array) {
    let observer = observerLookup.get(array);
    if (observer === void 0) {
      observerLookup.set(array, observer = new ArrayObserverImpl(array));
      enableArrayObservation();
    }
    return observer;
  };
})();
const getSetObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_set_obs__");
  const observerLookup = Set[lookupMetadataKey] ?? rtDefineHiddenProp(Set, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  const { add: $add, clear: $clear, delete: $delete } = Set.prototype;
  const methods = ["add", "clear", "delete"];
  const observe = {
    // https://tc39.github.io/ecma262/#sec-set.prototype.add
    add: function(value) {
      const o = observerLookup.get(this);
      if (o === void 0) {
        $add.call(this, value);
        return this;
      }
      const oldSize = this.size;
      $add.call(this, value);
      const newSize = this.size;
      if (newSize === oldSize) {
        return this;
      }
      o.indexMap[oldSize] = -2;
      o.notify();
      return this;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.clear
    clear: function() {
      const o = observerLookup.get(this);
      if (o === void 0) {
        return $clear.call(this);
      }
      const size = this.size;
      if (size > 0) {
        const indexMap = o.indexMap;
        let i = 0;
        for (const key of this.keys()) {
          if (indexMap[i] > -1) {
            indexMap.deletedIndices.push(indexMap[i]);
            indexMap.deletedItems.push(key);
          }
          i++;
        }
        $clear.call(this);
        indexMap.length = 0;
        o.notify();
      }
      return void 0;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.delete
    delete: function(value) {
      const o = observerLookup.get(this);
      if (o === void 0) {
        return $delete.call(this, value);
      }
      const size = this.size;
      if (size === 0) {
        return false;
      }
      let i = 0;
      const indexMap = o.indexMap;
      for (const entry of this.keys()) {
        if (entry === value) {
          if (indexMap[i] > -1) {
            indexMap.deletedIndices.push(indexMap[i]);
            indexMap.deletedItems.push(entry);
          }
          indexMap.splice(i, 1);
          const deleteResult = $delete.call(this, value);
          if (deleteResult === true) {
            o.notify();
          }
          return deleteResult;
        }
        i++;
      }
      return false;
    }
  };
  function enableSetObservation(set) {
    for (const method of methods) {
      rtDefineHiddenProp(set, method, observe[method]);
    }
  }
  class SetObserverImpl {
    constructor(observedSet) {
      this.type = atObserver$1;
      this.collection = observedSet;
      this.indexMap = createIndexMap(observedSet.size);
      this.lenObs = void 0;
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const set = this.collection;
      const size = set.size;
      this.indexMap = createIndexMap(size);
      subs.notifyCollection(set, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionSizeObserver(this);
    }
  }
  subscriberCollection(SetObserverImpl, null);
  return function getSetObserver2(set) {
    let observer = observerLookup.get(set);
    if (observer === void 0) {
      observerLookup.set(set, observer = new SetObserverImpl(set));
      enableSetObservation(set);
    }
    return observer;
  };
})();
const getMapObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_map_obs__");
  const observerLookup = Map[lookupMetadataKey] ?? rtDefineHiddenProp(Map, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  const { set: $set, clear: $clear, delete: $delete } = Map.prototype;
  const methods = ["set", "clear", "delete"];
  const observe = {
    // https://tc39.github.io/ecma262/#sec-map.prototype.map
    set: function(key, value) {
      const o = observerLookup.get(this);
      if (o === void 0) {
        $set.call(this, key, value);
        return this;
      }
      const oldValue = this.get(key);
      const oldSize = this.size;
      $set.call(this, key, value);
      const newSize = this.size;
      if (newSize === oldSize) {
        let i = 0;
        for (const entry of this.entries()) {
          if (entry[0] === key) {
            if (entry[1] !== oldValue) {
              o.indexMap.deletedIndices.push(o.indexMap[i]);
              o.indexMap.deletedItems.push(entry);
              o.indexMap[i] = -2;
              o.notify();
            }
            return this;
          }
          i++;
        }
        return this;
      }
      o.indexMap[oldSize] = -2;
      o.notify();
      return this;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.clear
    clear: function() {
      const o = observerLookup.get(this);
      if (o === void 0) {
        return $clear.call(this);
      }
      const size = this.size;
      if (size > 0) {
        const indexMap = o.indexMap;
        let i = 0;
        for (const key of this.keys()) {
          if (indexMap[i] > -1) {
            indexMap.deletedIndices.push(indexMap[i]);
            indexMap.deletedItems.push(key);
          }
          i++;
        }
        $clear.call(this);
        indexMap.length = 0;
        o.notify();
      }
      return void 0;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.delete
    delete: function(value) {
      const o = observerLookup.get(this);
      if (o === void 0) {
        return $delete.call(this, value);
      }
      const size = this.size;
      if (size === 0) {
        return false;
      }
      let i = 0;
      const indexMap = o.indexMap;
      for (const entry of this.keys()) {
        if (entry === value) {
          if (indexMap[i] > -1) {
            indexMap.deletedIndices.push(indexMap[i]);
            indexMap.deletedItems.push(entry);
          }
          indexMap.splice(i, 1);
          const deleteResult = $delete.call(this, value);
          if (deleteResult === true) {
            o.notify();
          }
          return deleteResult;
        }
        ++i;
      }
      return false;
    }
  };
  function enableMapObservation(map) {
    for (const method of methods) {
      rtDefineHiddenProp(map, method, observe[method]);
    }
  }
  class MapObserverImpl {
    constructor(map) {
      this.type = atObserver$1;
      this.collection = map;
      this.indexMap = createIndexMap(map.size);
      this.lenObs = void 0;
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const map = this.collection;
      const size = map.size;
      this.indexMap = createIndexMap(size);
      subs.notifyCollection(map, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionSizeObserver(this);
    }
  }
  subscriberCollection(MapObserverImpl, null);
  return function getMapObserver2(map) {
    let observer = observerLookup.get(map);
    if (observer === void 0) {
      observerLookup.set(map, observer = new MapObserverImpl(map));
      enableMapObservation(map);
    }
    return observer;
  };
})();
const connectableDecorator = /* @__PURE__ */ (() => {
  class BindingObserverRecord {
    constructor(b) {
      this.version = 0;
      this.count = 0;
      this.o = /* @__PURE__ */ new Map();
      this.b = b;
    }
    /**
     * Add, and subscribe to a given observer
     */
    add(observer) {
      if (!this.o.has(observer)) {
        observer.subscribe(this.b);
        ++this.count;
      }
      this.o.set(observer, this.version);
    }
    /**
     * Unsubscribe the observers that are not up to date with the record version
     */
    clear() {
      this.o.forEach(unsubscribeStale, this);
      this.count = this.o.size;
    }
    clearAll() {
      this.o.forEach(unsubscribeAll, this);
      this.o.clear();
      this.count = 0;
    }
  }
  function unsubscribeAll(version, subscribable) {
    subscribable.unsubscribe(this.b);
  }
  function unsubscribeStale(version, subscribable) {
    if (this.version !== version) {
      subscribable.unsubscribe(this.b);
      this.o.delete(subscribable);
    }
  }
  function getObserverRecord() {
    return rtDefineHiddenProp(this, "obs", new BindingObserverRecord(this));
  }
  function observe(obj, key) {
    this.obs.add(this.oL.getObserver(obj, key));
  }
  function observeCollection2(collection) {
    let observer;
    if (isArray(collection)) {
      observer = getArrayObserver(collection);
    } else if (isSet(collection)) {
      observer = getSetObserver(collection);
    } else if (isMap(collection)) {
      observer = getMapObserver(collection);
    } else {
      throw createMappedError$1(210, collection);
    }
    this.obs.add(observer);
  }
  function subscribeTo(subscribable) {
    this.obs.add(subscribable);
  }
  function noopHandleChange() {
    throw createMappedError$1(99, "handleChange");
  }
  function noopHandleCollectionChange() {
    throw createMappedError$1(99, "handleCollectionChange");
  }
  return function connectableDecorator2(target, context) {
    const proto = target.prototype;
    ensureProto(proto, "observe", observe);
    ensureProto(proto, "observeCollection", observeCollection2);
    ensureProto(proto, "subscribeTo", subscribeTo);
    rtDef(proto, "obs", { get: getObserverRecord });
    ensureProto(proto, "handleChange", noopHandleChange);
    ensureProto(proto, "handleCollectionChange", noopHandleCollectionChange);
    return target;
  };
})();
function connectable(target, context) {
  return target == null ? connectableDecorator : connectableDecorator(target, context);
}
let _connectable = null;
const connectables = [];
let connecting = false;
function pauseConnecting() {
  connecting = false;
}
function resumeConnecting() {
  connecting = true;
}
function currentConnectable() {
  return _connectable;
}
function enterConnectable(connectable2) {
  if (connectable2 == null) {
    throw createMappedError$1(
      206
      /* ErrorNames.switch_on_null_connectable */
    );
  }
  if (_connectable == null) {
    _connectable = connectable2;
    connectables[0] = _connectable;
    connecting = true;
    return;
  }
  if (_connectable === connectable2) {
    throw createMappedError$1(
      207
      /* ErrorNames.switch_active_connectable */
    );
  }
  connectables.push(connectable2);
  _connectable = connectable2;
  connecting = true;
}
function exitConnectable(connectable2) {
  if (connectable2 == null) {
    throw createMappedError$1(
      208
      /* ErrorNames.switch_off_null_connectable */
    );
  }
  if (_connectable !== connectable2) {
    throw createMappedError$1(
      209
      /* ErrorNames.switch_off_inactive_connectable */
    );
  }
  connectables.pop();
  _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;
  connecting = _connectable != null;
}
const ConnectableSwitcher = /* @__PURE__ */ rtObjectFreeze({
  get current() {
    return _connectable;
  },
  get connecting() {
    return connecting;
  },
  enter: enterConnectable,
  exit: exitConnectable,
  pause: pauseConnecting,
  resume: resumeConnecting
});
const R$get = Reflect.get;
const toStringTag = Object.prototype.toString;
const proxyMap = /* @__PURE__ */ new WeakMap();
const nowrapClassKey = "__au_nw__";
const nowrapPropKey = "__au_nw";
function canWrap(obj) {
  switch (toStringTag.call(obj)) {
    case "[object Object]":
      return obj.constructor[nowrapClassKey] !== true;
    case "[object Array]":
    case "[object Map]":
    case "[object Set]":
      return true;
    default:
      return false;
  }
}
const rawKey = "__raw__";
function wrap$1(v) {
  return canWrap(v) ? getProxy(v) : v;
}
function getProxy(obj) {
  return proxyMap.get(obj) ?? createProxy(obj);
}
function getRaw(obj) {
  return obj[rawKey] ?? obj;
}
function unwrap$1(v) {
  return canWrap(v) && v[rawKey] || v;
}
function doNotCollect(object, key) {
  if (key === "constructor" || key === "__proto__" || key === "$observers" || key === Symbol.toPrimitive || key === Symbol.toStringTag || object.constructor[`${nowrapPropKey}_${rtSafeString(key)}__`] === true) {
    return true;
  }
  const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
  return descriptor?.configurable === false && descriptor.writable === false;
}
function createProxy(obj) {
  const handler = isArray(obj) ? arrayHandler : isMap(obj) || isSet(obj) ? collectionHandler : objectHandler;
  const proxiedObj = new Proxy(obj, handler);
  proxyMap.set(obj, proxiedObj);
  proxyMap.set(proxiedObj, proxiedObj);
  return proxiedObj;
}
const objectHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    const connectable2 = currentConnectable();
    if (!connecting || doNotCollect(target, key) || connectable2 == null) {
      return R$get(target, key, receiver);
    }
    connectable2.observe(target, key);
    return wrap$1(R$get(target, key, receiver));
  },
  deleteProperty(target, p) {
    {
      console.warn(`[DEV:aurelia] deletion of a property will not always be working with Aurelia observation system, as it depends on getter/setter installation.`);
    }
    return delete target[p];
  }
};
const arrayHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    if (!connecting || doNotCollect(target, key) || _connectable == null) {
      return R$get(target, key, receiver);
    }
    switch (key) {
      case "length":
        _connectable.observe(target, "length");
        return target.length;
      case "map":
        return wrappedArrayMap;
      case "includes":
        return wrappedArrayIncludes;
      case "indexOf":
        return wrappedArrayIndexOf;
      case "lastIndexOf":
        return wrappedArrayLastIndexOf;
      case "every":
        return wrappedArrayEvery;
      case "filter":
        return wrappedArrayFilter;
      case "find":
        return wrappedArrayFind;
      case "findIndex":
        return wrappedArrayFindIndex;
      case "flat":
        return wrappedArrayFlat;
      case "flatMap":
        return wrappedArrayFlatMap;
      case "join":
        return wrappedArrayJoin;
      case "push":
        return wrappedArrayPush;
      case "pop":
        return wrappedArrayPop;
      case "reduce":
        return wrappedReduce;
      case "reduceRight":
        return wrappedReduceRight;
      case "reverse":
        return wrappedArrayReverse;
      case "shift":
        return wrappedArrayShift;
      case "unshift":
        return wrappedArrayUnshift;
      case "slice":
        return wrappedArraySlice;
      case "splice":
        return wrappedArraySplice;
      case "some":
        return wrappedArraySome;
      case "sort":
        return wrappedArraySort;
      case "keys":
        return wrappedKeys;
      case "values":
      case Symbol.iterator:
        return wrappedValues;
      case "entries":
        return wrappedEntries;
    }
    _connectable.observe(target, key);
    return wrap$1(R$get(target, key, receiver));
  },
  // for (let i in array) ...
  ownKeys(target) {
    currentConnectable()?.observe(target, "length");
    return Reflect.ownKeys(target);
  }
};
function wrappedArrayMap(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.map((v, i) => (
    // do we wrap `thisArg`?
    unwrap$1(cb.call(thisArg, wrap$1(v), i, this))
  ));
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayEvery(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.every((v, i) => cb.call(thisArg, wrap$1(v), i, this));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFilter(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.filter((v, i) => (
    // do we wrap `thisArg`?
    unwrap$1(cb.call(thisArg, wrap$1(v), i, this))
  ));
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayIncludes(v) {
  const raw = getRaw(this);
  const res = raw.includes(unwrap$1(v));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayIndexOf(v) {
  const raw = getRaw(this);
  const res = raw.indexOf(unwrap$1(v));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayLastIndexOf(v) {
  const raw = getRaw(this);
  const res = raw.lastIndexOf(unwrap$1(v));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFindIndex(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.findIndex((v, i) => unwrap$1(cb.call(thisArg, wrap$1(v), i, this)));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFind(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.find((v, i) => cb(wrap$1(v), i, this), thisArg);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayFlat() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return wrap$1(raw.flat());
}
function wrappedArrayFlatMap(cb, thisArg) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return getProxy(raw.flatMap((v, i) => wrap$1(cb.call(thisArg, wrap$1(v), i, this))));
}
function wrappedArrayJoin(separator) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.join(separator);
}
function wrappedArrayPop() {
  return wrap$1(getRaw(this).pop());
}
function wrappedArrayPush(...args) {
  return getRaw(this).push(...args);
}
function wrappedArrayShift() {
  return wrap$1(getRaw(this).shift());
}
function wrappedArrayUnshift(...args) {
  return getRaw(this).unshift(...args);
}
function wrappedArraySplice(...args) {
  return wrap$1(getRaw(this).splice(...args));
}
function wrappedArrayReverse(..._args) {
  return wrap$1(getRaw(this).reverse());
}
function wrappedArraySome(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.some((v, i) => unwrap$1(cb.call(thisArg, wrap$1(v), i, this)));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArraySort(cb) {
  const raw = getRaw(this);
  const res = raw.sort(cb);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArraySlice(start2, end2) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return getProxy(raw.slice(start2, end2));
}
function wrappedReduce(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduce((curr, v, i) => cb(curr, wrap$1(v), i, this), initValue);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedReduceRight(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduceRight((curr, v, i) => cb(curr, wrap$1(v), i, this), initValue);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
const collectionHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    const connectable2 = currentConnectable();
    if (!connecting || doNotCollect(target, key) || connectable2 == null) {
      return R$get(target, key, receiver);
    }
    switch (key) {
      case "size":
        connectable2.observe(target, "size");
        return target.size;
      case "clear":
        return wrappedClear;
      case "delete":
        return wrappedDelete;
      case "forEach":
        return wrappedForEach;
      case "add":
        if (isSet(target)) {
          return wrappedAdd;
        }
        break;
      case "get":
        if (isMap(target)) {
          return wrappedGet;
        }
        break;
      case "set":
        if (isMap(target)) {
          return wrappedSet;
        }
        break;
      case "has":
        return wrappedHas;
      case "keys":
        return wrappedKeys;
      case "values":
        return wrappedValues;
      case "entries":
        return wrappedEntries;
      case Symbol.iterator:
        return isMap(target) ? wrappedEntries : wrappedValues;
    }
    return wrap$1(R$get(target, key, receiver));
  }
};
function wrappedForEach(cb, thisArg) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.forEach((v, key) => {
    cb.call(
      /* should wrap or not?? */
      thisArg,
      wrap$1(v),
      wrap$1(key),
      this
    );
  });
}
function wrappedHas(v) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.has(unwrap$1(v));
}
function wrappedGet(k) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return wrap$1(raw.get(unwrap$1(k)));
}
function wrappedSet(k, v) {
  return wrap$1(getRaw(this).set(unwrap$1(k), unwrap$1(v)));
}
function wrappedAdd(v) {
  return wrap$1(getRaw(this).add(unwrap$1(v)));
}
function wrappedClear() {
  return wrap$1(getRaw(this).clear());
}
function wrappedDelete(k) {
  return wrap$1(getRaw(this).delete(unwrap$1(k)));
}
function wrappedKeys() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.keys();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: wrap$1(value), done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function wrappedValues() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.values();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: wrap$1(value), done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function wrappedEntries() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.entries();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: [wrap$1(value[0]), wrap$1(value[1])], done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
const observeCollection = (connectable2, collection) => connectable2?.observeCollection(collection);
const ProxyObservable = /* @__PURE__ */ rtObjectFreeze({
  getProxy,
  getRaw,
  wrap: wrap$1,
  unwrap: unwrap$1,
  rawKey
});
class ComputedObserver {
  constructor(obj, get, set, observerLocator, flush = "async") {
    this.type = atObserver$1;
    this._oldValue = void 0;
    this._value = void 0;
    this._notified = false;
    this._isQueued = false;
    this._isDirty = false;
    this._callback = void 0;
    this._coercer = void 0;
    this._coercionConfig = void 0;
    this._obj = obj;
    this._wrapped = wrap$1(obj);
    this.$get = get;
    this.$set = set;
    this.oL = observerLocator;
    this._flush = flush;
  }
  init(value) {
    this._value = value;
    this._isDirty = false;
  }
  getValue() {
    if (this.subs.count === 0) {
      return this.$get.call(this._obj, this._obj, this);
    }
    if (this._isDirty) {
      this.compute();
      this._isDirty = false;
      this._notified = false;
    }
    return this._value;
  }
  // deepscan-disable-next-line
  setValue(v) {
    if (isFunction(this.$set)) {
      if (this._coercer !== void 0) {
        v = this._coercer.call(null, v, this._coercionConfig);
      }
      if (!areEqual(v, this._value)) {
        this.$set.call(this._obj, v);
        this.run();
      }
    } else {
      throw createMappedError$1(
        221
        /* ErrorNames.assign_readonly_readonly_property_from_computed */
      );
    }
  }
  useCoercer(coercer, coercionConfig) {
    this._coercer = coercer;
    this._coercionConfig = coercionConfig;
    return true;
  }
  useCallback(callback) {
    this._callback = callback;
    return true;
  }
  handleDirty() {
    if (!this._isDirty) {
      this._isDirty = true;
      this.subs.notifyDirty();
    }
  }
  handleChange() {
    this._isDirty = true;
    if (this.subs.count > 0) {
      this.run();
    }
  }
  handleCollectionChange() {
    this._isDirty = true;
    if (this.subs.count > 0) {
      this.run();
    }
  }
  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this._oldValue = this.compute();
      this._isDirty = false;
      this._notified = false;
    }
  }
  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this._isDirty = true;
      this.obs.clearAll();
      this._oldValue = void 0;
      this._notified = true;
    }
  }
  run() {
    if (this._flush === "sync") {
      this._run();
      return;
    }
    if (this._isQueued) {
      return;
    }
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      this._run();
    });
  }
  /** @internal */
  _run() {
    const currValue = this._value;
    const oldValue = this._oldValue;
    const newValue = this.compute();
    this._isDirty = false;
    if (!this._notified || !areEqual(newValue, currValue)) {
      this._callback?.(newValue, oldValue);
      this.subs.notify(newValue, oldValue);
      this._oldValue = this._value = newValue;
      this._notified = true;
    }
  }
  compute() {
    this.obs.version++;
    try {
      enterConnectable(this);
      return this._value = unwrap$1(this.$get.call(this._wrapped, this._wrapped, this));
    } finally {
      this.obs.clear();
      exitConnectable(this);
    }
  }
}
(() => {
  connectable(ComputedObserver, null);
  subscriberCollection(ComputedObserver, null);
})();
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
const computedPropInfo = /* @__PURE__ */ (() => {
  const map = /* @__PURE__ */ new WeakMap();
  const normalizeKey = (key) => {
    return isSymbol(key) ? key : String(key);
  };
  return {
    get: (obj, key) => map.get(obj)?.get(normalizeKey(key)),
    _getFlush: (obj, key) => {
      return map.get(obj)?.get(normalizeKey(key))?.flush;
    },
    set: (obj, key, value) => {
      if (!map.has(obj)) {
        map.set(obj, /* @__PURE__ */ new Map());
      }
      map.get(obj).set(normalizeKey(key), value);
    }
  };
})();
const IDirtyChecker = /* @__PURE__ */ rtCreateInterface(
  "IDirtyChecker",
  (x) => x.callback(() => {
    throw createMappedError$1(
      217
      /* ErrorNames.dirty_check_no_handler */
    );
  })
);
const DirtyCheckSettings = {
  /**
   * Default: `6`
   *
   * Adjust the global dirty check frequency.
   * Measures in "timeouts per check", such that (given a default of 250 timeouts per second in modern browsers):
   * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)
   * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)
   */
  timeoutsPerCheck: 25
};
class DirtyChecker {
  static register(c) {
    c.register(Registration.singleton(this, this), Registration.aliasTo(this, IDirtyChecker));
  }
  constructor() {
    this.tracked = [];
    this._task = null;
    this._elapsedFrames = 0;
    this.p = resolve(IPlatform$1);
    this.check = () => {
      if (++this._elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {
        return;
      }
      this._elapsedFrames = 0;
      const tracked = this.tracked.slice(0);
      const len = tracked.length;
      let current;
      let i = 0;
      for (; i < len; ++i) {
        current = tracked[i];
        if (current.isDirty()) {
          current.flush();
        }
      }
    };
    subscriberCollection(DirtyCheckProperty, null);
  }
  createProperty(obj, key) {
    return new DirtyCheckProperty(this, obj, key);
  }
  addProperty(property) {
    this.tracked.push(property);
    if (this.tracked.length === 1) {
      this._task = queueRecurringTask(this.check, { interval: 0 });
    }
  }
  removeProperty(property) {
    this.tracked.splice(this.tracked.indexOf(property), 1);
    if (this.tracked.length === 0) {
      this._task.cancel();
      this._task = null;
    }
  }
}
class DirtyCheckProperty {
  constructor(dirtyChecker, obj, key) {
    this.obj = obj;
    this.key = key;
    this.type = atNone;
    this._oldValue = void 0;
    this._dirtyChecker = dirtyChecker;
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(_v) {
    throw createMappedError$1(219, this.key);
  }
  isDirty() {
    return this._oldValue !== this.obj[this.key];
  }
  flush() {
    const oldValue = this._oldValue;
    const newValue = this.getValue();
    this._oldValue = newValue;
    this.subs.notify(newValue, oldValue);
  }
  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this._oldValue = this.obj[this.key];
      this._dirtyChecker.addProperty(this);
    }
  }
  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this._dirtyChecker.removeProperty(this);
    }
  }
}
class PrimitiveObserver {
  get doNotCache() {
    return true;
  }
  constructor(obj, key) {
    this.type = atNone;
    this._obj = obj;
    this._key = key;
  }
  getValue() {
    return this._obj[this._key];
  }
  setValue() {
  }
  subscribe() {
  }
  unsubscribe() {
  }
}
class PropertyAccessor {
  constructor() {
    this.type = atNone;
  }
  getValue(obj, key) {
    return obj[key];
  }
  setValue(value, obj, key) {
    obj[key] = value;
  }
}
class SetterObserver {
  constructor(obj, key) {
    this.type = atObserver$1;
    this._value = void 0;
    this._observing = false;
    this._callback = void 0;
    this._coercer = void 0;
    this._coercionConfig = void 0;
    this._obj = obj;
    this._key = key;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (this._coercer !== void 0) {
      newValue = this._coercer.call(void 0, newValue, this._coercionConfig);
    }
    const oldValue = this._value;
    if (this._observing) {
      if (areEqual(newValue, this._value)) {
        return;
      }
      this._value = newValue;
      this.subs.notifyDirty();
      this.subs.notify(newValue, oldValue);
      if (areEqual(newValue, this._value)) {
        this._callback?.(newValue, oldValue);
      }
    } else {
      this._value = this._obj[this._key] = newValue;
      this._callback?.(newValue, oldValue);
    }
  }
  useCallback(callback) {
    this._callback = callback;
    this.start();
    return true;
  }
  useCoercer(coercer, coercionConfig) {
    this._coercer = coercer;
    this._coercionConfig = coercionConfig;
    this.start();
    return true;
  }
  subscribe(subscriber) {
    if (this._observing === false) {
      this.start();
    }
    this.subs.add(subscriber);
  }
  start() {
    if (this._observing === false) {
      this._observing = true;
      this._value = this._obj[this._key];
      rtDef(this._obj, this._key, {
        enumerable: true,
        configurable: true,
        get: rtObjectAssign(() => this.getValue(), { getObserver: () => this }),
        set: (value) => {
          this.setValue(value);
        }
      });
    }
    return this;
  }
  stop() {
    if (this._observing) {
      rtDef(this._obj, this._key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this._value
      });
      this._observing = false;
    }
    return this;
  }
}
(() => {
  subscriberCollection(SetterObserver, null);
})();
const propertyAccessor = new PropertyAccessor();
const IObserverLocator = /* @__PURE__ */ rtCreateInterface("IObserverLocator", (x) => x.singleton(ObserverLocator));
const INodeObserverLocator = /* @__PURE__ */ rtCreateInterface("INodeObserverLocator", (x) => x.cachedCallback((handler) => {
  {
    handler.getAll(ILogger).forEach((logger) => {
      logger.error("Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).");
    });
  }
  return new DefaultNodeObserverLocator();
}));
class DefaultNodeObserverLocator {
  handles() {
    return false;
  }
  getObserver() {
    return propertyAccessor;
  }
  getAccessor() {
    return propertyAccessor;
  }
}
const IComputedObserverLocator = /* @__PURE__ */ rtCreateInterface("IComputedObserverLocator", (x) => x.singleton(class DefaultLocator {
  getObserver(obj, key, pd, requestor) {
    const observer = new ComputedObserver(obj, pd.get, pd.set, requestor, computedPropInfo._getFlush(obj, key));
    rtDef(obj, key, {
      enumerable: pd.enumerable,
      configurable: true,
      get: rtObjectAssign((() => observer.getValue()), { getObserver: () => observer }),
      set: (v) => {
        observer.setValue(v);
      }
    });
    return observer;
  }
}));
class ObserverLocator {
  constructor() {
    this._adapters = [];
    this._dirtyChecker = resolve(IDirtyChecker);
    this._nodeObserverLocator = resolve(INodeObserverLocator);
    this._computedObserverLocator = resolve(IComputedObserverLocator);
  }
  addAdapter(adapter) {
    this._adapters.push(adapter);
  }
  getObserver(obj, key) {
    if (obj == null) {
      throw createMappedError$1(199, key);
    }
    if (!isObject(obj)) {
      return new PrimitiveObserver(obj, isFunction(key) ? "" : key);
    }
    if (isFunction(key)) {
      return new ComputedObserver(obj, key, void 0, this);
    }
    const lookup2 = getObserverLookup(obj);
    let observer = lookup2[key];
    if (observer === void 0) {
      observer = this.createObserver(obj, key);
      if (!observer.doNotCache) {
        lookup2[key] = observer;
      }
    }
    return observer;
  }
  getAccessor(obj, key) {
    const cached = obj.$observers?.[key];
    if (cached !== void 0) {
      return cached;
    }
    if (this._nodeObserverLocator.handles(obj, key, this)) {
      return this._nodeObserverLocator.getAccessor(obj, key, this);
    }
    return propertyAccessor;
  }
  getArrayObserver(observedArray) {
    return getArrayObserver(observedArray);
  }
  getMapObserver(observedMap) {
    return getMapObserver(observedMap);
  }
  getSetObserver(observedSet) {
    return getSetObserver(observedSet);
  }
  createObserver(obj, key) {
    if (this._nodeObserverLocator.handles(obj, key, this)) {
      return this._nodeObserverLocator.getObserver(obj, key, this);
    }
    switch (key) {
      case "length":
        if (isArray(obj)) {
          return getArrayObserver(obj).getLengthObserver();
        }
        break;
      case "size":
        if (isMap(obj)) {
          return getMapObserver(obj).getLengthObserver();
        } else if (isSet(obj)) {
          return getSetObserver(obj).getLengthObserver();
        }
        break;
      default:
        if (isArray(obj) && isArrayIndex(key)) {
          return getArrayObserver(obj).getIndexObserver(Number(key));
        }
        break;
    }
    let pd = getOwnPropDesc(obj, key);
    if (pd === void 0) {
      let proto = getProto(obj);
      while (proto !== null) {
        pd = getOwnPropDesc(proto, key);
        if (pd === void 0) {
          proto = getProto(proto);
        } else {
          break;
        }
      }
    }
    if (pd !== void 0 && !hasOwnProp.call(pd, "value")) {
      let obs = this._getAdapterObserver(obj, key, pd);
      if (obs == null) {
        obs = pd.get?.getObserver?.(obj);
      }
      return obs == null ? pd.configurable ? this._computedObserverLocator.getObserver(obj, key, pd, this) : this._dirtyChecker.createProperty(obj, key) : obs;
    }
    return new SetterObserver(obj, key);
  }
  // /** @internal */
  // private _createComputedObserver(obj: object, key: PropertyKey, pd: PropertyDescriptor, useProxy?: boolean) {
  //   const observer = new ComputedObserver(obj, pd.get!, pd.set, this, !!useProxy);
  //   def(obj, key, {
  //     enumerable: pd.enumerable,
  //     configurable: true,
  //     get: objectAssign(((/* Computed Observer */) => observer.getValue()) as ObservableGetter, { getObserver: () => observer }),
  //     set: (/* Computed Observer */v) => {
  //       observer.setValue(v);
  //     },
  //   });
  //   return observer;
  // }
  /** @internal */
  _getAdapterObserver(obj, key, pd) {
    if (this._adapters.length > 0) {
      for (const adapter of this._adapters) {
        const observer = adapter.getObserver(obj, key, pd, this);
        if (observer != null) {
          return observer;
        }
      }
    }
    return null;
  }
}
const getCollectionObserver$1 = (collection) => {
  let obs;
  if (isArray(collection)) {
    obs = getArrayObserver(collection);
  } else if (isMap(collection)) {
    obs = getMapObserver(collection);
  } else if (isSet(collection)) {
    obs = getSetObserver(collection);
  }
  return obs;
};
const getProto = Object.getPrototypeOf;
const getOwnPropDesc = Object.getOwnPropertyDescriptor;
const getObserverLookup = (instance) => {
  let lookup2 = instance.$observers;
  if (lookup2 === void 0) {
    rtDef(instance, "$observers", { value: lookup2 = createLookup$1() });
  }
  return lookup2;
};
class RunEffect {
  constructor(oL, fn2) {
    this.oL = oL;
    this.fn = fn2;
    this.maxRunCount = 10;
    this.queued = false;
    this.running = false;
    this.runCount = 0;
    this.stopped = false;
    this._cleanupTask = void 0;
    this.run = () => {
      if (this.stopped) {
        throw createMappedError$1(
          225
          /* ErrorNames.stopping_a_stopped_effect */
        );
      }
      if (this.running) {
        return;
      }
      ++this.runCount;
      this.running = true;
      this.queued = false;
      ++this.obs.version;
      try {
        this._cleanupTask?.call(void 0);
        enterConnectable(this);
        this._cleanupTask = this.fn(this);
      } finally {
        this.obs.clear();
        this.running = false;
        exitConnectable(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount) {
          this.runCount = 0;
          throw createMappedError$1(
            226
            /* ErrorNames.effect_maximum_recursion_reached */
          );
        }
        this.run();
      } else {
        this.runCount = 0;
      }
    };
    this.stop = () => {
      this._cleanupTask?.call(void 0);
      this._cleanupTask = void 0;
      this.stopped = true;
      this.obs.clearAll();
    };
  }
  handleChange() {
    this.queued = true;
    this.run();
  }
  handleCollectionChange() {
    this.queued = true;
    this.run();
  }
}
(() => {
  connectable(RunEffect, null);
})();
class ExpressionObserver {
  constructor(scope, oL, expression, callback) {
    this.oL = oL;
    this._value = void 0;
    this.boundFn = false;
    this._scope = scope;
    this.ast = expression;
    this._callback = callback;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  run() {
    this.obs.version++;
    const oldValue = this._value;
    const value = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    if (!areEqual(value, oldValue)) {
      this._value = value;
      this._callback.call(void 0, value, oldValue);
    }
  }
  stop() {
    this.obs.clearAll();
    this._value = void 0;
  }
}
(() => {
  connectable(ExpressionObserver, null);
  mixinNoopAstEvaluator(ExpressionObserver);
})();
const tsPending$1 = "pending";
const tsRunning$1 = "running";
const tsCompleted = "completed";
const tsCanceled = "canceled";
const lookup = /* @__PURE__ */ new Map();
const notImplemented = (name2) => {
  return () => {
    throw createError$2(`AUR1005: The PLATFORM did not receive a valid reference to the global function '${name2}'.`);
  };
};
class Platform {
  constructor(g, overrides = {}) {
    this.macroTaskRequested = false;
    this.macroTaskHandle = -1;
    this.globalThis = g;
    "decodeURI decodeURIComponent encodeURI encodeURIComponent Date Reflect console".split(" ").forEach((prop) => {
      this[prop] = prop in overrides ? overrides[prop] : g[prop];
    });
    "clearInterval clearTimeout queueMicrotask setInterval setTimeout".split(" ").forEach((method) => {
      this[method] = method in overrides ? overrides[method] : g[method]?.bind(g) ?? notImplemented(method);
    });
    this.performanceNow = "performanceNow" in overrides ? overrides.performanceNow : g.performance?.now?.bind(g.performance) ?? notImplemented("performance.now");
    this.flushMacroTask = this.flushMacroTask.bind(this);
    this.taskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));
  }
  static getOrCreate(g, overrides = {}) {
    let platform = lookup.get(g);
    if (platform === void 0) {
      lookup.set(g, platform = new Platform(g, overrides));
    }
    return platform;
  }
  static set(g, platform) {
    lookup.set(g, platform);
  }
  requestMacroTask() {
    this.macroTaskRequested = true;
    if (this.macroTaskHandle === -1) {
      this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);
    }
  }
  cancelMacroTask() {
    this.macroTaskRequested = false;
    if (this.macroTaskHandle > -1) {
      this.clearTimeout(this.macroTaskHandle);
      this.macroTaskHandle = -1;
    }
  }
  flushMacroTask() {
    this.macroTaskHandle = -1;
    if (this.macroTaskRequested === true) {
      this.macroTaskRequested = false;
      this.taskQueue.flush();
    }
  }
}
class TaskQueue {
  get isEmpty() {
    return this._pendingAsyncCount === 0 && this._processing.length === 0 && this._pending.length === 0 && this._delayed.length === 0;
  }
  /**
   * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,
   * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.
   *
   * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.
   *
   * If that is the case, we can resolve the promise that was created when `yield()` is called.
   *
   * @internal
   */
  get _hasNoMoreFiniteWork() {
    return this._pendingAsyncCount === 0 && this._processing.every(isPersistent) && this._pending.every(isPersistent) && this._delayed.every(isPersistent);
  }
  constructor(platform, $request, $cancel) {
    this.platform = platform;
    this.$request = $request;
    this.$cancel = $cancel;
    this._suspenderTask = void 0;
    this._pendingAsyncCount = 0;
    this._processing = [];
    this._pending = [];
    this._delayed = [];
    this._flushRequested = false;
    this._yieldPromise = void 0;
    this._lastRequest = 0;
    this._lastFlush = 0;
    this._requestFlush = () => {
      if (this._tracer.enabled) {
        this._tracer.enter(this, "requestFlush");
      }
      if (!this._flushRequested) {
        this._flushRequested = true;
        this._lastRequest = this._now();
        this.$request();
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "requestFlush");
      }
    };
    this._now = platform.performanceNow;
    this._tracer = new Tracer(platform.console);
  }
  flush(now = this._now()) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "flush");
    }
    this._flushRequested = false;
    this._lastFlush = now;
    if (this._suspenderTask === void 0) {
      let curr;
      if (this._pending.length > 0) {
        this._processing.push(...this._pending);
        this._pending.length = 0;
      }
      if (this._delayed.length > 0) {
        for (let i = 0; i < this._delayed.length; ++i) {
          curr = this._delayed[i];
          if (curr.queueTime <= now) {
            this._processing.push(curr);
            this._delayed.splice(i--, 1);
          }
        }
      }
      let cur;
      while (this._processing.length > 0) {
        (cur = this._processing.shift()).run();
        if (cur.status === tsRunning$1) {
          if (cur.suspend === true) {
            this._suspenderTask = cur;
            this._requestFlush();
            if (this._tracer.enabled) {
              this._tracer.leave(this, "flush early async");
            }
            return;
          } else {
            ++this._pendingAsyncCount;
          }
        }
      }
      if (this._pending.length > 0) {
        this._processing.push(...this._pending);
        this._pending.length = 0;
      }
      if (this._delayed.length > 0) {
        for (let i = 0; i < this._delayed.length; ++i) {
          curr = this._delayed[i];
          if (curr.queueTime <= now) {
            this._processing.push(curr);
            this._delayed.splice(i--, 1);
          }
        }
      }
      if (this._processing.length > 0 || this._delayed.length > 0 || this._pendingAsyncCount > 0) {
        this._requestFlush();
      }
      if (this._yieldPromise !== void 0 && this._hasNoMoreFiniteWork) {
        const p = this._yieldPromise;
        this._yieldPromise = void 0;
        p.resolve();
      }
    } else {
      this._requestFlush();
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "flush full");
    }
  }
  /**
   * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.
   *
   * This operation is idempotent and will do nothing if no flush is scheduled.
   */
  cancel() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "cancel");
    }
    if (this._flushRequested) {
      this.$cancel();
      this._flushRequested = false;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "cancel");
    }
  }
  /**
   * Returns a promise that, when awaited, resolves when:
   * - all *non*-persistent (including async) tasks have finished;
   * - the last-added persistent task has run exactly once;
   *
   * This operation is idempotent: the same promise will be returned until it resolves.
   *
   * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.
   */
  async yield() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "yield");
    }
    if (this.isEmpty) {
      if (this._tracer.enabled) {
        this._tracer.leave(this, "yield empty");
      }
    } else {
      if (this._yieldPromise === void 0) {
        if (this._tracer.enabled) {
          this._tracer.trace(this, "yield - creating promise");
        }
        this._yieldPromise = createExposedPromise();
      }
      await this._yieldPromise;
      if (this._tracer.enabled) {
        this._tracer.leave(this, "yield task");
      }
    }
  }
  queueTask(callback, opts) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "queueTask");
    }
    const { delay, preempt, persistent, suspend } = { ...defaultQueueTaskOptions, ...opts };
    if (preempt) {
      if (delay > 0) {
        throw preemptDelayComboError();
      }
      if (persistent) {
        throw preemptyPersistentComboError();
      }
    }
    if (this._processing.length === 0) {
      this._requestFlush();
    }
    const time = this._now();
    const task = new Task2(this._tracer, this, time, time + delay, preempt, persistent, suspend, callback);
    if (preempt) {
      this._processing[this._processing.length] = task;
    } else if (delay === 0) {
      this._pending[this._pending.length] = task;
    } else {
      this._delayed[this._delayed.length] = task;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "queueTask");
    }
    return task;
  }
  /**
   * Remove the task from this queue.
   */
  remove(task) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "remove");
    }
    let idx = this._processing.indexOf(task);
    if (idx > -1) {
      this._processing.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove processing");
      }
      return;
    }
    idx = this._pending.indexOf(task);
    if (idx > -1) {
      this._pending.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove pending");
      }
      return;
    }
    idx = this._delayed.indexOf(task);
    if (idx > -1) {
      this._delayed.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove delayed");
      }
      return;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "remove error");
    }
    throw createError$2(`Task #${task.id} could not be found`);
  }
  /**
   * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.
   *
   * @internal
   */
  _resetPersistentTask(task) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "resetPersistentTask");
    }
    task.reset(this._now());
    if (task.createdTime === task.queueTime) {
      this._pending[this._pending.length] = task;
    } else {
      this._delayed[this._delayed.length] = task;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "resetPersistentTask");
    }
  }
  /**
   * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.
   *
   * @internal
   */
  _completeAsyncTask(task) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "completeAsyncTask");
    }
    if (task.suspend === true) {
      if (this._suspenderTask !== task) {
        if (this._tracer.enabled) {
          this._tracer.leave(this, "completeAsyncTask error");
        }
        throw createError$2(`Async task completion mismatch: suspenderTask=${this._suspenderTask?.id}, task=${task.id}`);
      }
      this._suspenderTask = void 0;
    } else {
      --this._pendingAsyncCount;
    }
    if (this._yieldPromise !== void 0 && this._hasNoMoreFiniteWork) {
      const p = this._yieldPromise;
      this._yieldPromise = void 0;
      p.resolve();
    }
    if (this.isEmpty) {
      this.cancel();
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "completeAsyncTask");
    }
  }
}
class TaskAbortError2 extends Error {
  constructor(task) {
    super("Task was canceled.");
    this.task = task;
  }
}
let id = 0;
class Task2 {
  get result() {
    const result = this._result;
    if (result === void 0) {
      switch (this._status) {
        case tsPending$1: {
          const promise = this._result = createExposedPromise();
          this._resolve = promise.resolve;
          this._reject = promise.reject;
          return promise;
        }
        /* istanbul ignore next */
        case tsRunning$1:
          throw createError$2("Trying to await task from within task will cause a deadlock.");
        case tsCompleted:
          return this._result = Promise.resolve();
        case tsCanceled:
          return this._result = Promise.reject(new TaskAbortError2(this));
      }
    }
    return result;
  }
  get status() {
    return this._status;
  }
  constructor(tracer, taskQueue, createdTime, queueTime, preempt, persistent, suspend, callback) {
    this.taskQueue = taskQueue;
    this.createdTime = createdTime;
    this.queueTime = queueTime;
    this.preempt = preempt;
    this.persistent = persistent;
    this.suspend = suspend;
    this.callback = callback;
    this.id = ++id;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
    this._status = tsPending$1;
    this._tracer = tracer;
  }
  run(time = this.taskQueue.platform.performanceNow()) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "run");
    }
    if (this._status !== tsPending$1) {
      if (this._tracer.enabled) {
        this._tracer.leave(this, "run error");
      }
      throw createError$2(`Cannot run task in ${this._status} state`);
    }
    const { persistent, taskQueue, callback, _resolve: resolve2, _reject: reject, createdTime } = this;
    let ret;
    this._status = tsRunning$1;
    try {
      ret = callback(time - createdTime);
      if (ret instanceof Promise) {
        ret.then(($ret) => {
          if (this.persistent) {
            taskQueue._resetPersistentTask(this);
          } else {
            if (persistent) {
              this._status = tsCanceled;
            } else {
              this._status = tsCompleted;
            }
            this.dispose();
          }
          taskQueue._completeAsyncTask(this);
          if (this._tracer.enabled) {
            this._tracer.leave(this, "run async then");
          }
          if (resolve2 !== void 0) {
            resolve2($ret);
          }
        }).catch((err) => {
          if (!this.persistent) {
            this.dispose();
          }
          taskQueue._completeAsyncTask(this);
          if (this._tracer.enabled) {
            this._tracer.leave(this, "run async catch");
          }
          if (reject !== void 0) {
            reject(err);
          } else {
            throw err;
          }
        });
      } else {
        if (this.persistent) {
          taskQueue._resetPersistentTask(this);
        } else {
          if (persistent) {
            this._status = tsCanceled;
          } else {
            this._status = tsCompleted;
          }
          this.dispose();
        }
        if (this._tracer.enabled) {
          this._tracer.leave(this, "run sync success");
        }
        if (resolve2 !== void 0) {
          resolve2(ret);
        }
      }
    } catch (err) {
      if (!this.persistent) {
        this.dispose();
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "run sync error");
      }
      if (reject !== void 0) {
        reject(err);
      } else {
        throw err;
      }
    }
  }
  cancel() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "cancel");
    }
    if (this._status === tsPending$1) {
      const taskQueue = this.taskQueue;
      const reject = this._reject;
      taskQueue.remove(this);
      if (taskQueue.isEmpty) {
        taskQueue.cancel();
      }
      this._status = tsCanceled;
      this.dispose();
      if (reject !== void 0) {
        reject(new TaskAbortError2(this));
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "cancel true =pending");
      }
      return true;
    } else if (this._status === tsRunning$1 && this.persistent) {
      this.persistent = false;
      if (this._tracer.enabled) {
        this._tracer.leave(this, "cancel true =running+persistent");
      }
      return true;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "cancel false");
    }
    return false;
  }
  reset(time) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "reset");
    }
    const delay = this.queueTime - this.createdTime;
    this.createdTime = time;
    this.queueTime = time + delay;
    this._status = tsPending$1;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
    if (this._tracer.enabled) {
      this._tracer.leave(this, "reset");
    }
  }
  dispose() {
    if (this._tracer.enabled) {
      this._tracer.trace(this, "dispose");
    }
    this.callback = void 0;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
  }
}
class Tracer {
  constructor(console2) {
    this.console = console2;
    this.enabled = false;
    this.depth = 0;
  }
  enter(obj, method) {
    this.log(`${"  ".repeat(this.depth++)}> `, obj, method);
  }
  leave(obj, method) {
    this.log(`${"  ".repeat(--this.depth)}< `, obj, method);
  }
  trace(obj, method) {
    this.log(`${"  ".repeat(this.depth)}- `, obj, method);
  }
  log(prefix, obj, method) {
    if (obj instanceof TaskQueue) {
      const processing = obj._processing.length;
      const pending = obj._pending.length;
      const delayed = obj._delayed.length;
      const flushReq = obj._flushRequested;
      const susTask = !!obj._suspenderTask;
      const info2 = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;
      this.console.log(`${prefix}[Q.${method}] ${info2}`);
    } else {
      const id2 = obj["id"];
      const created = Math.round(obj["createdTime"] * 10) / 10;
      const queue2 = Math.round(obj["queueTime"] * 10) / 10;
      const preempt = obj["preempt"];
      const persistent = obj["persistent"];
      const suspend = obj["suspend"];
      const status = obj["_status"];
      const info2 = `id=${id2} created=${created} queue=${queue2} preempt=${preempt} persistent=${persistent} status=${status} suspend=${suspend}`;
      this.console.log(`${prefix}[T.${method}] ${info2}`);
    }
  }
}
const defaultQueueTaskOptions = {
  delay: 0,
  preempt: false,
  persistent: false,
  suspend: false
};
let $resolve;
let $reject;
const executor = (resolve2, reject) => {
  $resolve = resolve2;
  $reject = reject;
};
const createExposedPromise = () => {
  const p = new Promise(executor);
  p.resolve = $resolve;
  p.reject = $reject;
  return p;
};
const isPersistent = (task) => task.persistent;
const preemptDelayComboError = () => createError$2(`AUR1006: Invalid arguments: preempt cannot be combined with a greater-than-zero delay`);
const preemptyPersistentComboError = () => createError$2(`AUR1007: Invalid arguments: preempt cannot be combined with persistent`);
const createError$2 = (msg) => new Error(msg);
class BrowserPlatform extends Platform {
  static getOrCreate(g, overrides = {}) {
    let platform = BrowserPlatform._lookup.get(g);
    if (platform === void 0) {
      BrowserPlatform._lookup.set(g, platform = new BrowserPlatform(g, overrides));
    }
    return platform;
  }
  static set(g, platform) {
    BrowserPlatform._lookup.set(g, platform);
  }
  /**
   * @deprecated Use `platform.domQueue` instead.
   */
  get domWriteQueue() {
    {
      this.console.log("[DEV:aurelia] platform.domQueue is deprecated, please use platform.domQueue instead.");
    }
    return this.domQueue;
  }
  /**
   * @deprecated Use `platform.domQueue` instead.
   */
  get domReadQueue() {
    {
      this.console.log("[DEV:aurelia] platform.domReadQueue has been removed, please use platform.domQueue instead.");
    }
    return this.domQueue;
  }
  constructor(g, overrides = {}) {
    super(g, overrides);
    const notImplemented2 = (name2) => () => {
      throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name2}'.`);
    };
    "Node Element HTMLElement CustomEvent CSSStyleSheet ShadowRoot MutationObserver window document customElements".split(" ").forEach((prop) => this[prop] = prop in overrides ? overrides[prop] : g[prop]);
    "fetch requestAnimationFrame cancelAnimationFrame".split(" ").forEach((prop) => (
      // eslint-disable-next-line
      this[prop] = prop in overrides ? overrides[prop] : g[prop]?.bind(g) ?? notImplemented2(prop)
    ));
    this.domQueue = (() => {
      let domRequested = false;
      let domHandle = -1;
      const requestDomFlush = () => {
        domRequested = true;
        if (domHandle === -1) {
          domHandle = this.requestAnimationFrame(flushDomQueue);
        }
      };
      const cancelDomFlush = () => {
        domRequested = false;
        if (domHandle > -1) {
          this.cancelAnimationFrame(domHandle);
          domHandle = -1;
        }
      };
      const flushDomQueue = () => {
        domHandle = -1;
        if (domRequested === true) {
          domRequested = false;
          domQueue.flush();
        }
      };
      const domQueue = new TaskQueue(this, requestDomFlush, cancelDomFlush);
      return domQueue;
    })();
  }
}
BrowserPlatform._lookup = /* @__PURE__ */ new WeakMap();
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
const { default: defaultMode, oneTime, toView, fromView, twoWay } = BindingMode;
const getMetadata = Metadata.get;
const hasMetadata = Metadata.has;
const defineMetadata = Metadata.define;
const { annotation } = Protocol;
const getAnnotationKeyFor = annotation.keyFor;
const O = Object;
const safeString = String;
const baseObjectPrototype = O.prototype;
const hasOwnProperty = baseObjectPrototype.hasOwnProperty;
const objectFreeze = O.freeze;
const objectAssign = O.assign;
const getOwnPropertyNames = O.getOwnPropertyNames;
const objectKeys = O.keys;
const IsDataAttribute = /* @__PURE__ */ createLookup$1();
const isDataAttribute = (obj, key, svgAnalyzer) => {
  if (IsDataAttribute[key] === true) {
    return true;
  }
  if (!isString(key)) {
    return false;
  }
  const prefix = key.slice(0, 5);
  return IsDataAttribute[key] = prefix === "aria-" || prefix === "data-" || svgAnalyzer.isStandardSvgAttribute(obj, key);
};
const rethrow = (err) => {
  throw err;
};
const def = Reflect.defineProperty;
const defineHiddenProp = (obj, key, value) => {
  def(obj, key, {
    enumerable: false,
    configurable: true,
    writable: true,
    value
  });
  return value;
};
const addSignalListener = (signaler, signal, listener) => signaler.addSignalListener(signal, listener);
const removeSignalListener = (signaler, signal, listener) => signaler.removeSignalListener(signal, listener);
const etInterpolation = "Interpolation";
const etIsIterator = "IsIterator";
const etIsFunction = "IsFunction";
const etIsProperty = "IsProperty";
const tsPending = "pending";
const tsRunning = "running";
const atObserver = AccessorType.Observer;
const atNode = AccessorType.Node;
const atLayout = AccessorType.Layout;
const createMappedError = (code, ...details) => {
  const paddedCode = safeString(code).padStart(4, "0");
  const message = getMessageByCode(code, ...details);
  const link = `https://docs.aurelia.io/developer-guides/error-messages/runtime-html/aur${paddedCode}`;
  return new Error(`AUR${paddedCode}: ${message}

For more information, see: ${link}`);
};
const errorsMap = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    113
    /* ErrorNames.ast_increment_infinite_loop */
  ]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,
  [
    114
    /* ErrorNames.ast_nullish_member_access */
  ]: `Ast eval error: cannot access property "{{0}}" of {{1}}.`,
  [
    115
    /* ErrorNames.ast_nullish_keyed_access */
  ]: `Ast eval error: cannot access key "{{0}}" of {{1}}.`,
  [
    116
    /* ErrorNames.ast_nullish_assignment */
  ]: `Ast eval error: cannot assign value to property "{{0}}" of null/undefined.`,
  [
    151
    /* ErrorNames.binding_behavior_def_not_found */
  ]: `No binding behavior definition found for type {{0:name}}`,
  [
    152
    /* ErrorNames.value_converter_def_not_found */
  ]: `No value converter definition found for type {{0:name}}`,
  [
    153
    /* ErrorNames.element_existed */
  ]: `Element "{{0}}" has already been registered.`,
  [
    154
    /* ErrorNames.attribute_existed */
  ]: `Attribute "{{0}}" has already been registered.`,
  [
    155
    /* ErrorNames.value_converter_existed */
  ]: `Value converter {{0}} has already been registered.`,
  [
    156
    /* ErrorNames.binding_behavior_existed */
  ]: `Binding behavior {{0}} has already been registered.`,
  [
    157
    /* ErrorNames.binding_command_existed */
  ]: `Binding command {{0}} has already been registered.`,
  [
    203
    /* ErrorNames.null_scope */
  ]: `Trying to retrieve a property or build a scope from a null/undefined scope`,
  [
    204
    /* ErrorNames.create_scope_with_null_context */
  ]: "Trying to create a scope with null/undefined binding context",
  [
    227
    /* ErrorNames.invalid_bindable_decorator_usage_symbol */
  ]: `@bindable is not supported for properties that uses a symbol for name. Use a string for the property name instead.`,
  [
    228
    /* ErrorNames.invalid_bindable_decorator_usage_class_without_configuration */
  ]: `@bindable cannot be used as a class decorator when no configuration object is supplied.`,
  [
    229
    /* ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration */
  ]: `@bindable cannot be used as a class decorator when no property name is supplied in the configuration object.`,
  [
    500
    /* ErrorNames.controller_cached_not_found */
  ]: `There is no cached controller for the provided ViewModel: {{0}}`,
  [
    501
    /* ErrorNames.controller_no_shadow_on_containerless */
  ]: `Invalid combination: cannot combine the containerless custom element option with Shadow DOM.`,
  [
    502
    /* ErrorNames.controller_activating_disposed */
  ]: `Trying to activate a disposed controller: {{0}}.`,
  [
    503
    /* ErrorNames.controller_activation_unexpected_state */
  ]: `Controller at {{0}} is in an unexpected state: {{1}} during activation.`,
  [
    504
    /* ErrorNames.controller_activation_synthetic_no_scope */
  ]: `Synthetic view at {{0}} is being activated with null/undefined scope.`,
  [
    505
    /* ErrorNames.controller_deactivation_unexpected_state */
  ]: `Controller at {{0}} is in an unexpected state: {{1}} during deactivation.`,
  [
    506
    /* ErrorNames.controller_watch_invalid_callback */
  ]: `Invalid callback for @watch decorator: {{0}}`,
  [
    507
    /* ErrorNames.controller_property_not_coercible */
  ]: `Observer for bindable property {{0}} does not support coercion.`,
  [
    508
    /* ErrorNames.controller_property_no_change_handler */
  ]: `Observer for property {{0}} does not support change handler.`,
  [
    759
    /* ErrorNames.attribute_def_not_found */
  ]: `No attribute definition found for type {{0:name}}`,
  [
    760
    /* ErrorNames.element_def_not_found */
  ]: `No element definition found for type {{0:name}}`,
  [
    761
    /* ErrorNames.element_only_name */
  ]: `Cannot create a custom element definition with only a name and no type: {{0}}`,
  [
    762
    /* ErrorNames.node_is_not_a_host */
  ]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,
  [
    763
    /* ErrorNames.node_is_not_a_host2 */
  ]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,
  [
    764
    /* ErrorNames.node_is_not_part_of_aurelia_app */
  ]: `Trying to retrieve a custom element controller from a node. But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,
  [
    765
    /* ErrorNames.node_is_not_part_of_aurelia_app2 */
  ]: `Trying to retrieve a custom element controller from a node. But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,
  [
    766
    /* ErrorNames.invalid_process_content_hook */
  ]: `Invalid @processContent hook. Expected the hook to be a function (when defined in a class, it needs to be a static function) but got a {{0:typeof}}.`,
  [
    652
    /* ErrorNames.node_observer_strategy_not_found */
  ]: `Aurelia is unable to observe property {{0}}. Register observation mapping with .useConfig().`,
  [
    653
    /* ErrorNames.node_observer_mapping_existed */
  ]: `Mapping for property {{0}} of <{{1}} /> already exists`,
  [
    654
    /* ErrorNames.select_observer_array_on_non_multi_select */
  ]: `Array values can only be bound to a multi-select.`,
  [
    714
    /* ErrorNames.compiler_primary_already_existed */
  ]: `Template compilation error: primary already exists on element/attribute "{{0}}"`,
  [
    719
    /* ErrorNames.compiler_attr_mapper_duplicate_mapping */
  ]: `Attribute {{0}} has been already registered for {{1:element}}`,
  [
    767
    /* ErrorNames.root_not_found */
  ]: `Aurelia.root was accessed without a valid root.`,
  [
    768
    /* ErrorNames.aurelia_instance_existed_in_container */
  ]: `An instance of Aurelia is already registered with the container or an ancestor of it.`,
  [
    769
    /* ErrorNames.invalid_platform_impl */
  ]: `Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView, did you create the host from a DOMParser and forget to call adoptNode()?`,
  [
    770
    /* ErrorNames.no_composition_root */
  ]: `Aurelia.start() was called without a composition root`,
  [
    771
    /* ErrorNames.invalid_dispose_call */
  ]: `The aurelia instance must be fully stopped before it can be disposed`,
  [
    750
    /* ErrorNames.not_supported_view_ref_api */
  ]: `view.ref is not supported. If you are migrating from v1, this can be understood as the controller.`,
  [
    751
    /* ErrorNames.ref_not_found */
  ]: `Attempted to reference "{{0}}", but it was not found amongst the target's API.`,
  [
    752
    /* ErrorNames.element_res_not_found */
  ]: `Element {{0:.res}} is not registered in {{1:name}}.`,
  [
    753
    /* ErrorNames.attribute_res_not_found */
  ]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,
  [
    754
    /* ErrorNames.attribute_tc_res_not_found */
  ]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,
  [
    755
    /* ErrorNames.view_factory_provider_not_ready */
  ]: `Cannot resolve ViewFactory before the provider was prepared.`,
  [
    756
    /* ErrorNames.view_factory_invalid_name */
  ]: `Cannot resolve ViewFactory without a (valid) name.`,
  [
    757
    /* ErrorNames.rendering_mismatch_length */
  ]: `AUR0757: The compiled template is not aligned with the render instructions. There are {{0}} targets and {{1}} instructions.`,
  [
    772
    /* ErrorNames.watch_null_config */
  ]: `Invalid @watch decorator config. Expected an expression or a fn but received null/undefined.`,
  [
    773
    /* ErrorNames.watch_invalid_change_handler */
  ]: `Invalid @watch decorator change handler config.Method "{{0}}" not found in class {{1}}`,
  [
    774
    /* ErrorNames.watch_non_method_decorator_usage */
  ]: `Invalid @watch decorator usage: decorated target {{0}} is not a class method.`,
  [
    775
    /* ErrorNames.repeat_invalid_key_binding_command */
  ]: `Invalid command "{{0}}" usage with [repeat]`,
  [
    776
    /* ErrorNames.repeat_extraneous_binding */
  ]: `Invalid [repeat] usage, found extraneous target "{{0}}"`,
  [
    777
    /* ErrorNames.repeat_non_iterable */
  ]: `Unsupported: [repeat] cannot iterate over {{0:toString}}`,
  [
    778
    /* ErrorNames.repeat_non_countable */
  ]: `Unsupported: [repeat] cannot count {{0:toString}}`,
  [
    814
    /* ErrorNames.repeat_mismatch_length */
  ]: `[repeat] encountered an error: number of views != number of items {{0:join(!=)}}`,
  [
    779
    /* ErrorNames.portal_invalid_insert_position */
  ]: "Invalid portal insertion position: {{0}}",
  [
    801
    /* ErrorNames.self_behavior_invalid_usage */
  ]: `"& self" binding behavior only supports listener binding via trigger/capture command.`,
  [
    802
    /* ErrorNames.update_trigger_behavior_no_triggers */
  ]: `"& updateTrigger" invalid usage. This binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:'blur'">`,
  [
    803
    /* ErrorNames.update_trigger_invalid_usage */
  ]: `"& updateTrigger" invalid usage. This binding behavior can only be applied to two-way/ from-view bindings.`,
  [
    805
    /* ErrorNames.au_compose_invalid_scope_behavior */
  ]: `Invalid scope behavior "{{0}}" on <au-compose />. Only "scoped" or "auto" allowed.`,
  // originally not supported
  [
    806
    /* ErrorNames.au_compose_component_name_not_found */
  ]: `<au-compose /> couldn't find a custom element with name "{{0}}", did you forget to register it locally or globally?`,
  [
    807
    /* ErrorNames.au_compose_invalid_run */
  ]: `Composition has already been activated/deactivated. Id: {{0:controller}}`,
  [
    808
    /* ErrorNames.au_compose_duplicate_deactivate */
  ]: `Composition has already been deactivated.`,
  [
    810
    /* ErrorNames.else_without_if */
  ]: `Invalid [else] usage, it should follow an [if]`,
  [
    811
    /* ErrorNames.portal_query_empty */
  ]: `Invalid portal strict target query, empty query.`,
  [
    812
    /* ErrorNames.portal_no_target */
  ]: `Invalid portal strict target resolution, target not found.`,
  [
    813
    /* ErrorNames.promise_invalid_usage */
  ]: `Invalid [pending]/[then]/[catch] usage. The parent [promise].resolve not found; only "*[promise.resolve] > *[pending|then|catch]" relation is supported.`,
  [
    815
    /* ErrorNames.switch_invalid_usage */
  ]: `Invalid [case/default-case] usage. The parent [switch] not found; only "*[switch] > *[case|default-case]" relation is supported.`,
  [
    816
    /* ErrorNames.switch_no_multiple_default */
  ]: `Invalid [default-case] usage. Multiple 'default-case's are not allowed.`,
  [
    817
    /* ErrorNames.signal_behavior_invalid_usage */
  ]: `"& signal" binding behavior can only be used with bindings that have a "handleChange" method`,
  [
    818
    /* ErrorNames.signal_behavior_no_signals */
  ]: `"& signal" invalid usage. At least one signal name must be passed to the signal behavior, e.g. "expr & signal:'my-signal'"`,
  [
    819
    /* ErrorNames.spreading_bindable_onto_non_component */
  ]: "Spreading to bindables onto non custom element",
  [
    820
    /* ErrorNames.spreading_invalid_target */
  ]: `Invalid spread target {{0}}`,
  [
    9999
    /* ErrorNames.no_spread_scope_context_found */
  ]: "No scope context for spread binding.",
  [
    9998
    /* ErrorNames.no_spread_template_controller */
  ]: "Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?",
  [
    9997
    /* ErrorNames.marker_malformed */
  ]: `Marker is malformed. This likely happens when a compiled template has been modified. Did you accidentally modified some compiled template? You can modify template before compilation with compiling Template compiler hook.`,
  [
    9996
    /* ErrorNames.binding_already_has_rate_limited */
  ]: `Invalid usage, a rate limit has already been applied. Did you have both throttle and debounce on the same binding?`,
  [
    9995
    /* ErrorNames.binding_already_has_target_subscriber */
  ]: `The binding already has a target subscriber.`,
  [
    9994
    /* ErrorNames.attr_behavior_invalid_binding */
  ]: `"& attr" can be only used on property binding. It's used on {{0:ctor}}`,
  [
    9993
    /* ErrorNames.update_trigger_behavior_not_supported */
  ]: '"& updateTrigger" binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger',
  [
    9992
    /* ErrorNames.update_trigger_behavior_node_property_not_observable */
  ]: `"& updateTrigger" uses node observer to observe, but it does not know how to use events to observe property <{{0:target@property}} />`,
  [
    9991
    /* ErrorNames.children_decorator_invalid_usage */
  ]: `Invalid @children usage. @children decorator can only be used on a field`,
  [
    9990
    /* ErrorNames.slotted_decorator_invalid_usage */
  ]: `Invalid @slotted usage. @slotted decorator can only be used on a field`,
  [
    9989
    /* ErrorNames.children_invalid_query */
  ]: `Invalid query selector. Only selectors with alpha-numeric characters, or $all are allowed. Got {{0}} instead.`
};
const getMessageByCode = (name2, ...details) => {
  let cooked = errorsMap[name2];
  for (let i = 0; i < details.length; ++i) {
    const regex = new RegExp(`{{${i}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i];
      if (value != null) {
        switch (method) {
          case "nodeName":
            value = value.nodeName.toLowerCase();
            break;
          case "name":
            value = value.name;
            break;
          case "typeof":
            value = typeof value;
            break;
          case "ctor":
            value = value.constructor.name;
            break;
          case "controller":
            value = value.controller.name;
            break;
          case "target@property":
            value = `${value.target}@${value.targetProperty}`;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "bindingCommandHelp":
            value = getBindingCommandHelp(value);
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = safeString(value[method.slice(1)]);
            } else {
              value = safeString(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
function getBindingCommandHelp(name2) {
  switch (name2) {
    case "delegate":
      return `
The ".delegate" binding command has been removed in v2. Binding command ".trigger" should be used instead. If you are migrating v1 application, install compat package to add back the ".delegate" binding command for ease of migration.`;
    case "call":
      return `
The ".call" binding command has been removed in v2. If you want to pass a callback that preserves the context of the function call, you can use lambda instead. Refer to lambda expression doc for more details.`;
    default:
      return "";
  }
}
function bindable(configOrPropOrTarget, context) {
  let configOrProp = void 0;
  function decorator(_target, context2) {
    let $prop;
    switch (context2.kind) {
      case "getter":
      case "field": {
        const prop = context2.name;
        if (typeof prop !== "string")
          throw createMappedError(
            227
            /* ErrorNames.invalid_bindable_decorator_usage_symbol */
          );
        $prop = prop;
        break;
      }
      case "class":
        if (configOrProp == null)
          throw createMappedError(
            228
            /* ErrorNames.invalid_bindable_decorator_usage_class_without_configuration */
          );
        if (typeof configOrProp == "string") {
          $prop = configOrProp;
        } else {
          const prop = configOrProp.name;
          if (!prop)
            throw createMappedError(
              229
              /* ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration */
            );
          if (typeof prop !== "string")
            throw createMappedError(
              227
              /* ErrorNames.invalid_bindable_decorator_usage_symbol */
            );
          $prop = prop;
        }
        break;
    }
    const config = configOrProp == null || typeof configOrProp === "string" ? { name: $prop } : configOrProp;
    const metadata = context2.metadata[baseName] ??= createLookup$1();
    metadata[$prop] = BindableDefinition.create($prop, config);
  }
  if (arguments.length > 1) {
    configOrProp = {};
    decorator(configOrPropOrTarget, context);
    return;
  } else if (isString(configOrPropOrTarget)) {
    configOrProp = configOrPropOrTarget;
    return decorator;
  }
  configOrProp = configOrPropOrTarget === void 0 ? {} : configOrPropOrTarget;
  return decorator;
}
const baseName = /* @__PURE__ */ getAnnotationKeyFor("bindables");
const Bindable = objectFreeze({
  name: baseName,
  keyFrom: (name2) => `${baseName}:${name2}`,
  from(...bindableLists) {
    const bindables2 = {};
    const isArray2 = Array.isArray;
    function addName(name2) {
      bindables2[name2] = BindableDefinition.create(name2);
    }
    function addDescription(name2, def2) {
      bindables2[name2] = def2 instanceof BindableDefinition ? def2 : BindableDefinition.create(name2, def2 === true ? {} : def2);
    }
    function addList(maybeList) {
      if (isArray2(maybeList)) {
        maybeList.forEach((nameOrDef) => isString(nameOrDef) ? addName(nameOrDef) : addDescription(nameOrDef.name, nameOrDef));
      } else if (maybeList instanceof BindableDefinition) {
        bindables2[maybeList.name] = maybeList;
      } else if (maybeList !== void 0) {
        objectKeys(maybeList).forEach((name2) => addDescription(name2, maybeList[name2]));
      }
    }
    bindableLists.forEach(addList);
    return bindables2;
  },
  getAll(Type) {
    const defs = [];
    const prototypeChain = getPrototypeChain(Type);
    let iProto = prototypeChain.length;
    let Class;
    while (--iProto >= 0) {
      Class = prototypeChain[iProto];
      const bindableMetadata = getMetadata(baseName, Class);
      if (bindableMetadata == null)
        continue;
      defs.push(...Object.values(bindableMetadata));
    }
    return defs;
  },
  /** @internal */
  _add(bindable2, Type) {
    let bindables2 = getMetadata(baseName, Type);
    if (bindables2 == null) {
      defineMetadata(bindables2 = createLookup$1(), Type, baseName);
    }
    bindables2[bindable2.name] = bindable2;
  }
});
class BindableDefinition {
  constructor(attribute, callback, mode, primary, name2, set) {
    this.attribute = attribute;
    this.callback = callback;
    this.mode = mode;
    this.primary = primary;
    this.name = name2;
    this.set = set;
  }
  static create(prop, def2 = {}) {
    const mode = def2.mode ?? toView;
    return new BindableDefinition(def2.attribute ?? kebabCase(prop), def2.callback ?? `${prop}Changed`, isString(mode) ? BindingMode[mode] ?? defaultMode : mode, def2.primary ?? false, def2.name ?? prop, def2.set ?? getInterceptor(def2));
  }
}
const Coercer = {
  key: /* @__PURE__ */ getAnnotationKeyFor("coercer"),
  define(target, property) {
    defineMetadata(target[property].bind(target), target, Coercer.key);
  },
  for(target) {
    return getMetadata(Coercer.key, target);
  }
};
function getInterceptor(def2 = {}) {
  const type = def2.type ?? null;
  if (type == null) {
    return noop;
  }
  let coercer;
  switch (type) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      coercer = type;
      break;
    default: {
      const $coercer = type.coerce;
      coercer = typeof $coercer === "function" ? $coercer.bind(type) : Coercer.for(type) ?? noop;
      break;
    }
  }
  return coercer === noop ? coercer : createCoercer(coercer, def2.nullable);
}
function createCoercer(coercer, nullable) {
  return function(value, coercionConfiguration) {
    if (!coercionConfiguration?.enableCoercion)
      return value;
    return (nullable ?? (coercionConfiguration?.coerceNullish ?? false ? false : true)) && value == null ? value : coercer(value, coercionConfiguration);
  };
}
const createInterface = DI.createInterface;
const singletonRegistration = Registration.singleton;
const aliasRegistration = Registration.aliasTo;
const instanceRegistration = Registration.instance;
const registerResolver = (ctn, key, resolver) => ctn.registerResolver(key, resolver);
const dtElement = "custom-element";
const dtAttribute = "custom-attribute";
const getDefinitionFromStaticAu = (Type, typeName, createDef, metadataKey = "__au_static_resource__") => {
  let def2 = getMetadata(metadataKey, Type);
  if (def2 == null) {
    if (Type.$au?.type === typeName) {
      def2 = createDef(Type.$au, Type);
      defineMetadata(def2, Type, metadataKey);
    }
  }
  return def2;
};
class BindingBehaviorDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new BindingBehaviorDefinition(Type, firstDefined(getBehaviorAnnotation(Type, "name"), name2), mergeArrays(getBehaviorAnnotation(Type, "aliases"), def2.aliases, Type.aliases), BindingBehavior.keyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getBindingBehaviorKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getBindingBehaviorKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError(156, this.name)}`);
    }
  }
}
const behaviorTypeName = "binding-behavior";
const bbBaseName = /* @__PURE__ */ getResourceKeyFor(behaviorTypeName);
const getBehaviorAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getBindingBehaviorKeyFrom = (name2) => `${bbBaseName}:${name2}`;
const BindingBehavior = /* @__PURE__ */ objectFreeze({
  name: bbBaseName,
  keyFrom: getBindingBehaviorKeyFrom,
  isType(value) {
    return isFunction(value) && (hasMetadata(bbBaseName, value) || value.$au?.type === behaviorTypeName);
  },
  define(nameOrDef, Type) {
    const definition = BindingBehaviorDefinition.create(nameOrDef, Type);
    const $Type = definition.Type;
    defineMetadata(definition, $Type, bbBaseName, resourceBaseName);
    return $Type;
  },
  getDefinition(Type) {
    const def2 = getMetadata(bbBaseName, Type) ?? getDefinitionFromStaticAu(Type, behaviorTypeName, BindingBehaviorDefinition.create);
    if (def2 === void 0) {
      throw createMappedError(151, Type);
    }
    return def2;
  },
  find(container, name2) {
    const Type = container.find(behaviorTypeName, name2);
    return Type == null ? null : getMetadata(bbBaseName, Type) ?? getDefinitionFromStaticAu(Type, behaviorTypeName, BindingBehaviorDefinition.create) ?? null;
  },
  get(container, name2) {
    {
      try {
        return container.get(resource(getBindingBehaviorKeyFrom(name2)));
      } catch (ex) {
        console.error("[DEV:aurelia] Cannot retrieve binding behavior with name", name2);
        throw ex;
      }
    }
    return container.get(resource(getBindingBehaviorKeyFrom(name2)));
  }
});
const originalModesMap = /* @__PURE__ */ new Map();
const createConfig = (name2) => ({ type: behaviorTypeName, name: name2 });
class BindingModeBehavior {
  bind(scope, binding) {
    originalModesMap.set(binding, binding.mode);
    binding.mode = this.mode;
  }
  unbind(scope, binding) {
    binding.mode = originalModesMap.get(binding);
    originalModesMap.delete(binding);
  }
}
class OneTimeBindingBehavior extends BindingModeBehavior {
  get mode() {
    return oneTime;
  }
}
OneTimeBindingBehavior.$au = createConfig("oneTime");
class ToViewBindingBehavior extends BindingModeBehavior {
  get mode() {
    return toView;
  }
}
ToViewBindingBehavior.$au = createConfig("toView");
class FromViewBindingBehavior extends BindingModeBehavior {
  get mode() {
    return fromView;
  }
}
FromViewBindingBehavior.$au = createConfig("fromView");
class TwoWayBindingBehavior extends BindingModeBehavior {
  get mode() {
    return twoWay;
  }
}
TwoWayBindingBehavior.$au = createConfig("twoWay");
const bindingHandlerMap$1 = /* @__PURE__ */ new WeakMap();
const defaultDelay$1 = 200;
class DebounceBindingBehavior {
  constructor() {
    this._platform = resolve(IPlatform$1);
  }
  bind(scope, binding, delay, signals) {
    const opts = {
      type: "debounce",
      delay: delay ?? defaultDelay$1,
      now: this._platform.performanceNow,
      queue: this._platform.taskQueue,
      signals: isString(signals) ? [signals] : signals ?? emptyArray
    };
    const handler = binding.limit?.(opts);
    if (handler == null) {
      {
        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);
      }
    } else {
      bindingHandlerMap$1.set(binding, handler);
    }
  }
  unbind(scope, binding) {
    bindingHandlerMap$1.get(binding)?.dispose();
    bindingHandlerMap$1.delete(binding);
  }
}
DebounceBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "debounce"
};
const ISignaler = /* @__PURE__ */ createInterface("ISignaler", (x) => x.singleton(Signaler));
class Signaler {
  constructor() {
    this.signals = createLookup$1();
  }
  dispatchSignal(name2) {
    const listeners = this.signals[name2];
    if (listeners === void 0) {
      return;
    }
    let listener;
    for (listener of listeners.keys()) {
      listener.handleChange(void 0, void 0);
    }
  }
  addSignalListener(name2, listener) {
    (this.signals[name2] ??= /* @__PURE__ */ new Set()).add(listener);
  }
  removeSignalListener(name2, listener) {
    this.signals[name2]?.delete(listener);
  }
}
class SignalBindingBehavior {
  constructor() {
    this._lookup = /* @__PURE__ */ new Map();
    this._signaler = resolve(ISignaler);
  }
  bind(scope, binding, ...names) {
    if (!("handleChange" in binding)) {
      throw createMappedError(
        817
        /* ErrorNames.signal_behavior_invalid_usage */
      );
    }
    if (names.length === 0) {
      throw createMappedError(
        818
        /* ErrorNames.signal_behavior_no_signals */
      );
    }
    this._lookup.set(binding, names);
    let name2;
    for (name2 of names) {
      addSignalListener(this._signaler, name2, binding);
    }
  }
  unbind(scope, binding) {
    const names = this._lookup.get(binding);
    this._lookup.delete(binding);
    let name2;
    for (name2 of names) {
      removeSignalListener(this._signaler, name2, binding);
    }
  }
}
SignalBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "signal"
};
const bindingHandlerMap = /* @__PURE__ */ new WeakMap();
const defaultDelay = 200;
class ThrottleBindingBehavior {
  constructor() {
    ({ performanceNow: this._now, taskQueue: this._taskQueue } = resolve(IPlatform$1));
  }
  bind(scope, binding, delay, signals) {
    const opts = {
      type: "throttle",
      delay: delay ?? defaultDelay,
      now: this._now,
      queue: this._taskQueue,
      signals: isString(signals) ? [signals] : signals ?? emptyArray
    };
    const handler = binding.limit?.(opts);
    if (handler == null) {
      {
        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);
      }
    } else {
      bindingHandlerMap.set(binding, handler);
    }
  }
  unbind(scope, binding) {
    bindingHandlerMap.get(binding)?.dispose();
    bindingHandlerMap.delete(binding);
  }
}
ThrottleBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "throttle"
};
const IAppTask = /* @__PURE__ */ createInterface("IAppTask");
class $AppTask {
  constructor(slot, key, cb) {
    this.c = void 0;
    this.slot = slot;
    this.k = key;
    this.cb = cb;
  }
  register(container) {
    return this.c = container.register(instanceRegistration(IAppTask, this));
  }
  run() {
    const key = this.k;
    const cb = this.cb;
    return key === null ? cb() : cb(this.c.get(key));
  }
}
const AppTask = objectFreeze({
  /**
   * Returns a task that will run just before the root component is created by DI
   */
  creating: createAppTaskSlotHook("creating"),
  /**
   * Returns a task that will run after instantiating the root controller,
   * but before compiling its view (thus means before instantiating the child elements inside it)
   *
   * good chance for a router to do some initial work, or initial routing related in general
   */
  hydrating: createAppTaskSlotHook("hydrating"),
  /**
   * Return a task that will run after the hydration of the root controller,
   * but before hydrating the child element inside
   *
   * good chance for a router to do some initial work, or initial routing related in general
   */
  hydrated: createAppTaskSlotHook("hydrated"),
  /**
   * Return a task that will run right before the root component is activated.
   * In this phase, scope hierarchy is formed, and bindings are getting bound
   */
  activating: createAppTaskSlotHook("activating"),
  /**
   * Return a task that will run right after the root component is activated - the app is now running
   */
  activated: createAppTaskSlotHook("activated"),
  /**
   * Return a task that will runs right before the root component is deactivated.
   * In this phase, scope hierarchy is unlinked, and bindings are getting unbound
   */
  deactivating: createAppTaskSlotHook("deactivating"),
  /**
   * Return a task that will run right after the root component is deactivated
   */
  deactivated: createAppTaskSlotHook("deactivated")
});
function createAppTaskSlotHook(slotName) {
  function appTaskFactory(keyOrCallback, callback) {
    if (isFunction(callback)) {
      return new $AppTask(slotName, keyOrCallback, callback);
    }
    return new $AppTask(slotName, null, keyOrCallback);
  }
  return appTaskFactory;
}
const IPlatform = IPlatform$1;
class Refs {
}
const refs = /* @__PURE__ */ (() => {
  const refsMap = /* @__PURE__ */ new WeakMap();
  let hideProp = false;
  return new class {
    get hideProp() {
      return hideProp;
    }
    set hideProp(value) {
      hideProp = value;
    }
    get(node, name2) {
      return refsMap.get(node)?.[name2] ?? null;
    }
    set(node, name2, controller) {
      const ref = refsMap.get(node) ?? (refsMap.set(node, new Refs()), refsMap.get(node));
      if (name2 in ref) {
        throw new Error(`Node already associated with a controller, remove the ref "${name2}" first before associating with another controller`);
      }
      if (!hideProp) {
        node.$au ??= ref;
      }
      return ref[name2] = controller;
    }
  }();
})();
const INode = /* @__PURE__ */ createInterface("INode");
function watch(expressionOrPropertyAccessFn, changeHandlerOrCallbackOrOptions, optionsOrUndefined) {
  if (expressionOrPropertyAccessFn == null) {
    throw createMappedError(
      772
      /* ErrorNames.watch_null_config */
    );
  }
  return function decorator(target, context) {
    const isClassDecorator = context.kind === "class";
    let options;
    let changeHandler;
    if (isClassDecorator) {
      if (!isFunction(changeHandlerOrCallbackOrOptions) && changeHandlerOrCallbackOrOptions == null) {
        throw createMappedError(773, `${safeString(changeHandlerOrCallbackOrOptions)}@${target.name}}`);
      }
      changeHandler = changeHandlerOrCallbackOrOptions;
      options = {};
    } else {
      if (!isFunction(target) || context.static) {
        throw createMappedError(774, context.name);
      }
      changeHandler = target;
      options = {};
    }
    const watchDef = new WatchDefinition(expressionOrPropertyAccessFn, changeHandler, options.flush);
    if (isClassDecorator) {
      addDefinition(target);
    } else {
      let added = false;
      context.addInitializer(function() {
        if (!added) {
          added = true;
          addDefinition(this.constructor);
        }
      });
    }
    function addDefinition(type) {
      Watch.add(type, watchDef);
      if (isAttributeType(type)) {
        getAttributeDefinition(type).watches.push(watchDef);
      }
      if (isElementType(type)) {
        getElementDefinition(type).watches.push(watchDef);
      }
    }
  };
}
class WatchDefinition {
  constructor(expression, callback, flush = "async") {
    this.expression = expression;
    this.callback = callback;
    this.flush = flush;
  }
}
const Watch = /* @__PURE__ */ (() => {
  const watches = /* @__PURE__ */ new WeakMap();
  return objectFreeze({
    add(Type, definition) {
      let defs = watches.get(Type);
      if (defs == null) {
        watches.set(Type, defs = []);
      }
      defs.push(definition);
    },
    getDefinitions(Type) {
      return watches.get(Type) ?? emptyArray;
    }
  });
})();
class CustomAttributeDefinition {
  // a simple marker to distinguish between Custom Element definition & Custom attribute definition
  get type() {
    return dtAttribute;
  }
  constructor(Type, name2, aliases, key, defaultBindingMode, isTemplateController, bindables2, noMultiBindings, watches, dependencies2, containerStrategy) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
    this.defaultBindingMode = defaultBindingMode;
    this.isTemplateController = isTemplateController;
    this.bindables = bindables2;
    this.noMultiBindings = noMultiBindings;
    this.watches = watches;
    this.dependencies = dependencies2;
    this.containerStrategy = containerStrategy;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    const mode = firstDefined(getAttributeAnnotation(Type, "defaultBindingMode"), def2.defaultBindingMode, Type.defaultBindingMode, toView);
    for (const bindable2 of Object.values(Bindable.from(def2.bindables))) {
      Bindable._add(bindable2, Type);
    }
    return new CustomAttributeDefinition(Type, firstDefined(getAttributeAnnotation(Type, "name"), name2), mergeArrays(getAttributeAnnotation(Type, "aliases"), def2.aliases, Type.aliases), getAttributeKeyFrom(name2), isString(mode) ? BindingMode[mode] ?? defaultMode : mode, firstDefined(getAttributeAnnotation(Type, "isTemplateController"), def2.isTemplateController, Type.isTemplateController, false), Bindable.from(...Bindable.getAll(Type), getAttributeAnnotation(Type, "bindables"), Type.bindables, def2.bindables), firstDefined(getAttributeAnnotation(Type, "noMultiBindings"), def2.noMultiBindings, Type.noMultiBindings, false), mergeArrays(Watch.getDefinitions(Type), Type.watches), mergeArrays(getAttributeAnnotation(Type, "dependencies"), def2.dependencies, Type.dependencies), firstDefined(getAttributeAnnotation(Type, "containerStrategy"), def2.containerStrategy, Type.containerStrategy, "reuse"));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getAttributeKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getAttributeKeyFrom(alias))));
    } else {
      if (CustomAttributeDefinition.warnDuplicate) {
        container.get(ILogger).warn(createMappedError(154, this.name));
      }
      {
        console.warn(`[DEV:aurelia] ${createMappedError(154, this.name)}`);
      }
    }
  }
  toString() {
    return `au:ca:${this.name}`;
  }
}
CustomAttributeDefinition.warnDuplicate = true;
const attrTypeName = "custom-attribute";
const attributeBaseName = /* @__PURE__ */ getResourceKeyFor(attrTypeName);
const getAttributeKeyFrom = (name2) => `${attributeBaseName}:${name2}`;
const getAttributeAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const isAttributeType = (value) => {
  return isFunction(value) && (hasMetadata(attributeBaseName, value) || value.$au?.type === attrTypeName);
};
const findAttributeControllerFor = (node, name2) => {
  return refs.get(node, getAttributeKeyFrom(name2)) ?? void 0;
};
const defineAttribute = (nameOrDef, Type) => {
  const definition = CustomAttributeDefinition.create(nameOrDef, Type);
  const $Type = definition.Type;
  defineMetadata(definition, $Type, attributeBaseName, resourceBaseName);
  return $Type;
};
const getAttributeDefinition = (Type) => {
  const def2 = getMetadata(attributeBaseName, Type) ?? getDefinitionFromStaticAu(Type, attrTypeName, CustomAttributeDefinition.create);
  if (def2 === void 0) {
    throw createMappedError(759, Type);
  }
  return def2;
};
const findClosestControllerByName = (node, attrNameOrType) => {
  let key = "";
  let attrName = "";
  if (isString(attrNameOrType)) {
    key = getAttributeKeyFrom(attrNameOrType);
    attrName = attrNameOrType;
  } else {
    const definition = getAttributeDefinition(attrNameOrType);
    key = definition.key;
    attrName = definition.name;
  }
  let cur = node;
  while (cur !== null) {
    const controller = refs.get(cur, key);
    if (controller?.is(attrName)) {
      return controller;
    }
    cur = getEffectiveParentNode(cur);
  }
  return null;
};
const CustomAttribute = /* @__PURE__ */ objectFreeze({
  name: attributeBaseName,
  keyFrom: getAttributeKeyFrom,
  isType: isAttributeType,
  for: findAttributeControllerFor,
  closest: findClosestControllerByName,
  define: defineAttribute,
  getDefinition: getAttributeDefinition,
  annotate(Type, prop, value) {
    defineMetadata(value, Type, getAnnotationKeyFor(prop));
  },
  getAnnotation: getAttributeAnnotation,
  find(c, name2) {
    const Type = c.find(attrTypeName, name2);
    return Type === null ? null : getMetadata(attributeBaseName, Type) ?? getDefinitionFromStaticAu(Type, attrTypeName, CustomAttributeDefinition.create) ?? null;
  }
});
const ILifecycleHooks = /* @__PURE__ */ createInterface("ILifecycleHooks");
class LifecycleHooksEntry {
  constructor(definition, instance) {
    this.definition = definition;
    this.instance = instance;
  }
}
class LifecycleHooksDefinition {
  constructor(Type, propertyNames) {
    this.Type = Type;
    this.propertyNames = propertyNames;
  }
  /**
   * @param def - Placeholder for future extensions. Currently always an empty object.
   */
  static create(def2, Type) {
    const propertyNames = /* @__PURE__ */ new Set();
    let proto = Type.prototype;
    while (proto !== baseObjectPrototype) {
      for (const name2 of getOwnPropertyNames(proto)) {
        if (name2 !== "constructor" && !name2.startsWith("_")) {
          propertyNames.add(name2);
        }
      }
      proto = Object.getPrototypeOf(proto);
    }
    return new LifecycleHooksDefinition(Type, propertyNames);
  }
}
const LifecycleHooks = /* @__PURE__ */ (() => {
  const containerLookup2 = /* @__PURE__ */ new WeakMap();
  const definitionMap = /* @__PURE__ */ new WeakMap();
  return objectFreeze({
    // name: lhBaseName,
    /**
     * @param def - Placeholder for future extensions. Currently always an empty object.
     */
    define(def2, Type) {
      const definition = LifecycleHooksDefinition.create(def2, Type);
      const $Type = definition.Type;
      definitionMap.set($Type, definition);
      return {
        register(container) {
          singletonRegistration(ILifecycleHooks, $Type).register(container);
        }
      };
    },
    /**
     * @param ctx - The container where the resolution starts
     * @param Type - The constructor of the Custom element/ Custom attribute with lifecycle metadata
     */
    resolve(ctx) {
      let lookup2 = containerLookup2.get(ctx);
      if (lookup2 === void 0) {
        containerLookup2.set(ctx, lookup2 = new LifecycleHooksLookupImpl());
        const root = ctx.root;
        const instances2 = root === ctx ? ctx.getAll(ILifecycleHooks) : ctx.has(ILifecycleHooks, false) ? root.getAll(ILifecycleHooks).concat(ctx.getAll(ILifecycleHooks)) : root.getAll(ILifecycleHooks);
        let instance;
        let definition;
        let entry;
        let name2;
        let entries;
        for (instance of instances2) {
          definition = definitionMap.get(instance.constructor);
          entry = new LifecycleHooksEntry(definition, instance);
          for (name2 of definition.propertyNames) {
            entries = lookup2[name2];
            if (entries === void 0) {
              lookup2[name2] = [entry];
            } else {
              entries.push(entry);
            }
          }
        }
      }
      return lookup2;
    }
  });
})();
class LifecycleHooksLookupImpl {
}
function valueConverter(nameOrDef) {
  return function(target, context) {
    context.addInitializer(function() {
      ValueConverter.define(nameOrDef, this);
    });
    return target;
  };
}
class ValueConverterDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new ValueConverterDefinition(Type, firstDefined(getConverterAnnotation(Type, "name"), name2), mergeArrays(getConverterAnnotation(Type, "aliases"), def2.aliases, Type.aliases), ValueConverter.keyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getValueConverterKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getValueConverterKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError(155, this.name)}`);
    }
  }
}
const converterTypeName = "value-converter";
const vcBaseName = /* @__PURE__ */ getResourceKeyFor(converterTypeName);
const getConverterAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getValueConverterKeyFrom = (name2) => `${vcBaseName}:${name2}`;
const ValueConverter = objectFreeze({
  name: vcBaseName,
  keyFrom: getValueConverterKeyFrom,
  isType(value) {
    return isFunction(value) && (hasMetadata(vcBaseName, value) || value.$au?.type === converterTypeName);
  },
  define(nameOrDef, Type) {
    const definition = ValueConverterDefinition.create(nameOrDef, Type);
    const $Type = definition.Type;
    defineMetadata(definition, $Type, vcBaseName, resourceBaseName);
    return $Type;
  },
  getDefinition(Type) {
    const def2 = getMetadata(vcBaseName, Type) ?? getDefinitionFromStaticAu(Type, converterTypeName, ValueConverterDefinition.create);
    if (def2 === void 0) {
      throw createMappedError(152, Type);
    }
    return def2;
  },
  annotate(Type, prop, value) {
    defineMetadata(value, Type, getAnnotationKeyFor(prop));
  },
  getAnnotation: getConverterAnnotation,
  find(container, name2) {
    const Type = container.find(converterTypeName, name2);
    return Type == null ? null : getMetadata(vcBaseName, Type) ?? getDefinitionFromStaticAu(Type, converterTypeName, ValueConverterDefinition.create) ?? null;
  },
  get(container, name2) {
    {
      try {
        return container.get(resource(getValueConverterKeyFrom(name2)));
      } catch (ex) {
        console.error("[DEV:aurelia] Cannot retrieve value converter with name", name2);
        throw ex;
      }
    }
    return container.get(resource(getValueConverterKeyFrom(name2)));
  }
});
class BindingTargetSubscriber {
  constructor(b, flushQueue) {
    this._value = void 0;
    this.b = b;
    this._flushQueue = flushQueue;
  }
  flush() {
    if (this.b.isBound) {
      this.b.updateSource(this._value);
    }
  }
  // deepscan-disable-next-line
  handleChange(value, _) {
    const b = this.b;
    if (value !== astEvaluate(b.ast, b._scope, b, null)) {
      this._value = value;
      this._flushQueue.add(this);
    }
  }
}
const mixinUseScope = /* @__PURE__ */ (() => {
  function useScope(scope) {
    this._scope = scope;
  }
  return (target) => {
    defineHiddenProp(target.prototype, "useScope", useScope);
  };
})();
const mixinAstEvaluator = /* @__PURE__ */ (() => {
  class ResourceLookup {
  }
  const converterResourceLookupCache = /* @__PURE__ */ new WeakMap();
  const behaviorResourceLookupCache = /* @__PURE__ */ new WeakMap();
  const appliedBehaviors = /* @__PURE__ */ new WeakMap();
  function evaluatorGet(key) {
    return this.l.get(key);
  }
  function evaluatorGetBehavior(b, name2) {
    let resourceLookup = behaviorResourceLookupCache.get(b);
    if (resourceLookup == null) {
      behaviorResourceLookupCache.set(b, resourceLookup = new ResourceLookup());
    }
    return resourceLookup[name2] ??= BindingBehavior.get(b.l, name2);
  }
  function evaluatorBindBehavior(name2, scope, args) {
    const behavior = evaluatorGetBehavior(this, name2);
    if (behavior == null) {
      throw createMappedError(101, name2);
    }
    let applied = appliedBehaviors.get(this);
    if (applied == null) {
      appliedBehaviors.set(this, applied = {});
    }
    if (applied[name2]) {
      throw createMappedError(102, name2);
    }
    behavior.bind?.(scope, this, ...args);
  }
  function evaluatorUnbindBehavior(name2, scope) {
    const behavior = evaluatorGetBehavior(this, name2);
    const applied = appliedBehaviors.get(this);
    behavior?.unbind?.(scope, this);
    if (applied != null) {
      applied[name2] = false;
    }
  }
  function evaluatorGetConverter(b, name2) {
    let resourceLookup = converterResourceLookupCache.get(b);
    if (resourceLookup == null) {
      converterResourceLookupCache.set(b, resourceLookup = new ResourceLookup());
    }
    return resourceLookup[name2] ??= ValueConverter.get(b.l, name2);
  }
  function evaluatorBindConverter(name2) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc == null) {
      throw createMappedError(103, name2);
    }
    const signals = vc.signals;
    if (signals != null) {
      const signaler = this.l.get(ISignaler);
      const ii = signals.length;
      let i = 0;
      for (; i < ii; ++i) {
        signaler.addSignalListener(signals[i], this);
      }
    }
  }
  function evaluatorUnbindConverter(name2) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc?.signals === void 0) {
      return;
    }
    const signaler = this.l.get(ISignaler);
    let i = 0;
    for (; i < vc.signals.length; ++i) {
      signaler.removeSignalListener(vc.signals[i], this);
    }
  }
  function evaluatorUseConverter(name2, mode, value, args) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc == null) {
      throw createMappedError(103, name2);
    }
    const withContext = vc.withContext === true;
    let callerContext = null;
    if (withContext) {
      const hydrationContext = this.l.get(IHydrationContext);
      const controller = hydrationContext.controller;
      const viewModel = controller.viewModel;
      callerContext = {
        source: viewModel,
        binding: this
      };
    }
    switch (mode) {
      case "toView": {
        if ("toView" in vc) {
          return withContext ? vc.toView(value, callerContext, ...args) : vc.toView(value, ...args);
        }
        return value;
      }
      case "fromView": {
        if ("fromView" in vc) {
          return withContext ? vc.fromView?.(value, callerContext, ...args) : vc.fromView?.(value, ...args);
        }
        return value;
      }
    }
  }
  return (target) => {
    const proto = target.prototype;
    defineHiddenProp(proto, "get", evaluatorGet);
    defineHiddenProp(proto, "bindBehavior", evaluatorBindBehavior);
    defineHiddenProp(proto, "unbindBehavior", evaluatorUnbindBehavior);
    defineHiddenProp(proto, "bindConverter", evaluatorBindConverter);
    defineHiddenProp(proto, "unbindConverter", evaluatorUnbindConverter);
    defineHiddenProp(proto, "useConverter", evaluatorUseConverter);
  };
})();
const IFlushQueue = /* @__PURE__ */ createInterface("IFlushQueue", (x) => x.singleton(FlushQueue));
class FlushQueue {
  constructor() {
    this._flushing = false;
    this._items = /* @__PURE__ */ new Set();
  }
  get count() {
    return this._items.size;
  }
  add(flushable) {
    this._items.add(flushable);
    if (this._flushing) {
      return;
    }
    this._flushing = true;
    try {
      this._items.forEach(flushItem);
    } finally {
      this._flushing = false;
    }
  }
  clear() {
    this._items.clear();
    this._flushing = false;
  }
}
const flushItem = function(item, _, items) {
  items.delete(item);
  item.flush();
};
const mixingBindingLimited = /* @__PURE__ */ (() => {
  const withLimitationBindings = /* @__PURE__ */ new WeakSet();
  const debounced = (opts, callOriginal, binding) => {
    let limiterTask;
    let task;
    let latestValue;
    let isPending = false;
    const callOriginalCallback = () => callOriginal(latestValue);
    const fn2 = (v) => {
      latestValue = v;
      if (binding.isBound) {
        task = limiterTask;
        limiterTask = queueAsyncTask(callOriginalCallback, { delay: opts.delay });
        task?.cancel();
      } else {
        callOriginalCallback();
      }
    };
    const dispose2 = fn2.dispose = () => {
      task?.cancel();
      limiterTask?.cancel();
      task = limiterTask = void 0;
    };
    fn2.flush = () => {
      isPending = limiterTask?.status === tsPending;
      dispose2();
      if (isPending) {
        callOriginalCallback();
      }
    };
    return fn2;
  };
  const throttled = (opts, callOriginal, binding) => {
    let limiterTask;
    let task;
    let last = 0;
    let elapsed = 0;
    let latestValue;
    let isPending = false;
    const now = () => opts.now();
    const callOriginalCallback = () => callOriginal(latestValue);
    const fn2 = (v) => {
      latestValue = v;
      if (binding.isBound) {
        elapsed = now() - last;
        task = limiterTask;
        if (elapsed > opts.delay) {
          last = now();
          callOriginalCallback();
        } else {
          limiterTask = queueAsyncTask(() => {
            last = now();
            callOriginalCallback();
          }, { delay: opts.delay - elapsed });
        }
        task?.cancel();
      } else {
        callOriginalCallback();
      }
    };
    const dispose2 = fn2.dispose = () => {
      task?.cancel();
      limiterTask?.cancel();
      task = limiterTask = void 0;
    };
    fn2.flush = () => {
      isPending = limiterTask?.status === tsPending;
      dispose2();
      if (isPending) {
        callOriginalCallback();
      }
    };
    return fn2;
  };
  return (target, getMethodName) => {
    defineHiddenProp(target.prototype, "limit", function(opts) {
      if (withLimitationBindings.has(this)) {
        throw createMappedError(
          9996
          /* ErrorNames.binding_already_has_rate_limited */
        );
      }
      withLimitationBindings.add(this);
      const prop = getMethodName(this, opts);
      const signals = opts.signals;
      const signaler = signals.length > 0 ? this.get(ISignaler) : null;
      const originalFn = this[prop];
      const callOriginal = (...args) => originalFn.call(this, ...args);
      const limitedFn = opts.type === "debounce" ? debounced(opts, callOriginal, this) : throttled(opts, callOriginal, this);
      const signalListener = signaler ? { handleChange: limitedFn.flush } : null;
      this[prop] = limitedFn;
      if (signaler) {
        signals.forEach((s) => addSignalListener(signaler, s, signalListener));
      }
      return {
        dispose: () => {
          if (signaler) {
            signals.forEach((s) => removeSignalListener(signaler, s, signalListener));
          }
          withLimitationBindings.delete(this);
          limitedFn.dispose();
          delete this[prop];
        }
      };
    });
  };
})();
const createPrototypeMixer = /* @__PURE__ */ ((mixed = /* @__PURE__ */ new WeakSet()) => {
  return (mixer) => {
    return function() {
      if (!mixed.has(this)) {
        mixed.add(this);
        mixer.call(this);
      }
    };
  };
})();
class AttributeBinding {
  constructor(controller, locator, observerLocator, ast, target, targetAttribute, targetProperty, mode, strict) {
    this.targetAttribute = targetAttribute;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._isQueued = false;
    this._value = void 0;
    this.boundFn = false;
    this._isMulti = false;
    this.l = locator;
    this.ast = ast;
    this._controller = controller;
    this.target = target;
    this.oL = observerLocator;
    if ((this._isMulti = targetProperty.indexOf(" ") > -1) && !AttributeBinding._splitString.has(targetProperty)) {
      AttributeBinding._splitString.set(targetProperty, targetProperty.split(" "));
    }
  }
  updateTarget(value) {
    const target = this.target;
    const targetAttribute = this.targetAttribute;
    const targetProperty = this.targetProperty;
    switch (targetAttribute) {
      case "class":
        if (this._isMulti) {
          const force = !!value;
          for (const cls of AttributeBinding._splitString.get(targetProperty)) {
            target.classList.toggle(cls, force);
          }
        } else {
          target.classList.toggle(targetProperty, !!value);
        }
        break;
      case "style": {
        let priority = "";
        let newValue = safeString(value);
        if (isString(newValue) && newValue.includes("!important")) {
          priority = "important";
          newValue = newValue.replace("!important", "");
        }
        target.style.setProperty(targetProperty, newValue, priority);
        break;
      }
      default: {
        if (value == null) {
          target.removeAttribute(targetAttribute);
        } else {
          target.setAttribute(targetAttribute, safeString(value));
        }
      }
    }
  }
  handleChange() {
    if (!this.isBound)
      return;
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      if (!this.isBound)
        return;
      this.obs.version++;
      const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
      this.obs.clear();
      if (newValue !== this._value) {
        this._value = newValue;
        this.updateTarget(newValue);
      }
    });
  }
  // todo: based off collection and handle update accordingly instead off always start
  handleCollectionChange() {
    this.handleChange();
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    if (this.mode & (toView | oneTime)) {
      this.updateTarget(this._value = astEvaluate(this.ast, scope, this, (this.mode & toView) > 0 ? this : null));
    }
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this._value = void 0;
    this.obs.clearAll();
  }
}
AttributeBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(AttributeBinding);
  mixingBindingLimited(AttributeBinding, () => "updateTarget");
  connectable(AttributeBinding, null);
  mixinAstEvaluator(AttributeBinding);
});
AttributeBinding._splitString = /* @__PURE__ */ new Map();
class InterpolationBinding {
  constructor(controller, locator, observerLocator, ast, target, targetProperty, mode, strict) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._isQueued = false;
    this._controller = controller;
    this.oL = observerLocator;
    this._targetObserver = observerLocator.getAccessor(target, targetProperty);
    const expressions = ast.expressions;
    const partBindings = this.partBindings = Array(expressions.length);
    const ii = expressions.length;
    let i = 0;
    for (; ii > i; ++i) {
      partBindings[i] = new InterpolationPartBinding(expressions[i], target, targetProperty, locator, observerLocator, strict, this);
    }
  }
  /** @internal */
  _handlePartChange() {
    if (!this.isBound)
      return;
    const shouldQueue = this._controller.state !== activating && (this._targetObserver.type & atLayout) > 0;
    if (shouldQueue) {
      if (this._isQueued)
        return;
      this._isQueued = true;
      queueTask(() => {
        this._isQueued = false;
        if (!this.isBound)
          return;
        this.updateTarget();
      });
    } else {
      this.updateTarget();
    }
  }
  updateTarget() {
    const partBindings = this.partBindings;
    const ast = this.ast;
    const target = this.target;
    const targetProperty = this.targetProperty;
    const staticParts = ast.parts;
    const ii = partBindings.length;
    let result = "";
    let i = 0;
    if (ii === 1) {
      result = staticParts[0] + partBindings[0]._evaluate() + staticParts[1];
    } else {
      result = staticParts[0];
      for (; ii > i; ++i) {
        result += partBindings[i]._evaluate() + staticParts[i + 1];
      }
    }
    this._targetObserver.setValue(result, target, targetProperty);
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    const partBindings = this.partBindings;
    const ii = partBindings.length;
    let i = 0;
    for (; ii > i; ++i) {
      partBindings[i].bind(scope);
    }
    this.updateTarget();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this._scope = void 0;
    const partBindings = this.partBindings;
    const ii = partBindings.length;
    let i = 0;
    for (; ii > i; ++i) {
      partBindings[i].unbind();
    }
  }
  /**
   * Start using a given observer to update the target
   */
  useAccessor(accessor) {
    this._targetObserver = accessor;
  }
}
class InterpolationPartBinding {
  constructor(ast, target, targetProperty, locator, observerLocator, strict, owner) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.strict = strict;
    this.owner = owner;
    this.mode = toView;
    this.isBound = false;
    this._value = "";
    this.boundFn = false;
    this._isDirty = false;
    this.l = locator;
    this.oL = observerLocator;
  }
  updateTarget() {
    this.owner._handlePartChange();
  }
  handleChange() {
    if (!this.isBound)
      return;
    this._isDirty = true;
    this.updateTarget();
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    this._isDirty = true;
    this.updateTarget();
  }
  /** @internal */
  _evaluate() {
    if (!this._isDirty)
      return this._value;
    this.obs.version++;
    const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    this.obs.clear();
    this._value = newValue;
    if (isArray(newValue)) {
      this.observeCollection(newValue);
    }
    this._isDirty = false;
    return this._value;
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    if (isArray(this._value)) {
      this.observeCollection(this._value);
    }
    this._isDirty = false;
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this._value = void 0;
    this._isDirty = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
}
InterpolationPartBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(InterpolationPartBinding);
  mixingBindingLimited(InterpolationPartBinding, () => "updateTarget");
  connectable(InterpolationPartBinding, null);
  mixinAstEvaluator(InterpolationPartBinding);
});
class ContentBinding {
  constructor(controller, locator, observerLocator, p, ast, target, strict) {
    this.p = p;
    this.ast = ast;
    this.target = target;
    this.strict = strict;
    this.isBound = false;
    this.mode = toView;
    this._isQueued = false;
    this._value = "";
    this._needsRemoveNode = false;
    this.boundFn = false;
    this.l = locator;
    this._controller = controller;
    this.oL = observerLocator;
  }
  updateTarget(value) {
    const target = this.target;
    const oldValue = this._value;
    this._value = value;
    if (this._needsRemoveNode) {
      oldValue.parentNode?.removeChild(oldValue);
      this._needsRemoveNode = false;
    }
    if (value instanceof this.p.Node) {
      target.parentNode?.insertBefore(value, target);
      value = "";
      this._needsRemoveNode = true;
    }
    target.textContent = safeString(value ?? "");
  }
  handleChange() {
    if (!this.isBound)
      return;
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      if (!this.isBound)
        return;
      this.obs.version++;
      const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
      this.obs.clear();
      if (newValue !== this._value) {
        this.updateTarget(newValue);
      }
    });
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      if (!this.isBound)
        return;
      this.obs.version++;
      const v = this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
      this.obs.clear();
      if (isArray(v)) {
        this.observeCollection(v);
      }
      this.updateTarget(v);
    });
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    const v = this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    if (isArray(v)) {
      this.observeCollection(v);
    }
    this.updateTarget(v);
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    if (this._needsRemoveNode) {
      this._value.parentNode?.removeChild(this._value);
    }
    this._scope = void 0;
    this.obs.clearAll();
  }
}
ContentBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(ContentBinding);
  mixingBindingLimited(ContentBinding, () => "updateTarget");
  connectable(ContentBinding, null);
  mixinAstEvaluator(ContentBinding);
});
class LetBinding {
  constructor(locator, observerLocator, ast, targetProperty, toBindingContext, strict) {
    this.ast = ast;
    this.targetProperty = targetProperty;
    this.isBound = false;
    this._scope = void 0;
    this.target = null;
    this.boundFn = false;
    this.l = locator;
    this.oL = observerLocator;
    this.strict = strict;
    this._toBindingContext = toBindingContext;
  }
  updateTarget() {
    this.target[this.targetProperty] = this._value;
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    this._value = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    this.updateTarget();
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope)
        return;
      this.unbind();
    }
    this._scope = _scope;
    this.target = this._toBindingContext ? _scope.bindingContext : _scope.overrideContext;
    astBind(this.ast, _scope, this);
    this._value = astEvaluate(this.ast, this._scope, this, this);
    this.updateTarget();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
}
LetBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(LetBinding);
  mixingBindingLimited(LetBinding, () => "updateTarget");
  connectable(LetBinding, null);
  mixinAstEvaluator(LetBinding);
});
class PropertyBinding {
  constructor(controller, locator, observerLocator, ast, target, targetProperty, mode, strict) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._targetObserver = void 0;
    this._isQueued = false;
    this._targetSubscriber = null;
    this.boundFn = false;
    this.l = locator;
    this._controller = controller;
    this.oL = observerLocator;
  }
  updateTarget(value) {
    this._targetObserver.setValue(value, this.target, this.targetProperty);
  }
  updateSource(value) {
    astAssign(this.ast, this._scope, this, null, value);
  }
  handleChange() {
    if (!this.isBound)
      return;
    const shouldQueue = this._controller.state !== activating && (this._targetObserver.type & atLayout) > 0;
    if (shouldQueue) {
      if (this._isQueued)
        return;
      this._isQueued = true;
      queueTask(() => {
        this._isQueued = false;
        if (!this.isBound)
          return;
        this._handleChange();
      });
    } else {
      this._handleChange();
    }
  }
  /** @internal */
  _handleChange() {
    this.obs.version++;
    const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    this.obs.clear();
    this.updateTarget(newValue);
  }
  // todo: based off collection and handle update accordingly instead off always start
  handleCollectionChange() {
    this.handleChange();
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    const observerLocator = this.oL;
    const $mode = this.mode;
    let targetObserver = this._targetObserver;
    if (!targetObserver) {
      if ($mode & fromView) {
        targetObserver = observerLocator.getObserver(this.target, this.targetProperty);
      } else {
        targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);
      }
      this._targetObserver = targetObserver;
    }
    const shouldConnect = ($mode & toView) > 0;
    if ($mode & (toView | oneTime)) {
      this.updateTarget(astEvaluate(this.ast, this._scope, this, shouldConnect ? this : null));
    }
    if ($mode & fromView) {
      targetObserver.subscribe(this._targetSubscriber ??= new BindingTargetSubscriber(this, this.l.get(IFlushQueue)));
      if (!shouldConnect) {
        this.updateSource(targetObserver.getValue(this.target, this.targetProperty));
      }
    }
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    if (this._targetSubscriber) {
      this._targetObserver.unsubscribe(this._targetSubscriber);
      this._targetSubscriber = null;
    }
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
  /**
   * Start using a given observer to listen to changes on the target of this binding
   */
  useTargetObserver(observer) {
    this._targetObserver?.unsubscribe(this);
    (this._targetObserver = observer).subscribe(this);
  }
  /**
   * Provide a subscriber for target change observation.
   *
   * Binding behaviors can use this to setup custom observation handling during bind lifecycle
   * to alter the update source behavior during bind phase of this binding.
   */
  useTargetSubscriber(subscriber) {
    if (this._targetSubscriber != null) {
      throw createMappedError(
        9995
        /* ErrorNames.binding_already_has_target_subscriber */
      );
    }
    this._targetSubscriber = subscriber;
  }
}
PropertyBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(PropertyBinding);
  mixingBindingLimited(PropertyBinding, (propBinding) => propBinding.mode & fromView ? "updateSource" : "updateTarget");
  connectable(PropertyBinding, null);
  mixinAstEvaluator(PropertyBinding);
});
class RefBinding {
  constructor(locator, oL, ast, target, strict) {
    this.oL = oL;
    this.ast = ast;
    this.target = target;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this.l = locator;
  }
  updateSource() {
    if (this.isBound) {
      this.obs.version++;
      astAssign(this.ast, this._scope, this, this, this.target);
      this.obs.clear();
    } else {
      astAssign(this.ast, this._scope, this, null, null);
    }
  }
  handleChange() {
    if (this.isBound) {
      this.updateSource();
    }
  }
  handleCollectionChange() {
    if (this.isBound) {
      this.updateSource();
    }
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    this.isBound = true;
    this.updateSource();
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this.obs.clearAll();
    if (astEvaluate(this.ast, this._scope, this, null) === this.target) {
      this.updateSource();
    }
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
  }
}
RefBinding.mix = createPrototypeMixer(() => {
  connectable(RefBinding, null);
  mixingBindingLimited(RefBinding, () => "updateSource");
  mixinUseScope(RefBinding);
  mixinAstEvaluator(RefBinding);
});
class ListenerBindingOptions {
  constructor(prevent, capture = false, onError) {
    this.prevent = prevent;
    this.capture = capture;
    this.onError = onError;
  }
}
class ListenerBinding {
  constructor(locator, ast, target, targetEvent, options, modifiedEventHandler, strict) {
    this.ast = ast;
    this.target = target;
    this.targetEvent = targetEvent;
    this.strict = strict;
    this.isBound = false;
    this.self = false;
    this.boundFn = true;
    this._modifiedEventHandler = null;
    this.l = locator;
    this._options = options;
    this._modifiedEventHandler = modifiedEventHandler;
  }
  callSource(event) {
    const overrideContext = this._scope.overrideContext;
    overrideContext.$event = event;
    let result = astEvaluate(this.ast, this._scope, this, null);
    delete overrideContext.$event;
    if (isFunction(result)) {
      result = result(event);
    }
    if (result !== true && this._options.prevent) {
      event.preventDefault();
    }
  }
  handleEvent(event) {
    if (this.self) {
      if (this.target !== event.composedPath()[0]) {
        return;
      }
    }
    if (this._modifiedEventHandler?.(event) !== false) {
      try {
        this.callSource(event);
      } catch (ex) {
        this._options.onError(event, ex);
      }
    }
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    this.target.addEventListener(this.targetEvent, this, this._options);
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.target.removeEventListener(this.targetEvent, this, this._options);
  }
}
ListenerBinding.mix = createPrototypeMixer(function() {
  mixinUseScope(ListenerBinding);
  mixingBindingLimited(ListenerBinding, () => "callSource");
  mixinAstEvaluator(ListenerBinding);
});
const IModifiedEventHandlerCreator = /* @__PURE__ */ createInterface("IEventModifier");
const IKeyMapping = /* @__PURE__ */ createInterface("IKeyMapping", (x) => x.instance({
  meta: objectFreeze(["ctrl", "alt", "shift", "meta"]),
  keys: {
    escape: "Escape",
    enter: "Enter",
    space: "Space",
    tab: "tab",
    // by default, maps the key a-z and A-Z to their respective keycodes
    ...Array.from({ length: 25 }).reduce((acc, _, idx) => {
      let char = String.fromCharCode(idx + 65);
      acc[idx + 65] = char;
      char = String.fromCharCode(idx + 97);
      acc[idx + 97] = acc[char] = char;
      return acc;
    }, {})
  }
}));
class ModifiedMouseEventHandler {
  constructor() {
    this.type = ["click", "mousedown", "mousemove", "mouseup", "dblclick", "contextmenu"];
    this._mapping = resolve(IKeyMapping);
    this._mouseButtons = ["left", "middle", "right"];
  }
  static register(c) {
    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedMouseEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return ((event) => {
      let prevent = false;
      let stop = false;
      let m3;
      for (m3 of modifiers) {
        switch (m3) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
          case "left":
          case "middle":
          case "right":
            if (event.button !== this._mouseButtons.indexOf(m3))
              return false;
            continue;
        }
        if (this._mapping.meta.includes(m3) && event[`${m3}Key`] !== true) {
          return false;
        }
        {
          console.warn(`Modifier '${m3}' is not supported for mouse events.`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    });
  }
}
class ModifiedKeyboardEventHandler {
  constructor() {
    this._mapping = resolve(IKeyMapping);
    this.type = ["keydown", "keyup"];
  }
  static register(c) {
    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedKeyboardEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return ((event) => {
      let prevent = false;
      let stop = false;
      let mod;
      for (mod of modifiers) {
        switch (mod) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
        }
        if (this._mapping.meta.includes(mod)) {
          if (event[`${mod}Key`] !== true) {
            return false;
          }
          continue;
        }
        const mappedKey = this._mapping.keys[mod];
        if (mappedKey !== event.key) {
          return false;
        }
        {
          console.warn(`Modifier '${mod}' is not supported for keyboard event with key "${event.key}".`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    });
  }
}
class ModifiedEventHandler {
  constructor() {
    this.type = ["$ALL"];
  }
  static register(c) {
    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return ((event) => {
      let prevent = false;
      let stop = false;
      let mod;
      for (mod of modifiers) {
        switch (mod) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
        }
        {
          console.warn(`Modifier '${mod}' is not supported for event "${event.type}".`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    });
  }
}
const IEventModifier = /* @__PURE__ */ createInterface("IEventModifierHandler", (x) => x.instance({
  getHandler: () => {
    {
      console.warn("No event modifier handler registered");
    }
    return null;
  }
}));
class EventModifier {
  constructor() {
    this._reg = resolve(all(IModifiedEventHandlerCreator)).reduce((acc, cur) => {
      const types = isArray(cur.type) ? cur.type : [cur.type];
      types.forEach((t) => acc[t] = cur);
      return acc;
    }, {});
  }
  static register(c) {
    c.register(singletonRegistration(IEventModifier, EventModifier));
  }
  getHandler(type, modifier) {
    return isString(modifier) ? (this._reg[type] ?? this._reg.$ALL)?.getHandler(modifier) ?? null : null;
  }
}
const EventModifierRegistration = {
  register(c) {
    c.register(EventModifier, ModifiedMouseEventHandler, ModifiedKeyboardEventHandler, ModifiedEventHandler);
  }
};
const IViewFactory = /* @__PURE__ */ createInterface("IViewFactory");
class ViewFactory {
  constructor(container, def2) {
    this.isCaching = false;
    this._cache = null;
    this._cacheSize = -1;
    this.name = def2.name;
    this.container = container;
    this.def = def2;
  }
  setCacheSize(size, doNotOverrideIfAlreadySet) {
    if (size) {
      if (size === "*") {
        size = ViewFactory.maxCacheSize;
      } else if (isString(size)) {
        size = parseInt(size, 10);
      }
      if (this._cacheSize === -1 || !doNotOverrideIfAlreadySet) {
        this._cacheSize = size;
      }
    }
    if (this._cacheSize > 0) {
      this._cache = [];
    } else {
      this._cache = null;
    }
    this.isCaching = this._cacheSize > 0;
  }
  canReturnToCache(_controller) {
    return this._cache != null && this._cache.length < this._cacheSize;
  }
  tryReturnToCache(controller) {
    if (this.canReturnToCache(controller)) {
      this._cache.push(controller);
      return true;
    }
    return false;
  }
  create(parentController) {
    const cache2 = this._cache;
    let controller;
    if (cache2 != null && cache2.length > 0) {
      controller = cache2.pop();
      return controller;
    }
    controller = Controller.$view(this, parentController);
    return controller;
  }
}
ViewFactory.maxCacheSize = 65535;
const createLocation = /* @__PURE__ */ (() => {
  const createComment = (p, text) => p.document.createComment(text);
  return (p) => {
    const locationEnd = createComment(p, "au-end");
    locationEnd.$start = createComment(p, "au-start");
    return locationEnd;
  };
})();
const insertManyBefore = (parent, target, newChildNodes) => {
  if (parent === null) {
    return;
  }
  const ii = newChildNodes.length;
  let i = 0;
  while (ii > i) {
    parent.insertBefore(newChildNodes[i], target);
    ++i;
  }
};
const createMutationObserver = (node, callback) => new node.ownerDocument.defaultView.MutationObserver(callback);
const isElement$1 = (node) => node.nodeType === 1;
const defaultSlotName = "default";
const auslotAttr = "au-slot";
const IAuSlotsInfo = /* @__PURE__ */ createInterface("IAuSlotsInfo");
class AuSlotsInfo {
  constructor(projectedSlots) {
    this.projectedSlots = projectedSlots;
  }
}
const IAuSlotWatcher = /* @__PURE__ */ createInterface("IAuSlotWatcher");
class SpreadBinding {
  /**
   * Create a list of SpreadBinding by searching for captured attributes in HydrationContexts
   * from a container
   */
  static create(hydrationContext, target, targetDef, rendering, compiler, platform, exprParser, observerLocator) {
    const bindings = [];
    const renderers = rendering.renderers;
    const getHydrationContext = (ancestor) => {
      let currentLevel = ancestor;
      let currentContext = hydrationContext;
      while (currentContext != null && currentLevel > 0) {
        currentContext = currentContext.parent;
        --currentLevel;
      }
      if (currentContext == null) {
        throw createMappedError(
          9999
          /* ErrorNames.no_spread_scope_context_found */
        );
      }
      return currentContext;
    };
    const renderSpreadInstruction = (ancestor) => {
      const context = getHydrationContext(ancestor);
      const spreadBinding = new SpreadBinding(context);
      const instructions = compiler.compileSpread(context.controller.definition, context.instruction?.captures ?? emptyArray, context.controller.container, target, targetDef);
      let inst;
      for (inst of instructions) {
        switch (inst.type) {
          case InstructionType.spreadTransferedBinding:
            renderSpreadInstruction(ancestor + 1);
            break;
          case InstructionType.spreadElementProp:
            renderers[inst.instruction.type].render(spreadBinding, findElementControllerFor(target), inst.instruction, platform, exprParser, observerLocator);
            break;
          default:
            renderers[inst.type].render(spreadBinding, target, inst, platform, exprParser, observerLocator);
        }
      }
      bindings.push(spreadBinding);
    };
    renderSpreadInstruction(0);
    return bindings;
  }
  get container() {
    return this.locator;
  }
  get definition() {
    return this.$controller.definition;
  }
  get state() {
    return this.$controller.state;
  }
  constructor(hydrationContext) {
    this.isBound = false;
    this._innerBindings = [];
    this.locator = (this.$controller = (this._hydrationContext = hydrationContext).controller).container;
  }
  get(key) {
    return this.locator.get(key);
  }
  bind(_scope) {
    if (this.isBound)
      return;
    this.isBound = true;
    const innerScope = this.scope = this._hydrationContext.controller.scope.parent ?? void 0;
    if (innerScope == null) {
      throw createMappedError(
        9999
        /* ErrorNames.no_spread_scope_context_found */
      );
    }
    this._innerBindings.forEach((b) => b.bind(innerScope));
  }
  unbind() {
    this._innerBindings.forEach((b) => b.unbind());
    this.isBound = false;
  }
  addBinding(binding) {
    this._innerBindings.push(binding);
  }
  addChild(controller) {
    if (controller.vmKind !== vmkCa) {
      throw createMappedError(
        9998
        /* ErrorNames.no_spread_template_controller */
      );
    }
    this.$controller.addChild(controller);
  }
}
class SpreadValueBinding {
  constructor(controller, target, targetKeys, ast, ol, l, strict) {
    this.target = target;
    this.targetKeys = targetKeys;
    this.ast = ast;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this.boundFn = false;
    this._bindingCache = {};
    this._scopeCache = /* @__PURE__ */ new WeakMap();
    this._controller = controller;
    this.oL = ol;
    this.l = l;
  }
  updateTarget() {
    this.obs.version++;
    const newValue = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    this._createBindings(newValue, true);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.updateTarget();
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    this.updateTarget();
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this.isBound = true;
    this._scope = scope;
    astBind(this.ast, scope, this);
    const value = astEvaluate(this.ast, scope, this, this);
    this._createBindings(value, false);
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    let key;
    for (key in this._bindingCache) {
      this._bindingCache[key].unbind();
    }
  }
  /**
   * @internal
   */
  _createBindings(value, unbind) {
    let key;
    if (!isObject(value)) {
      {
        console.warn(`[DEV:aurelia] $bindable spread is given a non object for properties: "${this.targetKeys.join(", ")}" of ${this.target.constructor.name}`);
      }
      for (key in this._bindingCache) {
        this._bindingCache[key]?.unbind();
      }
      return;
    }
    let binding;
    let scope = this._scopeCache.get(value);
    if (scope == null) {
      this._scopeCache.set(value, scope = Scope.fromParent(this._scope, value));
    }
    for (key of this.targetKeys) {
      binding = this._bindingCache[key];
      if (key in value) {
        if (binding == null) {
          binding = this._bindingCache[key] = new PropertyBinding(this._controller, this.l, this.oL, SpreadValueBinding._astCache[key] ??= new AccessScopeExpression(key, 0), this.target, key, BindingMode.toView, this.strict);
        }
        binding.bind(scope);
      } else if (unbind) {
        binding?.unbind();
      }
    }
  }
}
SpreadValueBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(SpreadValueBinding);
  mixingBindingLimited(SpreadValueBinding, () => "updateTarget");
  connectable(SpreadValueBinding, null);
  mixinAstEvaluator(SpreadValueBinding);
});
SpreadValueBinding._astCache = {};
const addListener = (target, name2, handler, options) => {
  target.addEventListener(name2, handler, options);
};
const removeListener = (target, name2, handler, options) => {
  target.removeEventListener(name2, handler, options);
};
const mixinNodeObserverUseConfig = (target) => {
  let event;
  const prototype = target.prototype;
  defineHiddenProp(prototype, "subscribe", function(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      for (event of this._config.events) {
        addListener(this._el, event, this);
      }
      this._listened = true;
      this._start?.();
    }
  });
  defineHiddenProp(prototype, "unsubscribe", function(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      for (event of this._config.events) {
        removeListener(this._el, event, this);
      }
      this._listened = false;
      this._stop?.();
    }
  });
  defineHiddenProp(prototype, "useConfig", function(config) {
    this._config = config;
    if (this._listened) {
      for (event of this._config.events) {
        removeListener(this._el, event, this);
      }
      for (event of this._config.events) {
        addListener(this._el, event, this);
      }
    }
  });
};
const mixinNoopSubscribable = (target) => {
  defineHiddenProp(target.prototype, "subscribe", noop);
  defineHiddenProp(target.prototype, "unsubscribe", noop);
};
class ClassAttributeAccessor {
  get doNotCache() {
    return true;
  }
  constructor(obj, mapping = {}) {
    this.obj = obj;
    this.mapping = mapping;
    this.type = atNode | atLayout;
    this._value = "";
    this._nameIndex = {};
    this._version = 0;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (newValue !== this._value) {
      this._value = newValue;
      this._flushChanges();
    }
  }
  /** @internal */
  _flushChanges() {
    const nameIndex = this._nameIndex;
    const version = ++this._version;
    const classList = this.obj.classList;
    const classesToAdd = getClassesToAdd(this._value);
    const ii = classesToAdd.length;
    let i = 0;
    let name2;
    if (ii > 0) {
      for (; i < ii; i++) {
        name2 = classesToAdd[i];
        name2 = this.mapping[name2] || name2;
        if (name2.length === 0) {
          continue;
        }
        nameIndex[name2] = this._version;
        classList.add(name2);
      }
    }
    if (version === 1) {
      return;
    }
    for (name2 in nameIndex) {
      name2 = this.mapping[name2] || name2;
      if (nameIndex[name2] === version) {
        continue;
      }
      classList.remove(name2);
    }
  }
}
(() => {
  mixinNoopSubscribable(ClassAttributeAccessor);
})();
function getClassesToAdd(object) {
  if (isString(object)) {
    return splitClassString(object);
  }
  if (typeof object !== "object") {
    return emptyArray;
  }
  if (isArray(object)) {
    const len = object.length;
    if (len > 0) {
      const classes2 = [];
      let i = 0;
      for (; len > i; ++i) {
        classes2.push(...getClassesToAdd(object[i]));
      }
      return classes2;
    } else {
      return emptyArray;
    }
  }
  const classes = [];
  let property;
  for (property in object) {
    if (Boolean(object[property])) {
      if (property.includes(" ")) {
        classes.push(...splitClassString(property));
      } else {
        classes.push(property);
      }
    }
  }
  return classes;
}
function splitClassString(classString) {
  const matches = classString.match(/\S+/g);
  if (matches === null) {
    return emptyArray;
  }
  return matches;
}
const fromHydrationContext = (key) => ({
  $isResolver: true,
  resolve(_, requestor) {
    return requestor.get(IHydrationContext).controller.container.get(own(key));
  }
});
const IRenderer = /* @__PURE__ */ createInterface("IRenderer");
function renderer(target, context) {
  const metadata = target[Symbol.metadata] ??= /* @__PURE__ */ Object.create(null);
  metadata[registrableMetadataKey] = {
    register(container) {
      singletonRegistration(IRenderer, target).register(container);
    }
  };
  return target;
}
function ensureExpression(parser, srcOrExpr, expressionType) {
  if (isString(srcOrExpr)) {
    return parser.parse(srcOrExpr, expressionType);
  }
  return srcOrExpr;
}
function getTarget(potentialTarget) {
  if (potentialTarget.viewModel != null) {
    return potentialTarget.viewModel;
  }
  return potentialTarget;
}
function getRefTarget(refHost, refTargetName) {
  if (refTargetName === "element") {
    return refHost;
  }
  switch (refTargetName) {
    case "controller":
      return findElementControllerFor(refHost);
    case "view":
      throw createMappedError(
        750
        /* ErrorNames.not_supported_view_ref_api */
      );
    case "component":
      return findElementControllerFor(refHost).viewModel;
    default: {
      const caController = findAttributeControllerFor(refHost, refTargetName);
      if (caController !== void 0) {
        return caController.viewModel;
      }
      const ceController = findElementControllerFor(refHost, { name: refTargetName });
      if (ceController === void 0) {
        throw createMappedError(751, refTargetName);
      }
      return ceController.viewModel;
    }
  }
}
const SetPropertyRenderer = /* @__PURE__ */ renderer(class SetPropertyRenderer2 {
  constructor() {
    this.target = InstructionType.setProperty;
  }
  render(renderingCtrl, target, instruction) {
    const obj = getTarget(target);
    if (obj.$observers?.[instruction.to] !== void 0) {
      obj.$observers[instruction.to].setValue(instruction.value);
    } else {
      obj[instruction.to] = instruction.value;
    }
  }
});
const CustomElementRenderer = /* @__PURE__ */ renderer(class CustomElementRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateElement;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let def2;
    let component;
    let childCtrl;
    const res = instruction.res;
    const projections = instruction.projections;
    const ctxContainer = renderingCtrl.container;
    switch (typeof res) {
      case "string":
        def2 = CustomElement.find(ctxContainer, res);
        if (def2 == null) {
          throw createMappedError(752, instruction, renderingCtrl);
        }
        break;
      // constructor based instruction
      // will be enabled later if needed.
      // As both AOT + runtime based can use definition for perf
      // -----------------
      // case 'function':
      //   def = CustomElement.getDefinition(res);
      //   break;
      default:
        def2 = res;
    }
    const containerless = instruction.containerless || def2.containerless;
    const location = containerless ? convertToRenderLocation(target) : null;
    const container = createElementContainer(
      /* platform         */
      platform,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* location         */
      location,
      /* SlotsInfo      */
      projections == null ? void 0 : new AuSlotsInfo(objectKeys(projections))
    );
    component = container.invoke(def2.Type);
    childCtrl = Controller.$el(
      /* own container       */
      container,
      /* viewModel           */
      component,
      /* host                */
      target,
      /* instruction         */
      instruction,
      /* definition          */
      def2,
      /* location            */
      location
    );
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i = 0;
    let propInst;
    while (ii > i) {
      propInst = props2[i];
      renderers[propInst.type].render(renderingCtrl, childCtrl, propInst, platform, exprParser, observerLocator);
      ++i;
    }
    renderingCtrl.addChild(childCtrl);
  }
});
const CustomAttributeRenderer = /* @__PURE__ */ renderer(class CustomAttributeRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateAttribute;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let ctxContainer = renderingCtrl.container;
    let def2;
    switch (typeof instruction.res) {
      case "string":
        def2 = CustomAttribute.find(ctxContainer, instruction.res);
        if (def2 == null) {
          throw createMappedError(753, instruction, renderingCtrl);
        }
        break;
      // constructor based instruction
      // will be enabled later if needed.
      // As both AOT + runtime based can use definition for perf
      // -----------------
      // case 'function':
      //   def = CustomAttribute.getDefinition(instruction.res);
      //   break;
      default:
        def2 = instruction.res;
    }
    const results = invokeAttribute(
      /* platform         */
      platform,
      /* attr definition  */
      def2,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* viewFactory      */
      void 0,
      /* location         */
      void 0
    );
    const childController = Controller.$attr(
      /* context ct */
      results.ctn,
      /* viewModel  */
      results.vm,
      /* host       */
      target,
      /* definition */
      def2
    );
    refs.set(target, def2.key, childController);
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i = 0;
    let propInst;
    while (ii > i) {
      propInst = props2[i];
      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);
      ++i;
    }
    renderingCtrl.addChild(childController);
  }
});
const TemplateControllerRenderer = /* @__PURE__ */ renderer(class TemplateControllerRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateTemplateController;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let ctxContainer = renderingCtrl.container;
    let def2;
    switch (typeof instruction.res) {
      case "string":
        def2 = CustomAttribute.find(ctxContainer, instruction.res);
        if (def2 == null) {
          throw createMappedError(754, instruction, renderingCtrl);
        }
        break;
      // constructor based instruction
      // will be enabled later if needed.
      // As both AOT + runtime based can use definition for perf
      // -----------------
      // case 'function':
      //   def = CustomAttribute.getDefinition(instruction.res);
      //   break;
      default:
        def2 = instruction.res;
    }
    const viewFactory = this._rendering.getViewFactory(instruction.def, def2.containerStrategy === "new" ? ctxContainer.createChild({ inheritParentResources: true }) : ctxContainer);
    const renderLocation = convertToRenderLocation(target);
    const results = invokeAttribute(
      /* platform         */
      platform,
      /* attr definition  */
      def2,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* viewFactory      */
      viewFactory,
      /* location         */
      renderLocation
    );
    const childController = Controller.$attr(
      /* container ct */
      results.ctn,
      /* viewModel    */
      results.vm,
      /* host         */
      target,
      /* definition   */
      def2
    );
    refs.set(renderLocation, def2.key, childController);
    results.vm.link?.(renderingCtrl, childController, target, instruction);
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i = 0;
    let propInst;
    while (ii > i) {
      propInst = props2[i];
      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);
      ++i;
    }
    renderingCtrl.addChild(childController);
  }
});
const LetElementRenderer = /* @__PURE__ */ renderer(class LetElementRenderer2 {
  constructor() {
    this.target = InstructionType.hydrateLetElement;
    LetBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    target.remove();
    const childInstructions = instruction.instructions;
    const toBindingContext = instruction.toBindingContext;
    const container = renderingCtrl.container;
    const ii = childInstructions.length;
    let childInstruction;
    let expr;
    let i = 0;
    while (ii > i) {
      childInstruction = childInstructions[i];
      expr = ensureExpression(exprParser, childInstruction.from, etIsProperty);
      renderingCtrl.addBinding(new LetBinding(container, observerLocator, expr, childInstruction.to, toBindingContext, renderingCtrl.strict ?? false));
      ++i;
    }
  }
});
const RefBindingRenderer = /* @__PURE__ */ renderer(class RefBindingRenderer2 {
  constructor() {
    this.target = InstructionType.refBinding;
    RefBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new RefBinding(renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), getRefTarget(target, instruction.to), renderingCtrl.strict ?? false));
  }
});
const InterpolationBindingRenderer = /* @__PURE__ */ renderer(class InterpolationBindingRenderer2 {
  constructor() {
    this.target = InstructionType.interpolation;
    InterpolationPartBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const binding = new InterpolationBinding(renderingCtrl, container, observerLocator, ensureExpression(exprParser, instruction.from, etInterpolation), getTarget(target), instruction.to, toView, renderingCtrl.strict ?? false);
    if (instruction.to === "class" && binding.target.nodeType > 0) {
      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));
      binding.useAccessor(new ClassAttributeAccessor(binding.target, cssMapping));
    }
    renderingCtrl.addBinding(binding);
  }
});
const PropertyBindingRenderer = /* @__PURE__ */ renderer(class PropertyBindingRenderer2 {
  constructor() {
    this.target = InstructionType.propertyBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const binding = new PropertyBinding(renderingCtrl, container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), getTarget(target), instruction.to, instruction.mode, renderingCtrl.strict ?? false);
    if (instruction.to === "class" && binding.target.nodeType > 0) {
      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));
      binding.useTargetObserver(new ClassAttributeAccessor(binding.target, cssMapping));
    }
    renderingCtrl.addBinding(binding);
  }
});
const IteratorBindingRenderer = /* @__PURE__ */ renderer(class IteratorBindingRenderer2 {
  constructor() {
    this.target = InstructionType.iteratorBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new PropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.forOf, etIsIterator), getTarget(target), instruction.to, toView, renderingCtrl.strict ?? false));
  }
});
const TextBindingRenderer = /* @__PURE__ */ renderer(class TextBindingRenderer2 {
  constructor() {
    this.target = InstructionType.textBinding;
    ContentBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new ContentBinding(renderingCtrl, renderingCtrl.container, observerLocator, platform, ensureExpression(exprParser, instruction.from, etIsProperty), target, renderingCtrl.strict ?? false));
  }
});
const IListenerBindingOptions = createInterface("IListenerBindingOptions", (x) => x.singleton(class {
  constructor() {
    this.p = resolve(IPlatform);
    this.prevent = false;
    this.onError = (event, error2) => {
      const errorEvent = new this.p.CustomEvent("au-event-error", { cancelable: true, detail: { event, error: error2 } });
      this.p.window.dispatchEvent(errorEvent);
      if (errorEvent.defaultPrevented) {
        return;
      }
      throw error2;
    };
  }
}));
const ListenerBindingRenderer = /* @__PURE__ */ renderer(class ListenerBindingRenderer2 {
  constructor() {
    this.target = InstructionType.listenerBinding;
    this._modifierHandler = resolve(IEventModifier);
    this._defaultOptions = resolve(IListenerBindingOptions);
    ListenerBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser) {
    renderingCtrl.addBinding(new ListenerBinding(renderingCtrl.container, ensureExpression(exprParser, instruction.from, etIsFunction), target, instruction.to, new ListenerBindingOptions(this._defaultOptions.prevent, instruction.capture, this._defaultOptions.onError), this._modifierHandler.getHandler(instruction.to, instruction.modifier), renderingCtrl.strict ?? false));
  }
});
const SetAttributeRenderer = /* @__PURE__ */ renderer(class SetAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setAttribute;
  }
  render(_, target, instruction) {
    target.setAttribute(instruction.to, instruction.value);
  }
});
const SetClassAttributeRenderer = /* @__PURE__ */ renderer(class SetClassAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setClassAttribute;
  }
  render(_, target, instruction) {
    addClasses(target.classList, instruction.value);
  }
});
const SetStyleAttributeRenderer = /* @__PURE__ */ renderer(class SetStyleAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setStyleAttribute;
  }
  render(_, target, instruction) {
    target.style.cssText += instruction.value;
  }
});
const ambiguousStyles = [
  "height",
  "width",
  "border-width",
  "padding",
  "padding-left",
  "padding-right",
  "padding-top",
  "padding-right",
  "padding-inline",
  "padding-block",
  "margin",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-bottom",
  "margin-inline",
  "margin-block",
  "top",
  "right",
  "bottom",
  "left"
];
const StylePropertyBindingRenderer = /* @__PURE__ */ renderer(class StylePropertyBindingRenderer2 {
  constructor() {
    this.target = InstructionType.stylePropertyBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    {
      if (ambiguousStyles.includes(instruction.to)) {
        renderingCtrl.addBinding(new DevStylePropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), target.style, instruction.to, toView, renderingCtrl.strict ?? false));
        return;
      }
    }
    renderingCtrl.addBinding(new PropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), target.style, instruction.to, toView, renderingCtrl.strict ?? false));
  }
});
class DevStylePropertyBinding extends PropertyBinding {
  updateTarget(value) {
    if (typeof value === "number" && value > 0) {
      console.warn(`[DEV]: Setting number ${value} as value for style.${this.targetProperty}. Did you meant "${value}px"?`);
    }
    return super.updateTarget(value);
  }
}
const AttributeBindingRenderer = /* @__PURE__ */ renderer(class AttributeBindingRenderer2 {
  constructor() {
    this.target = InstructionType.attributeBinding;
    AttributeBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const classMapping = container.has(ICssClassMapping, false) ? container.get(ICssClassMapping) : null;
    renderingCtrl.addBinding(new AttributeBinding(renderingCtrl, container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), target, instruction.attr, classMapping == null ? instruction.to : instruction.to.split(/\s/g).map((c) => classMapping[c] ?? c).join(" "), toView, renderingCtrl.strict ?? false));
  }
});
const SpreadRenderer = /* @__PURE__ */ renderer(class SpreadRenderer2 {
  constructor() {
    this._compiler = resolve(ITemplateCompiler);
    this._rendering = resolve(IRendering);
    this.target = InstructionType.spreadTransferedBinding;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    SpreadBinding.create(renderingCtrl.container.get(IHydrationContext), target, void 0, this._rendering, this._compiler, platform, exprParser, observerLocator).forEach((b) => renderingCtrl.addBinding(b));
  }
});
const SpreadValueRenderer = /* @__PURE__ */ renderer(class SpreadValueRenderer2 {
  constructor() {
    this.target = InstructionType.spreadValueBinding;
    SpreadValueBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const instructionTarget = instruction.target;
    if (instructionTarget === "$bindables") {
      renderingCtrl.addBinding(new SpreadValueBinding(renderingCtrl, target.viewModel, objectKeys(target.definition.bindables), exprParser.parse(instruction.from, etIsProperty), observerLocator, renderingCtrl.container, renderingCtrl.strict ?? false));
    } else {
      throw createMappedError(820, instructionTarget);
    }
  }
});
function addClasses(classList, className) {
  const len = className.length;
  let start2 = 0;
  for (let i = 0; i < len; ++i) {
    if (className.charCodeAt(i) === 32) {
      if (i !== start2) {
        classList.add(className.slice(start2, i));
      }
      start2 = i + 1;
    } else if (i + 1 === len) {
      classList.add(className.slice(start2));
    }
  }
}
const controllerProviderName = "IController";
const instructionProviderName = "IInstruction";
const locationProviderName = "IRenderLocation";
const slotInfoProviderName = "ISlotsInfo";
function createElementContainer(p, renderingCtrl, host, instruction, location, auSlotsInfo) {
  const ctn = renderingCtrl.container.createChild();
  registerHostNode(ctn, host, p);
  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));
  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));
  registerResolver(ctn, IRenderLocation, location == null ? noLocationProvider : new RenderLocationProvider(location));
  registerResolver(ctn, IViewFactory, noViewFactoryProvider);
  registerResolver(ctn, IAuSlotsInfo, auSlotsInfo == null ? noAuSlotProvider : new InstanceProvider(slotInfoProviderName, auSlotsInfo));
  return ctn;
}
class ViewFactoryProvider {
  get $isResolver() {
    return true;
  }
  constructor(factory) {
    this.f = factory;
  }
  resolve() {
    const f = this.f;
    if (f === null) {
      throw createMappedError(
        755
        /* ErrorNames.view_factory_provider_not_ready */
      );
    }
    if (!isString(f.name) || f.name.length === 0) {
      throw createMappedError(
        756
        /* ErrorNames.view_factory_invalid_name */
      );
    }
    return f;
  }
}
function invokeAttribute(p, definition, $renderingCtrl, host, instruction, viewFactory, location, auSlotsInfo) {
  const renderingCtrl = $renderingCtrl instanceof Controller ? $renderingCtrl : $renderingCtrl.$controller;
  const ctn = renderingCtrl.container.createChild();
  registerHostNode(ctn, host, p);
  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));
  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));
  registerResolver(ctn, IRenderLocation, location == null ? noLocationProvider : new InstanceProvider(locationProviderName, location));
  registerResolver(ctn, IViewFactory, viewFactory == null ? noViewFactoryProvider : new ViewFactoryProvider(viewFactory));
  registerResolver(
    ctn,
    IAuSlotsInfo,
    noAuSlotProvider
  );
  return { vm: ctn.invoke(definition.Type), ctn };
}
class RenderLocationProvider {
  get name() {
    return "IRenderLocation";
  }
  get $isResolver() {
    return true;
  }
  constructor(_location) {
    this._location = _location;
  }
  resolve() {
    return this._location;
  }
}
const noLocationProvider = new RenderLocationProvider(null);
const noViewFactoryProvider = new ViewFactoryProvider(null);
const noAuSlotProvider = new InstanceProvider(slotInfoProviderName, new AuSlotsInfo(emptyArray));
const IRendering = /* @__PURE__ */ createInterface("IRendering", (x) => x.singleton(Rendering));
class Rendering {
  get renderers() {
    return this._renderers ??= this._ctn.getAll(IRenderer, false).reduce((all2, r) => {
      {
        if (all2[r.target] !== void 0) {
          console.warn(`[DEV:aurelia] Renderer for target ${r.target} already exists.`);
        }
      }
      all2[r.target] ??= r;
      return all2;
    }, createLookup$1());
  }
  constructor() {
    this._compilationCache = /* @__PURE__ */ new WeakMap();
    this._fragmentCache = /* @__PURE__ */ new WeakMap();
    const ctn = this._ctn = resolve(IContainer).root;
    const p = this._platform = ctn.get(IPlatform);
    this._exprParser = ctn.get(IExpressionParser);
    this._observerLocator = ctn.get(IObserverLocator);
    this._marker = p.document.createElement("au-m");
    this._empty = new FragmentNodeSequence(p, p.document.createDocumentFragment());
  }
  compile(definition, container) {
    const compiler = container.get(ITemplateCompiler);
    const compiledMap = this._compilationCache;
    let compiled = compiledMap.get(definition);
    if (compiled == null) {
      compiledMap.set(definition, compiled = CustomElementDefinition.create(definition.needsCompile ? compiler.compile(definition, container) : definition));
    }
    return compiled;
  }
  getViewFactory(definition, container) {
    return new ViewFactory(container, CustomElementDefinition.getOrCreate(definition));
  }
  createNodes(definition) {
    if (definition.enhance === true) {
      return new FragmentNodeSequence(this._platform, this._transformMarker(definition.template));
    }
    let fragment;
    let needsImportNode = false;
    const cache2 = this._fragmentCache;
    const p = this._platform;
    const doc = p.document;
    if (cache2.has(definition)) {
      fragment = cache2.get(definition);
    } else {
      const template2 = definition.template;
      let tpl;
      if (template2 == null) {
        fragment = null;
      } else if (template2 instanceof p.Node) {
        if (template2.nodeName === "TEMPLATE") {
          fragment = template2.content;
          needsImportNode = true;
        } else {
          (fragment = doc.createDocumentFragment()).appendChild(template2.cloneNode(true));
        }
      } else {
        tpl = doc.createElement("template");
        if (isString(template2)) {
          tpl.innerHTML = template2;
        }
        fragment = tpl.content;
        needsImportNode = true;
      }
      this._transformMarker(fragment);
      cache2.set(definition, fragment);
    }
    return fragment == null ? this._empty : new FragmentNodeSequence(this._platform, needsImportNode ? doc.importNode(fragment, true) : doc.adoptNode(fragment.cloneNode(true)));
  }
  render(controller, targets, definition, host) {
    const rows = definition.instructions;
    const renderers = this.renderers;
    const ii = targets.length;
    let i = 0;
    let j = 0;
    let jj = rows.length;
    let row;
    let instruction;
    let target;
    if (ii !== jj) {
      throw createMappedError(757, ii, jj);
    }
    if (host != null) {
      row = definition.surrogates;
      if ((jj = row.length) > 0) {
        j = 0;
        while (jj > j) {
          instruction = row[j];
          renderers[instruction.type].render(controller, host, instruction, this._platform, this._exprParser, this._observerLocator);
          ++j;
        }
      }
    }
    if (ii > 0) {
      while (ii > i) {
        row = rows[i];
        target = targets[i];
        j = 0;
        jj = row.length;
        while (jj > j) {
          instruction = row[j];
          renderers[instruction.type].render(controller, target, instruction, this._platform, this._exprParser, this._observerLocator);
          ++j;
        }
        ++i;
      }
    }
  }
  /** @internal */
  _transformMarker(fragment) {
    if (fragment == null) {
      return null;
    }
    const walker = this._platform.document.createTreeWalker(
      fragment,
      /* NodeFilter.SHOW_COMMENT */
      128
    );
    let currentNode;
    while ((currentNode = walker.nextNode()) != null) {
      if (currentNode.nodeValue === "au*") {
        currentNode.parentNode.replaceChild(walker.currentNode = this._marker.cloneNode(), currentNode);
      }
    }
    return fragment;
  }
}
const IShadowDOMStyles = /* @__PURE__ */ createInterface("IShadowDOMStyles");
const IShadowDOMGlobalStyles = /* @__PURE__ */ createInterface("IShadowDOMGlobalStyles", (x) => x.instance({ applyTo: noop }));
const { enter, exit } = ConnectableSwitcher;
const { wrap, unwrap } = ProxyObservable;
class ComputedWatcher {
  get value() {
    return this._value;
  }
  constructor(obj, observerLocator, $get, cb, flush = "async") {
    this.obj = obj;
    this.$get = $get;
    this.isBound = false;
    this._isQueued = false;
    this._computeDepth = 0;
    this._value = void 0;
    this._callback = cb;
    this.oL = observerLocator;
    this._flush = flush;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    if (this.isBound)
      return;
    this.compute();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this.obs.clearAll();
  }
  run() {
    if (!this.isBound)
      return;
    if (this._flush === "sync") {
      this._run();
      return;
    }
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      this._run();
    });
  }
  /** @internal */
  _run() {
    if (!this.isBound)
      return;
    const obj = this.obj;
    const oldValue = this._value;
    if (++this._computeDepth > 100) {
      throw new Error(`AURXXXX: Possible infinitely recursive side-effect detected in a watcher.`);
    }
    const newValue = this.compute();
    if (!areEqual(newValue, oldValue)) {
      this._callback.call(obj, newValue, oldValue, obj);
    }
    if (!this._isQueued) {
      this._computeDepth = 0;
    }
  }
  compute() {
    this.obs.version++;
    try {
      enter(this);
      return this._value = unwrap(this.$get.call(void 0, wrap(this.obj), this));
    } finally {
      this.obs.clear();
      exit(this);
    }
  }
}
(() => {
  connectable(ComputedWatcher, null);
})();
class ExpressionWatcher {
  get value() {
    return this._value;
  }
  constructor(scope, l, oL, expression, callback, flush = "async") {
    this.scope = scope;
    this.l = l;
    this.oL = oL;
    this.isBound = false;
    this._isQueued = false;
    this.boundFn = false;
    this.obj = scope.bindingContext;
    this._expression = expression;
    this._callback = callback;
    this._flush = flush;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  run() {
    if (!this.isBound)
      return;
    if (this._flush === "sync") {
      this._run();
      return;
    }
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      this._run();
    });
  }
  /** @internal */
  _run() {
    if (!this.isBound)
      return;
    const expr = this._expression;
    const obj = this.obj;
    const oldValue = this._value;
    this.obs.version++;
    const value = astEvaluate(expr, this.scope, this, this);
    this.obs.clear();
    if (!areEqual(value, oldValue)) {
      this._value = value;
      this._callback.call(obj, value, oldValue, obj);
    }
  }
  bind() {
    if (this.isBound)
      return;
    this.obs.version++;
    this._value = astEvaluate(this._expression, this.scope, this, this);
    this.obs.clear();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this.obs.clearAll();
    this._value = void 0;
  }
}
(() => {
  connectable(ExpressionWatcher, null);
  mixinAstEvaluator(ExpressionWatcher);
})();
class Controller {
  get lifecycleHooks() {
    return this._lifecycleHooks;
  }
  get isActive() {
    return (this.state & (activating | activated)) > 0 && (this.state & deactivating) === 0;
  }
  get name() {
    if (this.parent === null) {
      switch (this.vmKind) {
        case vmkCa:
          return `[${this.definition.name}]`;
        case vmkCe:
          return this.definition.name;
        case vmkSynth:
          return this.viewFactory.name;
      }
    }
    switch (this.vmKind) {
      case vmkCa:
        return `${this.parent.name}>[${this.definition.name}]`;
      case vmkCe:
        return `${this.parent.name}>${this.definition.name}`;
      case vmkSynth:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get viewModel() {
    return this._vm;
  }
  set viewModel(v) {
    this._vm = v;
    this._vmHooks = v == null || this.vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(v);
  }
  get strict() {
    return this.definition?.strict;
  }
  constructor(container, vmKind, definition, viewFactory, viewModel, host, location) {
    this.container = container;
    this.vmKind = vmKind;
    this.definition = definition;
    this.viewFactory = viewFactory;
    this.host = host;
    this.head = null;
    this.tail = null;
    this.next = null;
    this.parent = null;
    this.bindings = null;
    this.children = null;
    this.hasLockedScope = false;
    this.scope = null;
    this.isBound = false;
    this._isBindingDone = false;
    this.mountTarget = targetNone;
    this.shadowRoot = null;
    this.nodes = null;
    this.location = null;
    this._lifecycleHooks = null;
    this.state = none;
    this._fullyNamed = false;
    this.$initiator = null;
    this.$resolve = void 0;
    this.$reject = void 0;
    this.$promise = void 0;
    this._activatingStack = 0;
    this._detachingStack = 0;
    this._unbindingStack = 0;
    this._vm = viewModel;
    this._vmHooks = vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(viewModel);
    {
      this.logger = null;
      this.debug = false;
    }
    this.location = location;
    this._rendering = container.root.get(IRendering);
  }
  static getCached(viewModel) {
    return controllerLookup.get(viewModel);
  }
  static getCachedOrThrow(viewModel) {
    const $el = Controller.getCached(viewModel);
    if ($el === void 0) {
      throw createMappedError(500, viewModel);
    }
    return $el;
  }
  /**
   * Create a controller for a custom element based on a given set of parameters
   *
   * @param ctn - The own container of the custom element
   * @param viewModel - The view model object (can be any object if a definition is specified)
   *
   * Semi private API
   */
  static $el(ctn, viewModel, host, hydrationInst, definition = void 0, location = null) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }
    {
      if (definition == null) {
        try {
          definition = getElementDefinition(viewModel.constructor);
        } catch (ex) {
          console.error(`[DEV:aurelia] Custom element definition not found for creating a controller with host: <${host.nodeName} /> and component ${viewModel.constructor.name || "(Anonymous) class"}`);
          throw ex;
        }
      }
    }
    registerResolver(ctn, definition.Type, new InstanceProvider(definition.key, viewModel, definition.Type));
    const controller = new Controller(
      /* container      */
      ctn,
      /* vmKind         */
      vmkCe,
      /* definition     */
      definition,
      /* viewFactory    */
      null,
      /* viewModel      */
      viewModel,
      /* host           */
      host,
      /* location       */
      location
    );
    const hydrationContext = ctn.get(optional(IHydrationContext));
    if (definition.dependencies.length > 0) {
      ctn.register(...definition.dependencies);
    }
    registerResolver(ctn, IHydrationContext, new InstanceProvider("IHydrationContext", new HydrationContext(controller, hydrationInst, hydrationContext)));
    controllerLookup.set(viewModel, controller);
    if (hydrationInst == null || hydrationInst.hydrate !== false) {
      controller._hydrateCustomElement(hydrationInst);
    }
    return controller;
  }
  /**
   * Create a controller for a custom attribute based on a given set of parameters
   *
   * @param ctn - own container associated with the custom attribute object
   * @param viewModel - the view model object
   * @param host - host element where this custom attribute is used
   * @param flags - todo(comment)
   * @param definition - the definition of the custom attribute,
   * will be used to override the definition associated with the view model object contructor if given
   */
  static $attr(ctn, viewModel, host, definition) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }
    definition = definition ?? getAttributeDefinition(viewModel.constructor);
    registerResolver(ctn, definition.Type, new InstanceProvider(definition.key, viewModel, definition.Type));
    const controller = new Controller(
      /* own ct         */
      ctn,
      /* vmKind         */
      vmkCa,
      /* definition     */
      definition,
      /* viewFactory    */
      null,
      /* viewModel      */
      viewModel,
      /* host           */
      host,
      /* location       */
      null
    );
    if (definition.dependencies.length > 0) {
      ctn.register(...definition.dependencies);
    }
    controllerLookup.set(viewModel, controller);
    controller._hydrateCustomAttribute();
    return controller;
  }
  /**
   * Create a synthetic view (controller) for a given factory
   *
   * @param viewFactory - todo(comment)
   * @param flags - todo(comment)
   * @param parentController - the parent controller to connect the created view with. Used in activation
   *
   * Semi private API
   */
  static $view(viewFactory, parentController = void 0) {
    const controller = new Controller(
      /* container      */
      viewFactory.container,
      /* vmKind         */
      vmkSynth,
      /* definition     */
      null,
      /* viewFactory    */
      viewFactory,
      /* viewModel      */
      null,
      /* host           */
      null,
      /* location       */
      null
    );
    controller.parent = parentController ?? null;
    controller._hydrateSynthetic();
    return controller;
  }
  /** @internal */
  _hydrateCustomElement(hydrationInst) {
    {
      this.logger = this.container.get(ILogger).root;
      this.debug = this.logger.config.level <= LogLevel.debug;
      if (this.debug) {
        this.logger = this.logger.scopeTo(this.name);
      }
    }
    const container = this.container;
    const instance = this._vm;
    const definition = this.definition;
    this.scope = Scope.create(instance, null, true);
    if (definition.watches.length > 0) {
      createWatchers(this, container, definition, instance);
    }
    createObservers(this, definition, instance);
    this._lifecycleHooks = LifecycleHooks.resolve(container);
    container.register(definition.Type);
    if (definition.injectable !== null) {
      registerResolver(container, definition.injectable, new InstanceProvider("definition.injectable", instance));
    }
    if (hydrationInst == null || hydrationInst.hydrate !== false) {
      this._hydrate();
      this._hydrateChildren();
    }
  }
  /** @internal */
  _hydrate() {
    if (this._lifecycleHooks.hydrating != null) {
      this._lifecycleHooks.hydrating.forEach(callHydratingHook, this);
    }
    if (this._vmHooks._hydrating) {
      if (this.debug) {
        this.logger.trace(`invoking hydrating() hook`);
      }
      this._vm.hydrating(this);
    }
    const definition = this.definition;
    const compiledDef = this._compiledDef = this._rendering.compile(definition, this.container);
    const shadowOptions = compiledDef.shadowOptions;
    const hasSlots = compiledDef.hasSlots;
    const containerless = compiledDef.containerless;
    const host = this.host;
    let location = this.location;
    if (containerless && location == null) {
      location = this.location = convertToRenderLocation(host);
    }
    setRef(host, elementBaseName, this);
    setRef(host, definition.key, this);
    if (shadowOptions !== null || hasSlots) {
      if (location != null) {
        throw createMappedError(
          501
          /* ErrorNames.controller_no_shadow_on_containerless */
        );
      }
      setRef(this.shadowRoot = host.attachShadow(shadowOptions ?? defaultShadowOptions), elementBaseName, this);
      setRef(this.shadowRoot, definition.key, this);
      this.mountTarget = targetShadowRoot;
    } else if (location != null) {
      if (host !== location) {
        setRef(location, elementBaseName, this);
        setRef(location, definition.key, this);
      }
      this.mountTarget = targetLocation;
    } else {
      this.mountTarget = targetHost;
    }
    this._vm.$controller = this;
    this.nodes = this._rendering.createNodes(compiledDef);
    if (this._lifecycleHooks.hydrated !== void 0) {
      this._lifecycleHooks.hydrated.forEach(callHydratedHook, this);
    }
    if (this._vmHooks._hydrated) {
      if (this.debug) {
        this.logger.trace(`invoking hydrated() hook`);
      }
      this._vm.hydrated(this);
    }
  }
  /** @internal */
  _hydrateChildren() {
    this._rendering.render(
      /* controller */
      this,
      /* targets    */
      this.nodes.findTargets(),
      /* definition */
      this._compiledDef,
      /* host       */
      this.host
    );
    if (this._lifecycleHooks.created !== void 0) {
      this._lifecycleHooks.created.forEach(callCreatedHook, this);
    }
    if (this._vmHooks._created) {
      if (this.debug) {
        this.logger.trace(`invoking created() hook`);
      }
      this._vm.created(this);
    }
  }
  /** @internal */
  _hydrateCustomAttribute() {
    const definition = this.definition;
    const instance = this._vm;
    if (definition.watches.length > 0) {
      createWatchers(this, this.container, definition, instance);
    }
    createObservers(this, definition, instance);
    instance.$controller = this;
    this._lifecycleHooks = LifecycleHooks.resolve(this.container);
    if (this._lifecycleHooks.created !== void 0) {
      this._lifecycleHooks.created.forEach(callCreatedHook, this);
    }
    if (this._vmHooks._created) {
      if (this.debug) {
        this.logger.trace(`invoking created() hook`);
      }
      this._vm.created(this);
    }
  }
  /** @internal */
  _hydrateSynthetic() {
    this._compiledDef = this._rendering.compile(this.viewFactory.def, this.container);
    this._rendering.render(
      /* controller */
      this,
      /* targets    */
      (this.nodes = this._rendering.createNodes(this._compiledDef)).findTargets(),
      /* definition */
      this._compiledDef,
      /* host       */
      void 0
    );
  }
  activate(initiator, parent, scope) {
    switch (this.state) {
      case none:
      case deactivated:
        if (!(parent === null || parent.isActive)) {
          return;
        }
        this.state = activating;
        break;
      case activated:
        return;
      case disposed:
        throw createMappedError(502, this.name);
      default:
        throw createMappedError(503, this.name, stringifyState$1(this.state));
    }
    this.parent = parent;
    if (this.debug && !this._fullyNamed) {
      this._fullyNamed = true;
      (this.logger ??= this.container.get(ILogger).root.scopeTo(this.name)).trace(`activate()`);
    }
    switch (this.vmKind) {
      case vmkCe:
        this.scope.parent = scope ?? null;
        break;
      case vmkCa:
        this.scope = scope ?? null;
        break;
      case vmkSynth:
        if (scope === void 0 || scope === null) {
          throw createMappedError(504, this.name);
        }
        if (!this.hasLockedScope) {
          this.scope = scope;
        }
        break;
    }
    this.$initiator = initiator;
    this._enterActivating();
    let ret = void 0;
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.binding != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.binding()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.binding.map(callBindingHook, this));
    }
    if (this._vmHooks._binding) {
      if (this.debug) {
        this.logger.trace(`binding()`);
      }
      ret = onResolveAll(ret, this._vm.binding(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      ret.then(() => {
        this._isBindingDone = true;
        if (this.state !== activating) {
          this._leaveActivating();
        } else {
          this.bind();
        }
      }).catch((err) => {
        this._reject(err);
      });
      return this.$promise;
    }
    this._isBindingDone = true;
    this.bind();
    return this.$promise;
  }
  bind() {
    if (this.debug) {
      this.logger.trace(`bind()`);
    }
    let i = 0;
    let ii = 0;
    let ret = void 0;
    if (this.bindings !== null) {
      i = 0;
      ii = this.bindings.length;
      while (ii > i) {
        this.bindings[i].bind(this.scope);
        ++i;
      }
    }
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.bound != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.bound()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.bound.map(callBoundHook, this));
    }
    if (this._vmHooks._bound) {
      if (this.debug) {
        this.logger.trace(`bound()`);
      }
      ret = onResolveAll(ret, this._vm.bound(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      ret.then(() => {
        this.isBound = true;
        if (this.state !== activating) {
          this._leaveActivating();
        } else {
          this._attach();
        }
      }).catch((err) => {
        this._reject(err);
      });
      return;
    }
    this.isBound = true;
    this._attach();
  }
  /** @internal */
  _append(...nodes) {
    switch (this.mountTarget) {
      case targetHost:
        this.host.append(...nodes);
        break;
      case targetShadowRoot:
        this.shadowRoot.append(...nodes);
        break;
      case targetLocation: {
        let i = 0;
        for (; i < nodes.length; ++i) {
          this.location.parentNode.insertBefore(nodes[i], this.location);
        }
        break;
      }
    }
  }
  /** @internal */
  _attach() {
    if (this.debug) {
      this.logger.trace(`attach()`);
    }
    switch (this.mountTarget) {
      case targetHost:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case targetShadowRoot: {
        const container = this.container;
        const styles = container.has(IShadowDOMStyles, false) ? container.get(IShadowDOMStyles) : container.get(IShadowDOMGlobalStyles);
        styles.applyTo(this.shadowRoot);
        this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case targetLocation:
        this.nodes.insertBefore(this.location);
        break;
    }
    let i = 0;
    let ret = void 0;
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.attaching != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.attaching()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.attaching.map(callAttachingHook, this));
    }
    if (this._vmHooks._attaching) {
      if (this.debug) {
        this.logger.trace(`attaching()`);
      }
      ret = onResolveAll(ret, this._vm.attaching(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      this._enterActivating();
      ret.then(() => {
        this._leaveActivating();
      }).catch((err) => {
        this._reject(err);
      });
    }
    if (this.children !== null) {
      for (; i < this.children.length; ++i) {
        void this.children[i].activate(this.$initiator, this, this.scope);
      }
    }
    this._leaveActivating();
  }
  deactivate(initiator, _parent) {
    let prevActivation = void 0;
    switch (this.state & ~released) {
      case activated:
        this.state = deactivating;
        break;
      case activating:
        this.state = deactivating;
        prevActivation = this.$promise?.catch(
          (err) => {
            this.logger.warn("The activation error will be ignored, as the controller is already scheduled for deactivation. The activation was rejected with: %s", err);
          }
        );
        break;
      case none:
      case deactivated:
      case disposed:
      case deactivated | disposed:
        return;
      default:
        throw createMappedError(505, this.name, this.state);
    }
    if (this.debug) {
      this.logger.trace(`deactivate()`);
    }
    this.$initiator = initiator;
    if (initiator === this) {
      this._enterDetaching();
    }
    let i = 0;
    let ret;
    if (this.children !== null) {
      for (i = 0; i < this.children.length; ++i) {
        void this.children[i].deactivate(initiator, this);
      }
    }
    return onResolve(prevActivation, () => {
      if (this.isBound) {
        if (this.vmKind !== vmkSynth && this._lifecycleHooks.detaching != null) {
          if (this.debug) {
            this.logger.trace(`lifecycleHooks.detaching()`);
          }
          ret = onResolveAll(...this._lifecycleHooks.detaching.map(callDetachingHook, this));
        }
        if (this._vmHooks._detaching) {
          if (this.debug) {
            this.logger.trace(`detaching()`);
          }
          ret = onResolveAll(ret, this._vm.detaching(this.$initiator, this.parent));
        }
      }
      if (isPromise(ret)) {
        this._ensurePromise();
        initiator._enterDetaching();
        ret.then(() => {
          initiator._leaveDetaching();
        }).catch((err) => {
          initiator._reject(err);
        });
      }
      if (initiator.head === null) {
        initiator.head = this;
      } else {
        initiator.tail.next = this;
      }
      initiator.tail = this;
      if (initiator !== this) {
        return;
      }
      this._leaveDetaching();
      return this.$promise;
    });
  }
  removeNodes() {
    switch (this.vmKind) {
      case vmkCe:
      case vmkSynth:
        this.nodes.remove();
        this.nodes.unlink();
    }
  }
  unbind() {
    if (this.debug) {
      this.logger.trace(`unbind()`);
    }
    let i = 0;
    if (this.bindings !== null) {
      for (; i < this.bindings.length; ++i) {
        this.bindings[i].unbind();
      }
    }
    this.parent = null;
    switch (this.vmKind) {
      case vmkCa:
        this.scope = null;
        break;
      case vmkSynth:
        if (!this.hasLockedScope) {
          this.scope = null;
        }
        if ((this.state & released) === released && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this) {
          this.dispose();
        }
        break;
      case vmkCe:
        this.scope.parent = null;
        break;
    }
    this.state = deactivated;
    this.$initiator = null;
    this._resolve();
  }
  /** @internal */
  _ensurePromise() {
    if (this.$promise === void 0) {
      this.$promise = new Promise((resolve2, reject) => {
        this.$resolve = resolve2;
        this.$reject = reject;
      });
      if (this.$initiator !== this) {
        this.parent._ensurePromise();
      }
    }
  }
  /** @internal */
  _resolve() {
    if (this.$promise !== void 0) {
      _resolve = this.$resolve;
      this.$resolve = this.$reject = this.$promise = void 0;
      _resolve();
      _resolve = void 0;
    }
  }
  /** @internal */
  _reject(err) {
    if (this.$promise !== void 0) {
      _reject = this.$reject;
      this.$resolve = this.$reject = this.$promise = void 0;
      _reject(err);
      _reject = void 0;
    }
    if (this.$initiator !== this) {
      this.parent._reject(err);
    }
  }
  /** @internal */
  _enterActivating() {
    ++this._activatingStack;
    if (this.$initiator !== this) {
      this.parent._enterActivating();
    }
  }
  /** @internal */
  _leaveActivating() {
    if (this.state !== activating) {
      --this._activatingStack;
      this._resolve();
      if (this.$initiator !== this) {
        this.parent._leaveActivating();
      }
      return;
    }
    if (--this._activatingStack === 0) {
      if (this.vmKind !== vmkSynth && this._lifecycleHooks.attached != null) {
        _retPromise = onResolveAll(...this._lifecycleHooks.attached.map(callAttachedHook, this));
      }
      if (this._vmHooks._attached) {
        if (this.debug) {
          this.logger.trace(`attached()`);
        }
        _retPromise = onResolveAll(_retPromise, this._vm.attached(this.$initiator));
      }
      if (isPromise(_retPromise)) {
        this._ensurePromise();
        _retPromise.then(() => {
          this.state = activated;
          this._resolve();
          if (this.$initiator !== this) {
            this.parent._leaveActivating();
          }
        }).catch((err) => {
          this._reject(err);
        });
        _retPromise = void 0;
        return;
      }
      _retPromise = void 0;
      this.state = activated;
      this._resolve();
    }
    if (this.$initiator !== this) {
      this.parent._leaveActivating();
    }
  }
  /** @internal */
  _enterDetaching() {
    ++this._detachingStack;
  }
  /** @internal */
  _leaveDetaching() {
    if (--this._detachingStack === 0) {
      if (this.debug) {
        this.logger.trace(`detach()`);
      }
      this._enterUnbinding();
      this.removeNodes();
      let cur = this.$initiator.head;
      let ret = void 0;
      while (cur !== null) {
        if (cur !== this) {
          if (cur.debug) {
            cur.logger.trace(`detach()`);
          }
          cur.removeNodes();
        }
        if (cur._isBindingDone) {
          if (cur.vmKind !== vmkSynth && cur._lifecycleHooks.unbinding != null) {
            ret = onResolveAll(...cur._lifecycleHooks.unbinding.map(callUnbindingHook, cur));
          }
          if (cur._vmHooks._unbinding) {
            if (cur.debug) {
              cur.logger.trace("unbinding()");
            }
            ret = onResolveAll(ret, cur.viewModel.unbinding(cur.$initiator, cur.parent));
          }
        }
        if (isPromise(ret)) {
          this._ensurePromise();
          this._enterUnbinding();
          ret.then(() => {
            this._leaveUnbinding();
          }).catch((err) => {
            this._reject(err);
          });
        }
        ret = void 0;
        cur = cur.next;
      }
      this._leaveUnbinding();
    }
  }
  /** @internal */
  _enterUnbinding() {
    ++this._unbindingStack;
  }
  /** @internal */
  _leaveUnbinding() {
    if (--this._unbindingStack === 0) {
      if (this.debug) {
        this.logger.trace(`unbind()`);
      }
      let cur = this.$initiator.head;
      let next = null;
      while (cur !== null) {
        if (cur !== this) {
          cur._isBindingDone = false;
          cur.isBound = false;
          cur.unbind();
        }
        next = cur.next;
        cur.next = null;
        cur = next;
      }
      this.head = this.tail = null;
      this._isBindingDone = false;
      this.isBound = false;
      this.unbind();
    }
  }
  addBinding(binding) {
    if (this.bindings === null) {
      this.bindings = [binding];
    } else {
      this.bindings[this.bindings.length] = binding;
    }
  }
  addChild(controller) {
    if (this.children === null) {
      this.children = [controller];
    } else {
      this.children[this.children.length] = controller;
    }
  }
  is(name2) {
    switch (this.vmKind) {
      case vmkCa:
      case vmkCe: {
        return this.definition.name === name2;
      }
      case vmkSynth:
        return this.viewFactory.name === name2;
    }
  }
  lockScope(scope) {
    this.scope = scope;
    this.hasLockedScope = true;
  }
  setHost(host) {
    if (this.vmKind === vmkCe) {
      setRef(host, elementBaseName, this);
      setRef(host, this.definition.key, this);
    }
    this.host = host;
    this.mountTarget = targetHost;
    return this;
  }
  setShadowRoot(shadowRoot) {
    if (this.vmKind === vmkCe) {
      setRef(shadowRoot, elementBaseName, this);
      setRef(shadowRoot, this.definition.key, this);
    }
    this.shadowRoot = shadowRoot;
    this.mountTarget = targetShadowRoot;
    return this;
  }
  setLocation(location) {
    if (this.vmKind === vmkCe) {
      setRef(location, elementBaseName, this);
      setRef(location, this.definition.key, this);
    }
    this.location = location;
    this.mountTarget = targetLocation;
    return this;
  }
  release() {
    this.state |= released;
  }
  dispose() {
    if (this.debug) {
      this.logger.trace(`dispose()`);
    }
    if ((this.state & disposed) === disposed) {
      return;
    }
    this.state |= disposed;
    if (this._vmHooks._dispose) {
      this._vm.dispose();
    }
    if (this.children !== null) {
      this.children.forEach(callDispose);
      this.children = null;
    }
    this.scope = null;
    this.nodes = null;
    this.location = null;
    this.viewFactory = null;
    if (this._vm !== null) {
      controllerLookup.delete(this._vm);
      this._vm = null;
    }
    this._vm = null;
    this.host = null;
    this.shadowRoot = null;
    this.container.disposeResolvers();
  }
  accept(visitor) {
    if (visitor(this) === true) {
      return true;
    }
    if (this._vmHooks._accept && this._vm.accept(visitor) === true) {
      return true;
    }
    if (this.children !== null) {
      const { children } = this;
      for (let i = 0, ii = children.length; i < ii; ++i) {
        if (children[i].accept(visitor) === true) {
          return true;
        }
      }
    }
  }
}
const controllerLookup = /* @__PURE__ */ new WeakMap();
const targetNone = 0;
const targetHost = 1;
const targetShadowRoot = 2;
const targetLocation = 3;
const MountTarget = objectFreeze({
  none: targetNone,
  host: targetHost,
  shadowRoot: targetShadowRoot,
  location: targetLocation
});
const optionalCoercionConfigResolver = optionalResource(ICoercionConfiguration);
function createObservers(controller, definition, instance) {
  const bindables2 = definition.bindables;
  const observableNames = getOwnPropertyNames(bindables2);
  const length = observableNames.length;
  if (length === 0)
    return;
  const locator = controller.container.get(IObserverLocator);
  const hasAggregatedCallbacks = "propertiesChanged" in instance;
  const coercion = controller.vmKind === vmkSynth ? void 0 : controller.container.get(optionalCoercionConfigResolver);
  const queueCallback = hasAggregatedCallbacks ? /* @__PURE__ */ (() => {
    let changes = {};
    let isQueued = false;
    let changeCount = 0;
    const callPropertiesChanged = () => {
      if (!isQueued) {
        isQueued = true;
        queueTask(() => {
          isQueued = false;
          const $changes = changes;
          changes = {};
          changeCount = 0;
          if (controller.isBound) {
            instance.propertiesChanged?.($changes);
            if (changeCount > 0) {
              callPropertiesChanged();
            }
          }
        });
      }
    };
    return (key, newValue, oldValue) => {
      changes[key] = { newValue, oldValue };
      changeCount++;
      callPropertiesChanged();
    };
  })() : noop;
  for (let i = 0; i < length; ++i) {
    const name2 = observableNames[i];
    const bindable2 = bindables2[name2];
    const handler = bindable2.callback;
    const obs = locator.getObserver(instance, name2);
    if (bindable2.set !== noop) {
      if (obs.useCoercer?.(bindable2.set, coercion) !== true) {
        throw createMappedError(507, name2);
      }
    }
    if (instance[handler] != null || instance.propertyChanged != null || hasAggregatedCallbacks) {
      const callback = (newValue, oldValue) => {
        if (controller.isBound) {
          instance[handler]?.(newValue, oldValue);
          instance.propertyChanged?.(name2, newValue, oldValue);
          queueCallback(name2, newValue, oldValue);
        }
      };
      if (obs.useCallback?.(callback) !== true) {
        throw createMappedError(508, name2);
      }
    }
  }
}
const AccessScopeAstMap = /* @__PURE__ */ new Map();
const getAccessScopeAst = (key) => {
  let ast = AccessScopeAstMap.get(key);
  if (ast == null) {
    ast = new AccessScopeExpression(key, 0);
    AccessScopeAstMap.set(key, ast);
  }
  return ast;
};
function createWatchers(controller, context, definition, instance) {
  const observerLocator = context.get(IObserverLocator);
  const expressionParser = context.get(IExpressionParser);
  const watches = definition.watches;
  const scope = controller.vmKind === vmkCe ? controller.scope : Scope.create(instance, null, true);
  const ii = watches.length;
  let expression;
  let callback;
  let ast;
  let flush;
  let i = 0;
  for (; ii > i; ++i) {
    ({ expression, callback, flush } = watches[i]);
    callback = isFunction(callback) ? callback : Reflect.get(instance, callback);
    if (!isFunction(callback)) {
      throw createMappedError(506, callback);
    }
    if (isFunction(expression)) {
      controller.addBinding(new ComputedWatcher(instance, observerLocator, expression, callback, flush));
    } else {
      ast = isString(expression) ? expressionParser.parse(expression, etIsProperty) : getAccessScopeAst(expression);
      controller.addBinding(new ExpressionWatcher(scope, context, observerLocator, ast, callback, flush));
    }
  }
}
function isCustomElementController(value) {
  return value instanceof Controller && value.vmKind === vmkCe;
}
function isCustomElementViewModel(value) {
  return isElementType(value?.constructor);
}
class HooksDefinition {
  constructor(target) {
    this._define = "define" in target;
    this._hydrating = "hydrating" in target;
    this._hydrated = "hydrated" in target;
    this._created = "created" in target;
    this._binding = "binding" in target;
    this._bound = "bound" in target;
    this._attaching = "attaching" in target;
    this._attached = "attached" in target;
    this._detaching = "detaching" in target;
    this._unbinding = "unbinding" in target;
    this._dispose = "dispose" in target;
    this._accept = "accept" in target;
  }
}
HooksDefinition.none = new HooksDefinition({});
const defaultShadowOptions = {
  mode: "open"
};
const vmkCe = "customElement";
const vmkCa = "customAttribute";
const vmkSynth = "synthetic";
const none = 0;
const activating = 1;
const activated = 2;
const deactivating = 4;
const deactivated = 8;
const released = 16;
const disposed = 32;
function stringifyState$1(state) {
  const names = [];
  if ((state & activating) === activating) {
    names.push("activating");
  }
  if ((state & activated) === activated) {
    names.push("activated");
  }
  if ((state & deactivating) === deactivating) {
    names.push("deactivating");
  }
  if ((state & deactivated) === deactivated) {
    names.push("deactivated");
  }
  if ((state & released) === released) {
    names.push("released");
  }
  if ((state & disposed) === disposed) {
    names.push("disposed");
  }
  return names.length === 0 ? "none" : names.join("|");
}
const IController = /* @__PURE__ */ createInterface("IController");
const IHydrationContext = /* @__PURE__ */ createInterface("IHydrationContext");
class HydrationContext {
  constructor(controller, instruction, parent) {
    this.instruction = instruction;
    this.parent = parent;
    this.controller = controller;
  }
}
function callDispose(disposable) {
  disposable.dispose();
}
function callCreatedHook(l) {
  l.instance.created(this._vm, this);
}
function callHydratingHook(l) {
  l.instance.hydrating(this._vm, this);
}
function callHydratedHook(l) {
  l.instance.hydrated(this._vm, this);
}
function callBindingHook(l) {
  return l.instance.binding(this._vm, this["$initiator"], this.parent);
}
function callBoundHook(l) {
  return l.instance.bound(this._vm, this["$initiator"], this.parent);
}
function callAttachingHook(l) {
  return l.instance.attaching(this._vm, this["$initiator"], this.parent);
}
function callAttachedHook(l) {
  return l.instance.attached(this._vm, this["$initiator"]);
}
function callDetachingHook(l) {
  return l.instance.detaching(this._vm, this["$initiator"], this.parent);
}
function callUnbindingHook(l) {
  return l.instance.unbinding(this._vm, this["$initiator"], this.parent);
}
let _resolve;
let _reject;
let _retPromise;
const setRef = refs.set;
const IEventTarget = /* @__PURE__ */ createInterface("IEventTarget", (x) => x.cachedCallback((handler) => {
  if (handler.has(IAppRoot, true)) {
    return handler.get(IAppRoot).host;
  }
  return handler.get(IPlatform).document;
}));
const IRenderLocation = /* @__PURE__ */ createInterface("IRenderLocation");
const ICssClassMapping = /* @__PURE__ */ createInterface("ICssClassMapping");
const effectiveParentNodeOverrides = /* @__PURE__ */ new WeakMap();
function getEffectiveParentNode(node) {
  if (effectiveParentNodeOverrides.has(node)) {
    return effectiveParentNodeOverrides.get(node);
  }
  let containerlessOffset = 0;
  let next = node.nextSibling;
  while (next !== null) {
    if (next.nodeType === 8) {
      switch (next.textContent) {
        case "au-start":
          ++containerlessOffset;
          break;
        case "au-end":
          if (containerlessOffset-- === 0) {
            return next;
          }
      }
    }
    next = next.nextSibling;
  }
  if (node.parentNode === null && node.nodeType === 11) {
    const controller = findElementControllerFor(node, { optional: true });
    if (controller == null) {
      return null;
    }
    if (controller.mountTarget === MountTarget.shadowRoot) {
      return getEffectiveParentNode(controller.host);
    }
  }
  return node.parentNode;
}
function setEffectiveParentNode(childNodeOrNodeSequence, parentNode) {
  if (childNodeOrNodeSequence.platform !== void 0 && !(childNodeOrNodeSequence instanceof childNodeOrNodeSequence.platform.Node)) {
    const nodes = childNodeOrNodeSequence.childNodes;
    for (let i = 0, ii = nodes.length; i < ii; ++i) {
      effectiveParentNodeOverrides.set(nodes[i], parentNode);
    }
  } else {
    effectiveParentNodeOverrides.set(childNodeOrNodeSequence, parentNode);
  }
}
function convertToRenderLocation(node) {
  if (isRenderLocation(node)) {
    return node;
  }
  const locationEnd = node.ownerDocument.createComment("au-end");
  const locationStart = locationEnd.$start = node.ownerDocument.createComment("au-start");
  const parentNode = node.parentNode;
  if (parentNode !== null) {
    parentNode.replaceChild(locationEnd, node);
    parentNode.insertBefore(locationStart, locationEnd);
  }
  return locationEnd;
}
function isRenderLocation(node) {
  return node.textContent === "au-end";
}
class FragmentNodeSequence {
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  constructor(platform, fragment) {
    this.platform = platform;
    this.next = void 0;
    this._isMounted = false;
    this._isLinked = false;
    this.ref = null;
    const targetNodeList = (this.f = fragment).querySelectorAll("au-m");
    let i = 0;
    let ii = targetNodeList.length;
    let targets = this.t = Array(ii);
    let target;
    let marker;
    while (ii > i) {
      marker = targetNodeList[i];
      target = marker.nextSibling;
      marker.remove();
      if (target.nodeType === 8) {
        marker = target;
        (target = target.nextSibling).$start = marker;
      }
      targets[i] = target;
      ++i;
    }
    const childNodeList = fragment.childNodes;
    const childNodes = this.childNodes = Array(ii = childNodeList.length);
    i = 0;
    while (ii > i) {
      childNodes[i] = childNodeList[i];
      ++i;
    }
    this._firstChild = fragment.firstChild;
    this._lastChild = fragment.lastChild;
  }
  findTargets() {
    return this.t;
  }
  insertBefore(refNode) {
    if (this._isLinked && !!this.ref) {
      this.addToLinked();
    } else {
      const parent = refNode.parentNode;
      if (this._isMounted) {
        let current = this._firstChild;
        let next;
        const end2 = this._lastChild;
        while (current != null) {
          next = current.nextSibling;
          parent.insertBefore(current, refNode);
          if (current === end2) {
            break;
          }
          current = next;
        }
      } else {
        this._isMounted = true;
        refNode.parentNode.insertBefore(this.f, refNode);
      }
    }
  }
  appendTo(parent, enhance = false) {
    if (this._isMounted) {
      let current = this._firstChild;
      let next;
      const end2 = this._lastChild;
      while (current != null) {
        next = current.nextSibling;
        parent.appendChild(current);
        if (current === end2) {
          break;
        }
        current = next;
      }
    } else {
      this._isMounted = true;
      if (!enhance) {
        parent.appendChild(this.f);
      }
    }
  }
  remove() {
    if (this._isMounted) {
      this._isMounted = false;
      const fragment = this.f;
      const end2 = this._lastChild;
      let next;
      let current = this._firstChild;
      while (current !== null) {
        next = current.nextSibling;
        fragment.appendChild(current);
        if (current === end2) {
          break;
        }
        current = next;
      }
    }
  }
  addToLinked() {
    const refNode = this.ref;
    const parent = refNode.parentNode;
    if (this._isMounted) {
      let current = this._firstChild;
      let next;
      const end2 = this._lastChild;
      while (current != null) {
        next = current.nextSibling;
        parent.insertBefore(current, refNode);
        if (current === end2) {
          break;
        }
        current = next;
      }
    } else {
      this._isMounted = true;
      parent.insertBefore(this.f, refNode);
    }
  }
  unlink() {
    this._isLinked = false;
    this.next = void 0;
    this.ref = void 0;
  }
  link(next) {
    this._isLinked = true;
    if (isRenderLocation(next)) {
      this.ref = next;
    } else {
      this.next = next;
      this._obtainRefNode();
    }
  }
  /** @internal */
  _obtainRefNode() {
    if (this.next !== void 0) {
      this.ref = this.next.firstChild;
    } else {
      this.ref = void 0;
    }
  }
}
const IWindow = /* @__PURE__ */ createInterface("IWindow", (x) => x.callback((handler) => handler.get(IPlatform).window));
const ILocation = /* @__PURE__ */ createInterface("ILocation", (x) => x.callback((handler) => handler.get(IWindow).location));
const IHistory = /* @__PURE__ */ createInterface("IHistory", (x) => x.callback((handler) => handler.get(IWindow).history));
const registerHostNode = (container, host, platform = container.get(IPlatform)) => {
  registerResolver(container, platform.HTMLElement, registerResolver(container, platform.Element, registerResolver(container, INode, new InstanceProvider("ElementResolver", host))));
  return container;
};
function customElement(nameOrDef) {
  return function(target, context) {
    context.addInitializer(function() {
      defineElement(nameOrDef, this);
    });
    return target;
  };
}
const definitionLookup = /* @__PURE__ */ new WeakMap();
class CustomElementDefinition {
  get type() {
    return dtElement;
  }
  constructor(Type, name2, aliases, key, capture, template2, instructions, dependencies2, injectable, needsCompile, surrogates, bindables2, containerless, shadowOptions, hasSlots, enhance, watches, strict, processContent) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
    this.capture = capture;
    this.template = template2;
    this.instructions = instructions;
    this.dependencies = dependencies2;
    this.injectable = injectable;
    this.needsCompile = needsCompile;
    this.surrogates = surrogates;
    this.bindables = bindables2;
    this.containerless = containerless;
    this.shadowOptions = shadowOptions;
    this.hasSlots = hasSlots;
    this.enhance = enhance;
    this.watches = watches;
    this.strict = strict;
    this.processContent = processContent;
  }
  static create(nameOrDef, Type = null) {
    if (Type === null) {
      const def2 = nameOrDef;
      if (isString(def2)) {
        throw createMappedError(761, nameOrDef);
      }
      const name3 = fromDefinitionOrDefault("name", def2, generateElementName);
      if (isFunction(def2.Type)) {
        Type = def2.Type;
      } else {
        Type = generateElementType(pascalCase(name3));
      }
      for (const bindable2 of Object.values(Bindable.from(def2.bindables))) {
        Bindable._add(bindable2, Type);
      }
      return new CustomElementDefinition(
        Type,
        name3,
        mergeArrays(def2.aliases),
        fromDefinitionOrDefault("key", def2, () => getElementKeyFrom(name3)),
        fromAnnotationOrDefinitionOrTypeOrDefault("capture", def2, Type, returnFalse),
        fromAnnotationOrDefinitionOrTypeOrDefault("template", def2, Type, returnNull),
        mergeArrays(def2.instructions),
        mergeArrays(getElementAnnotation(Type, "dependencies"), def2.dependencies),
        fromDefinitionOrDefault("injectable", def2, returnNull),
        fromDefinitionOrDefault("needsCompile", def2, returnTrue),
        mergeArrays(def2.surrogates),
        Bindable.from(getElementAnnotation(Type, "bindables"), def2.bindables),
        fromAnnotationOrDefinitionOrTypeOrDefault("containerless", def2, Type, returnFalse),
        fromDefinitionOrDefault("shadowOptions", def2, returnNull),
        fromDefinitionOrDefault("hasSlots", def2, returnFalse),
        fromDefinitionOrDefault("enhance", def2, returnFalse),
        fromDefinitionOrDefault("watches", def2, returnEmptyArray),
        // casting is incorrect, but it's good enough
        fromDefinitionOrDefault("strict", def2, returnUndefined),
        fromAnnotationOrTypeOrDefault("processContent", Type, returnNull)
      );
    }
    if (isString(nameOrDef)) {
      return new CustomElementDefinition(Type, nameOrDef, mergeArrays(getElementAnnotation(Type, "aliases"), Type.aliases), getElementKeyFrom(nameOrDef), fromAnnotationOrTypeOrDefault("capture", Type, returnFalse), fromAnnotationOrTypeOrDefault("template", Type, returnNull), mergeArrays(getElementAnnotation(Type, "instructions"), Type.instructions), mergeArrays(getElementAnnotation(Type, "dependencies"), Type.dependencies), fromAnnotationOrTypeOrDefault("injectable", Type, returnNull), fromAnnotationOrTypeOrDefault("needsCompile", Type, returnTrue), mergeArrays(getElementAnnotation(Type, "surrogates"), Type.surrogates), Bindable.from(...Bindable.getAll(Type), getElementAnnotation(Type, "bindables"), Type.bindables), fromAnnotationOrTypeOrDefault("containerless", Type, returnFalse), fromAnnotationOrTypeOrDefault("shadowOptions", Type, returnNull), fromAnnotationOrTypeOrDefault("hasSlots", Type, returnFalse), fromAnnotationOrTypeOrDefault("enhance", Type, returnFalse), mergeArrays(Watch.getDefinitions(Type), Type.watches), fromAnnotationOrTypeOrDefault("strict", Type, returnUndefined), fromAnnotationOrTypeOrDefault("processContent", Type, returnNull));
    }
    const name2 = fromDefinitionOrDefault("name", nameOrDef, generateElementName);
    for (const bindable2 of Object.values(Bindable.from(nameOrDef.bindables))) {
      Bindable._add(bindable2, Type);
    }
    return new CustomElementDefinition(Type, name2, mergeArrays(getElementAnnotation(Type, "aliases"), nameOrDef.aliases, Type.aliases), getElementKeyFrom(name2), fromAnnotationOrDefinitionOrTypeOrDefault("capture", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("template", nameOrDef, Type, returnNull), mergeArrays(getElementAnnotation(Type, "instructions"), nameOrDef.instructions, Type.instructions), mergeArrays(getElementAnnotation(Type, "dependencies"), nameOrDef.dependencies, Type.dependencies), fromAnnotationOrDefinitionOrTypeOrDefault("injectable", nameOrDef, Type, returnNull), fromAnnotationOrDefinitionOrTypeOrDefault("needsCompile", nameOrDef, Type, returnTrue), mergeArrays(getElementAnnotation(Type, "surrogates"), nameOrDef.surrogates, Type.surrogates), Bindable.from(...Bindable.getAll(Type), getElementAnnotation(Type, "bindables"), Type.bindables, nameOrDef.bindables), fromAnnotationOrDefinitionOrTypeOrDefault("containerless", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("shadowOptions", nameOrDef, Type, returnNull), fromAnnotationOrDefinitionOrTypeOrDefault("hasSlots", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("enhance", nameOrDef, Type, returnFalse), mergeArrays(nameOrDef.watches, Watch.getDefinitions(Type), Type.watches), fromAnnotationOrDefinitionOrTypeOrDefault("strict", nameOrDef, Type, returnUndefined), fromAnnotationOrDefinitionOrTypeOrDefault("processContent", nameOrDef, Type, returnNull));
  }
  static getOrCreate(partialDefinition) {
    if (partialDefinition instanceof CustomElementDefinition) {
      return partialDefinition;
    }
    if (definitionLookup.has(partialDefinition)) {
      return definitionLookup.get(partialDefinition);
    }
    const definition = CustomElementDefinition.create(partialDefinition);
    definitionLookup.set(partialDefinition, definition);
    defineMetadata(definition, definition.Type, elementBaseName);
    return definition;
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getElementKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (container.has(key, false)) {
      console.warn(createMappedError(153, this.name));
      return;
    }
    container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getElementKeyFrom(alias))));
  }
  toString() {
    return `au:ce:${this.name}`;
  }
}
const defaultForOpts = {
  name: void 0,
  searchParents: false,
  optional: false
};
const returnNull = () => null;
const returnUndefined = () => void 0;
const returnFalse = () => false;
const returnTrue = () => true;
const returnEmptyArray = () => emptyArray;
const elementTypeName = "custom-element";
const elementBaseName = /* @__PURE__ */ getResourceKeyFor(elementTypeName);
const getElementKeyFrom = (name2) => `${elementBaseName}:${name2}`;
const generateElementName = /* @__PURE__ */ ((id2) => () => `unnamed-${++id2}`)(0);
const annotateElementMetadata = (Type, prop, value) => {
  defineMetadata(value, Type, getAnnotationKeyFor(prop));
};
const defineElement = (nameOrDef, Type) => {
  const definition = CustomElementDefinition.create(nameOrDef, Type);
  const $Type = definition.Type;
  defineMetadata(definition, $Type, elementBaseName, resourceBaseName);
  return $Type;
};
const isElementType = (value) => {
  return isFunction(value) && (hasMetadata(elementBaseName, value) || value.$au?.type === elementTypeName);
};
const findElementControllerFor = (node, opts = defaultForOpts) => {
  if (opts.name === void 0 && opts.searchParents !== true) {
    const controller = refs.get(node, elementBaseName);
    if (controller === null) {
      if (opts.optional === true) {
        return null;
      }
      throw createMappedError(762, node);
    }
    return controller;
  }
  if (opts.name !== void 0) {
    if (opts.searchParents !== true) {
      const controller = refs.get(node, elementBaseName);
      if (controller === null) {
        throw createMappedError(763, node);
      }
      if (controller.is(opts.name)) {
        return controller;
      }
      return void 0;
    }
    let cur2 = node;
    let foundAController = false;
    while (cur2 !== null) {
      const controller = refs.get(cur2, elementBaseName);
      if (controller !== null) {
        foundAController = true;
        if (controller.is(opts.name)) {
          return controller;
        }
      }
      cur2 = getEffectiveParentNode(cur2);
    }
    if (foundAController) {
      return void 0;
    }
    throw createMappedError(764, node);
  }
  let cur = node;
  while (cur !== null) {
    const controller = refs.get(cur, elementBaseName);
    if (controller !== null) {
      return controller;
    }
    cur = getEffectiveParentNode(cur);
  }
  throw createMappedError(765, node);
};
const getElementAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getElementDefinition = (Type) => {
  const def2 = getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create);
  if (def2 == null) {
    throw createMappedError(760, Type);
  }
  return def2;
};
const createElementInjectable = () => {
  const $injectable = {
    // Old code is kept around. Needs to be refactored when TC39 supports argument decorator.
    // function(target: Injectable | AbstractInjectable, property: string | symbol | undefined, index?: number): Injectable | AbstractInjectable {
    //   const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target as Constructable);
    //   annotationParamtypes[index!] = $injectable;
    //   return target;
    // },
    $isInterface: false,
    register() {
      return {
        $isResolver: true,
        resolve(container, requestor) {
          if (requestor.has($injectable, true)) {
            return requestor.get($injectable);
          } else {
            return null;
          }
        }
      };
    }
  };
  return $injectable;
};
const generateElementType = /* @__PURE__ */ (function() {
  const nameDescriptor = {
    value: "",
    writable: false,
    enumerable: false,
    configurable: true
  };
  const defaultProto = {};
  return function(name2, proto = defaultProto) {
    const Type = class Anonymous {
    };
    nameDescriptor.value = name2;
    def(Type, "name", nameDescriptor);
    if (proto !== defaultProto) {
      objectAssign(Type.prototype, proto);
    }
    return Type;
  };
})();
const CustomElement = /* @__PURE__ */ objectFreeze({
  name: elementBaseName,
  keyFrom: getElementKeyFrom,
  isType: isElementType,
  for: findElementControllerFor,
  define: defineElement,
  getDefinition: getElementDefinition,
  annotate: annotateElementMetadata,
  getAnnotation: getElementAnnotation,
  generateName: generateElementName,
  createInjectable: createElementInjectable,
  generateType: generateElementType,
  find(c, name2) {
    const Type = c.find(elementTypeName, name2);
    return Type == null ? null : getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create) ?? null;
  }
});
const IAppRoot = /* @__PURE__ */ createInterface("IAppRoot");
class AppRoot {
  get controller() {
    return this._controller;
  }
  constructor(config, container, rootProvider, enhance = false) {
    this.config = config;
    this.container = container;
    this._hydratePromise = void 0;
    this._useOwnAppTasks = enhance;
    const host = this.host = config.host;
    rootProvider.prepare(this);
    registerResolver(container, IEventTarget, new InstanceProvider("IEventTarget", host));
    registerHostNode(container, host, this.platform = this._createPlatform(container, host));
    this._hydratePromise = onResolve(this._runAppTasks("creating"), () => {
      if (!config.allowActionlessForm !== false) {
        host.addEventListener("submit", (e) => {
          const target = e.target;
          const noAction = !target.getAttribute("action");
          if (target.tagName === "FORM" && noAction) {
            e.preventDefault();
          }
        }, false);
      }
      const childCtn = enhance ? container : container.createChild();
      const component = config.component;
      let instance;
      if (isFunction(component)) {
        instance = childCtn.invoke(component);
      } else {
        instance = config.component;
      }
      const hydrationInst = { hydrate: false, projections: null };
      const definition = enhance ? CustomElementDefinition.create({ name: generateElementName(), template: this.host, enhance: true, strict: config.strictBinding }) : void 0;
      const controller = this._controller = Controller.$el(childCtn, instance, host, hydrationInst, definition);
      controller._hydrateCustomElement(hydrationInst);
      return onResolve(this._runAppTasks("hydrating"), () => {
        controller._hydrate();
        return onResolve(this._runAppTasks("hydrated"), () => {
          controller._hydrateChildren();
          this._hydratePromise = void 0;
        });
      });
    });
  }
  activate() {
    return onResolve(this._hydratePromise, () => {
      return onResolve(this._runAppTasks("activating"), () => {
        return onResolve(this._controller.activate(this._controller, null, void 0), () => {
          return this._runAppTasks("activated");
        });
      });
    });
  }
  deactivate() {
    return onResolve(this._runAppTasks("deactivating"), () => {
      return onResolve(this._controller.deactivate(this._controller, null), () => {
        return this._runAppTasks("deactivated");
      });
    });
  }
  /** @internal */
  _runAppTasks(slot) {
    const container = this.container;
    const appTasks = this._useOwnAppTasks && !container.has(IAppTask, false) ? [] : container.getAll(IAppTask);
    return onResolveAll(...appTasks.reduce((results, task) => {
      if (task.slot === slot) {
        results.push(task.run());
      }
      return results;
    }, []));
  }
  /** @internal */
  _createPlatform(container, host) {
    let p;
    if (!container.has(IPlatform, false)) {
      if (host.ownerDocument.defaultView === null) {
        throw createMappedError(
          769
          /* ErrorNames.invalid_platform_impl */
        );
      }
      p = new BrowserPlatform(host.ownerDocument.defaultView);
      container.register(instanceRegistration(IPlatform, p));
    } else {
      p = container.get(IPlatform);
    }
    return p;
  }
  dispose() {
    this._controller?.dispose();
  }
}
const IAurelia = /* @__PURE__ */ createInterface("IAurelia");
let Aurelia$1 = class Aurelia {
  get isRunning() {
    return this._isRunning;
  }
  get isStarting() {
    return this._isStarting;
  }
  get isStopping() {
    return this._isStopping;
  }
  get root() {
    if (this._root == null) {
      if (this.next == null) {
        throw createMappedError(
          767
          /* ErrorNames.root_not_found */
        );
      }
      return this.next;
    }
    return this._root;
  }
  constructor(container = DI.createContainer()) {
    this.container = container;
    this._isRunning = false;
    this._isStarting = false;
    this._isStopping = false;
    this._root = void 0;
    this.next = void 0;
    this._startPromise = void 0;
    this._stopPromise = void 0;
    if (container.has(IAurelia, true) || container.has(Aurelia, true)) {
      throw createMappedError(
        768
        /* ErrorNames.aurelia_instance_existed_in_container */
      );
    }
    registerResolver(container, IAurelia, new InstanceProvider("IAurelia", this));
    registerResolver(container, Aurelia, new InstanceProvider("Aurelia", this));
    registerResolver(container, IAppRoot, this._rootProvider = new InstanceProvider("IAppRoot"));
  }
  register(...params) {
    this.container.register(...params);
    return this;
  }
  app(config) {
    this.next = new AppRoot(config, this.container, this._rootProvider);
    return this;
  }
  /**
   * @param parentController - The owning controller of the view created by this enhance call
   */
  enhance(config) {
    const container = config.container ?? this.container.createChild();
    const rootProvider = registerResolver(container, IAppRoot, new InstanceProvider("IAppRoot"));
    const appRoot = new AppRoot({ host: config.host, component: config.component }, container, rootProvider, true);
    return onResolve(appRoot.activate(), () => appRoot);
  }
  async waitForIdle() {
    const platform = this.root.platform;
    await platform.domQueue.yield();
    await platform.taskQueue.yield();
  }
  start(root = this.next) {
    if (root == null) {
      throw createMappedError(
        770
        /* ErrorNames.no_composition_root */
      );
    }
    if (isPromise(this._startPromise)) {
      return this._startPromise;
    }
    return this._startPromise = onResolve(this.stop(), () => {
      if (!refs.hideProp) {
        Reflect.set(root.host, "$aurelia", this);
      }
      this._rootProvider.prepare(this._root = root);
      this._isStarting = true;
      return onResolve(root.activate(), () => {
        this._isRunning = true;
        this._isStarting = false;
        this._startPromise = void 0;
        this._dispatchEvent(root, "au-started", root.host);
      });
    });
  }
  stop(dispose2 = false) {
    if (isPromise(this._stopPromise)) {
      return this._stopPromise;
    }
    if (this._isRunning === true) {
      const root = this._root;
      this._isRunning = false;
      this._isStopping = true;
      return this._stopPromise = onResolve(root.deactivate(), () => {
        return onResolve(tasksSettled(), () => {
          Reflect.deleteProperty(root.host, "$aurelia");
          if (dispose2) {
            root.dispose();
          }
          this._root = void 0;
          this._rootProvider.dispose();
          this._isStopping = false;
          this._stopPromise = void 0;
          this._dispatchEvent(root, "au-stopped", root.host);
        });
      });
    }
  }
  dispose() {
    if (this._isRunning || this._isStopping) {
      throw createMappedError(
        771
        /* ErrorNames.invalid_dispose_call */
      );
    }
    this.container.dispose();
  }
  /** @internal */
  _dispatchEvent(root, name2, target) {
    const ev = new root.platform.window.CustomEvent(name2, { detail: this, bubbles: true, cancelable: true });
    target.dispatchEvent(ev);
  }
};
const ISVGAnalyzer = /* @__PURE__ */ createInterface("ISVGAnalyzer", (x) => x.singleton(NoopSVGAnalyzer));
class NoopSVGAnalyzer {
  isStandardSvgAttribute(_node, _attributeName) {
    return false;
  }
}
class AttrMapper {
  constructor() {
    this.fns = [];
    this._tagAttrMap = createLookup$1();
    this._globalAttrMap = createLookup$1();
    this.svg = resolve(ISVGAnalyzer);
    this.useMapping({
      LABEL: { for: "htmlFor" },
      IMG: { usemap: "useMap" },
      INPUT: {
        maxlength: "maxLength",
        minlength: "minLength",
        formaction: "formAction",
        formenctype: "formEncType",
        formmethod: "formMethod",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        inputmode: "inputMode"
      },
      TEXTAREA: { maxlength: "maxLength" },
      TD: { rowspan: "rowSpan", colspan: "colSpan" },
      TH: { rowspan: "rowSpan", colspan: "colSpan" }
    });
    this.useGlobalMapping({
      accesskey: "accessKey",
      contenteditable: "contentEditable",
      tabindex: "tabIndex",
      textcontent: "textContent",
      innerhtml: "innerHTML",
      scrolltop: "scrollTop",
      scrollleft: "scrollLeft",
      readonly: "readOnly"
    });
  }
  /**
   * Allow application to teach Aurelia how to define how to map attributes to properties
   * based on element tagName
   */
  useMapping(config) {
    let newAttrMapping;
    let targetAttrMapping;
    let tagName;
    let attr;
    for (tagName in config) {
      newAttrMapping = config[tagName];
      targetAttrMapping = this._tagAttrMap[tagName] ??= createLookup$1();
      for (attr in newAttrMapping) {
        if (targetAttrMapping[attr] !== void 0) {
          throw createError$1(attr, tagName);
        }
        targetAttrMapping[attr] = newAttrMapping[attr];
      }
    }
  }
  /**
   * Allow applications to teach Aurelia how to define how to map attributes to properties
   * for all elements
   */
  useGlobalMapping(config) {
    const mapper = this._globalAttrMap;
    for (const attr in config) {
      if (mapper[attr] !== void 0) {
        throw createError$1(attr, "*");
      }
      mapper[attr] = config[attr];
    }
  }
  /**
   * Add a given function to a list of fns that will be used
   * to check if `'bind'` command can be understood as `'two-way'` command.
   */
  useTwoWay(fn2) {
    this.fns.push(fn2);
  }
  /**
   * Returns true if an attribute should be two way bound based on an element
   */
  isTwoWay(node, attrName) {
    return shouldDefaultToTwoWay(node, attrName) || this.fns.length > 0 && this.fns.some((fn2) => fn2(node, attrName));
  }
  /**
   * Retrieves the mapping information this mapper have for an attribute on an element
   */
  map(node, attr) {
    return this._tagAttrMap[node.nodeName]?.[attr] ?? this._globalAttrMap[attr] ?? (isDataAttribute(node, attr, this.svg) ? attr : null);
  }
}
AttrMapper.register = createImplementationRegister(IAttrMapper);
function shouldDefaultToTwoWay(element, attr) {
  switch (element.nodeName) {
    case "INPUT":
      switch (element.type) {
        case "checkbox":
        case "radio":
          return attr === "checked";
        // note:
        // ideally, it should check for corresponding input type first
        // as 'files' shouldn't be two way on a number input, for example
        // but doing it this way is acceptable-ish, as the common user expectations,
        // and the behavior of the control for these properties are the same,
        // regardless the type of the <input>
        default:
          return attr === "value" || attr === "files" || attr === "value-as-number" || attr === "value-as-date";
      }
    case "TEXTAREA":
    case "SELECT":
      return attr === "value";
    default:
      switch (attr) {
        case "textcontent":
        case "innerhtml":
          return element.hasAttribute("contenteditable");
        case "scrolltop":
        case "scrollleft":
          return true;
        default:
          return false;
      }
  }
}
function createError$1(attr, tagName) {
  return createMappedError(719, attr, tagName);
}
const RuntimeTemplateCompilerImplementation = {
  register(container) {
    container.register(TemplateCompiler, AttrMapper, ResourceResolver);
  }
};
class BindablesInfo {
  constructor(attrs, bindables2, primary) {
    this.attrs = attrs;
    this.bindables = bindables2;
    this.primary = primary;
  }
}
class ResourceResolver {
  constructor() {
    this._resourceCache = /* @__PURE__ */ new WeakMap();
    this._bindableCache = /* @__PURE__ */ new WeakMap();
  }
  el(c, name2) {
    let record = this._resourceCache.get(c);
    if (record == null) {
      this._resourceCache.set(c, record = new RecordCache());
    }
    return name2 in record._element ? record._element[name2] : record._element[name2] = CustomElement.find(c, name2);
  }
  attr(c, name2) {
    let record = this._resourceCache.get(c);
    if (record == null) {
      this._resourceCache.set(c, record = new RecordCache());
    }
    return name2 in record._attr ? record._attr[name2] : record._attr[name2] = CustomAttribute.find(c, name2);
  }
  bindables(def2) {
    let info2 = this._bindableCache.get(def2);
    if (info2 == null) {
      const bindables2 = def2.bindables;
      const attrs = createLookup$1();
      let bindable2;
      let prop;
      let hasPrimary = false;
      let primary;
      let attr;
      for (prop in bindables2) {
        bindable2 = bindables2[prop];
        attr = bindable2.attribute;
        if (bindable2.primary === true) {
          if (hasPrimary) {
            throw createMappedError(714, def2);
          }
          hasPrimary = true;
          primary = bindable2;
        } else if (!hasPrimary && primary == null) {
          primary = bindable2;
        }
        attrs[attr] = BindableDefinition.create(prop, bindable2);
      }
      if (bindable2 == null && def2.type === "custom-attribute") {
        primary = attrs.value = BindableDefinition.create("value", { mode: def2.defaultBindingMode ?? defaultMode });
      }
      this._bindableCache.set(def2, info2 = new BindablesInfo(attrs, bindables2, primary ?? null));
    }
    return info2;
  }
}
ResourceResolver.register = createImplementationRegister(IResourceResolver);
class RecordCache {
  constructor() {
    this._element = createLookup$1();
    this._attr = createLookup$1();
  }
}
const nsMap = createLookup$1();
class AttributeNSAccessor {
  static forNs(ns) {
    return nsMap[ns] ??= new AttributeNSAccessor(ns);
  }
  constructor(ns) {
    this.ns = ns;
    this.type = atNode | atLayout;
  }
  getValue(obj, propertyKey) {
    return obj.getAttributeNS(this.ns, propertyKey);
  }
  setValue(newValue, obj, key) {
    if (newValue == null) {
      obj.removeAttributeNS(this.ns, key);
    } else {
      obj.setAttributeNS(this.ns, key, newValue);
    }
  }
}
(() => {
  mixinNoopSubscribable(AttributeNSAccessor);
})();
class DataAttributeAccessor {
  constructor() {
    this.type = atNode | atLayout;
  }
  getValue(obj, key) {
    return obj.getAttribute(key);
  }
  setValue(newValue, obj, key) {
    if (newValue == null) {
      obj.removeAttribute(key);
    } else {
      obj.setAttribute(key, newValue);
    }
  }
}
(() => {
  mixinNoopSubscribable(DataAttributeAccessor);
})();
const attrAccessor = /* @__PURE__ */ new DataAttributeAccessor();
class SelectValueObserver {
  /** @internal */
  static _getSelectedOptions(options) {
    const selection = [];
    if (options.length === 0) {
      return selection;
    }
    const ii = options.length;
    let i = 0;
    let option;
    while (ii > i) {
      option = options[i];
      if (option.selected) {
        selection[selection.length] = hasOwnProperty.call(option, "model") ? option.model : option.value;
      }
      ++i;
    }
    return selection;
  }
  /** @internal */
  static _defaultMatcher(a, b) {
    return a === b;
  }
  constructor(obj, _key, config, observerLocator) {
    this.type = atNode | atObserver | atLayout;
    this._value = void 0;
    this._oldValue = void 0;
    this._hasChanges = false;
    this._arrayObserver = void 0;
    this._nodeObserver = void 0;
    this._observing = false;
    this._listened = false;
    this._el = obj;
    this._observerLocator = observerLocator;
    this._config = config;
  }
  getValue() {
    return this._observing ? this._value : this._el.multiple ? SelectValueObserver._getSelectedOptions(this._el.options) : this._el.value;
  }
  setValue(newValue) {
    this._oldValue = this._value;
    this._value = newValue;
    this._hasChanges = newValue !== this._oldValue;
    this._observeArray(newValue instanceof Array ? newValue : null);
    this._flushChanges();
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      this.syncOptions();
    }
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const value = this._value;
    const obj = this._el;
    const $isArray = isArray(value);
    const matcher = obj.matcher ?? SelectValueObserver._defaultMatcher;
    const options = obj.options;
    let i = options.length;
    while (i-- > 0) {
      const option = options[i];
      const optionValue = hasOwnProperty.call(option, "model") ? option.model : option.value;
      if ($isArray) {
        option.selected = value.findIndex((item) => !!matcher(optionValue, item)) !== -1;
        continue;
      }
      option.selected = !!matcher(optionValue, value);
    }
  }
  syncValue() {
    const obj = this._el;
    const options = obj.options;
    const len = options.length;
    const currentValue = this._value;
    let i = 0;
    if (obj.multiple) {
      if (!(currentValue instanceof Array)) {
        return true;
      }
      let option2;
      const matcher = obj.matcher || SelectValueObserver._defaultMatcher;
      const values = [];
      while (i < len) {
        option2 = options[i];
        if (option2.selected) {
          values.push(hasOwnProperty.call(option2, "model") ? option2.model : option2.value);
        }
        ++i;
      }
      let a;
      i = 0;
      while (i < currentValue.length) {
        a = currentValue[i];
        if (values.findIndex((b) => !!matcher(a, b)) === -1) {
          currentValue.splice(i, 1);
        } else {
          ++i;
        }
      }
      i = 0;
      while (i < values.length) {
        a = values[i];
        if (currentValue.findIndex((b) => !!matcher(a, b)) === -1) {
          currentValue.push(a);
        }
        ++i;
      }
      return false;
    }
    let value = null;
    let option;
    while (i < len) {
      option = options[i];
      if (option.selected) {
        value = hasOwnProperty.call(option, "model") ? option.model : option.value;
        break;
      }
      ++i;
    }
    this._oldValue = this._value;
    this._value = value;
    return true;
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    (this._nodeObserver = createMutationObserver(this._el, this._handleNodeChange.bind(this))).observe(this._el, {
      childList: true,
      subtree: true,
      characterData: true
    });
    this._observeArray(this._value instanceof Array ? this._value : null);
    this._observing = true;
  }
  /**
   * Used by mixing defined method unsubscribe
   *
   * @internal
   */
  _stop() {
    this._nodeObserver.disconnect();
    this._arrayObserver?.unsubscribe(this);
    this._nodeObserver = this._arrayObserver = void 0;
    this._observing = false;
  }
  // todo: observe all kind of collection
  /** @internal */
  _observeArray(array) {
    this._arrayObserver?.unsubscribe(this);
    this._arrayObserver = void 0;
    if (array != null) {
      if (!this._el.multiple) {
        throw createMappedError(
          654
          /* ErrorNames.select_observer_array_on_non_multi_select */
        );
      }
      (this._arrayObserver = this._observerLocator.getArrayObserver(array)).subscribe(this);
    }
  }
  handleEvent() {
    const shouldNotify = this.syncValue();
    if (shouldNotify) {
      this._flush();
    }
  }
  /** @internal */
  _handleNodeChange(_records) {
    this.syncOptions();
    const shouldNotify = this.syncValue();
    if (shouldNotify) {
      this._flush();
    }
  }
  /** @internal */
  _flush() {
    const oV2 = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV2);
  }
}
(() => {
  mixinNodeObserverUseConfig(SelectValueObserver);
  subscriberCollection(SelectValueObserver, null);
})();
const customPropertyPrefix = "--";
class StyleAttributeAccessor {
  constructor(obj) {
    this.obj = obj;
    this.type = atNode | atLayout;
    this._value = "";
    this._oldValue = "";
    this.styles = {};
    this.version = 0;
    this._hasChanges = false;
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(newValue) {
    this._value = newValue;
    this._hasChanges = newValue !== this._oldValue;
    this._flushChanges();
  }
  /** @internal */
  _getStyleTuplesFromString(currentValue) {
    const styleTuples = [];
    const urlRegexTester = /url\([^)]+$/;
    let offset2 = 0;
    let currentChunk = "";
    let nextSplit;
    let indexOfColon;
    let attribute;
    let value;
    while (offset2 < currentValue.length) {
      nextSplit = currentValue.indexOf(";", offset2);
      if (nextSplit === -1) {
        nextSplit = currentValue.length;
      }
      currentChunk += currentValue.substring(offset2, nextSplit);
      offset2 = nextSplit + 1;
      if (urlRegexTester.test(currentChunk)) {
        currentChunk += ";";
        continue;
      }
      indexOfColon = currentChunk.indexOf(":");
      attribute = currentChunk.substring(0, indexOfColon).trim();
      value = currentChunk.substring(indexOfColon + 1).trim();
      styleTuples.push([attribute, value]);
      currentChunk = "";
    }
    return styleTuples;
  }
  /** @internal */
  _getStyleTuplesFromObject(currentValue) {
    let value;
    let property;
    const styles = [];
    for (property in currentValue) {
      value = currentValue[property];
      if (value == null) {
        continue;
      }
      if (isString(value)) {
        if (property.startsWith(customPropertyPrefix)) {
          styles.push([property, value]);
          continue;
        }
        styles.push([kebabCase(property), value]);
        continue;
      }
      styles.push(...this._getStyleTuples(value));
    }
    return styles;
  }
  /** @internal */
  _getStyleTuplesFromArray(currentValue) {
    const len = currentValue.length;
    if (len > 0) {
      const styles = [];
      let i = 0;
      for (; len > i; ++i) {
        styles.push(...this._getStyleTuples(currentValue[i]));
      }
      return styles;
    }
    return emptyArray;
  }
  /** @internal */
  _getStyleTuples(currentValue) {
    if (isString(currentValue)) {
      return this._getStyleTuplesFromString(currentValue);
    }
    if (currentValue instanceof Array) {
      return this._getStyleTuplesFromArray(currentValue);
    }
    if (currentValue instanceof Object) {
      return this._getStyleTuplesFromObject(currentValue);
    }
    return emptyArray;
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      const currentValue = this._value;
      const styles = this.styles;
      const styleTuples = this._getStyleTuples(currentValue);
      let style;
      let version = this.version;
      this._oldValue = currentValue;
      let tuple;
      let name2;
      let value;
      let i = 0;
      const len = styleTuples.length;
      for (; i < len; ++i) {
        tuple = styleTuples[i];
        name2 = tuple[0];
        value = tuple[1];
        this.setProperty(name2, value);
        styles[name2] = version;
      }
      this.styles = styles;
      this.version += 1;
      if (version === 0) {
        return;
      }
      version -= 1;
      for (style in styles) {
        if (!hasOwnProperty.call(styles, style) || styles[style] !== version) {
          continue;
        }
        this.obj.style.removeProperty(style);
      }
    }
  }
  setProperty(style, value) {
    let priority = "";
    if (value != null && isFunction(value.indexOf) && value.includes("!important")) {
      priority = "important";
      value = value.replace("!important", "");
    }
    this.obj.style.setProperty(style, value, priority);
  }
  bind() {
    this._value = this._oldValue = this.obj.style.cssText;
  }
}
(() => {
  mixinNoopSubscribable(StyleAttributeAccessor);
})();
class ValueAttributeObserver {
  constructor(obj, key, config) {
    this.type = atNode | atObserver | atLayout;
    this._value = "";
    this._oldValue = "";
    this._hasChanges = false;
    this._listened = false;
    this._el = obj;
    this._key = key;
    this._config = config;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (areEqual(newValue, this._value)) {
      return;
    }
    this._oldValue = this._value;
    this._value = newValue;
    this._hasChanges = true;
    if (!this._config.readonly) {
      this._flushChanges();
    }
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      this._el[this._key] = this._value ?? this._config.default;
      this._flush();
    }
  }
  handleEvent() {
    this._oldValue = this._value;
    this._value = this._el[this._key];
    if (this._oldValue !== this._value) {
      this._hasChanges = false;
      this._flush();
    }
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    this._value = this._oldValue = this._el[this._key];
  }
  /** @internal */
  _flush() {
    const oV2 = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV2);
  }
}
(() => {
  mixinNodeObserverUseConfig(ValueAttributeObserver);
  subscriberCollection(ValueAttributeObserver, null);
})();
const nsAttributes = (() => {
  const xlinkNS = "http://www.w3.org/1999/xlink";
  const xmlNS = "http://www.w3.org/XML/1998/namespace";
  const xmlnsNS = "http://www.w3.org/2000/xmlns/";
  return objectAssign(createLookup$1(), {
    "xlink:actuate": ["actuate", xlinkNS],
    "xlink:arcrole": ["arcrole", xlinkNS],
    "xlink:href": ["href", xlinkNS],
    "xlink:role": ["role", xlinkNS],
    "xlink:show": ["show", xlinkNS],
    "xlink:title": ["title", xlinkNS],
    "xlink:type": ["type", xlinkNS],
    "xml:lang": ["lang", xmlNS],
    "xml:space": ["space", xmlNS],
    "xmlns": ["xmlns", xmlnsNS],
    "xmlns:xlink": ["xlink", xmlnsNS]
  });
})();
const elementPropertyAccessor = new PropertyAccessor();
elementPropertyAccessor.type = atNode | atLayout;
class NodeObserverLocator {
  constructor() {
    this.allowDirtyCheck = true;
    this._events = createLookup$1();
    this._globalEvents = createLookup$1();
    this._overrides = createLookup$1();
    this._globalOverrides = createLookup$1();
    this._locator = resolve(IServiceLocator);
    this._platform = resolve(IPlatform);
    this._dirtyChecker = resolve(IDirtyChecker);
    this.svg = resolve(ISVGAnalyzer);
    const inputEvents = ["change", "input"];
    const inputEventsConfig = { events: inputEvents, default: "" };
    this.useConfig({
      INPUT: {
        value: inputEventsConfig,
        valueAsNumber: { events: inputEvents, default: 0 },
        checked: { type: CheckedObserver, events: inputEvents },
        files: { events: inputEvents, readonly: true }
      },
      SELECT: {
        value: { type: SelectValueObserver, events: ["change"], default: "" }
      },
      TEXTAREA: {
        value: inputEventsConfig
      }
    });
    const contentEventsConfig = { events: ["change", "input", "blur", "keyup", "paste"], default: "" };
    const scrollEventsConfig = { events: ["scroll"], default: 0 };
    this.useConfigGlobal({
      scrollTop: scrollEventsConfig,
      scrollLeft: scrollEventsConfig,
      textContent: contentEventsConfig,
      innerHTML: contentEventsConfig
    });
    this.overrideAccessorGlobal("css", "style", "class");
    this.overrideAccessor({
      INPUT: ["value", "checked", "model"],
      SELECT: ["value"],
      TEXTAREA: ["value"]
    });
  }
  // deepscan-disable-next-line
  handles(obj, _key) {
    return obj instanceof this._platform.Node;
  }
  useConfig(nodeNameOrConfig, key, eventsConfig) {
    const lookup2 = this._events;
    let existingMapping;
    if (isString(nodeNameOrConfig)) {
      existingMapping = lookup2[nodeNameOrConfig] ??= createLookup$1();
      if (existingMapping[key] == null) {
        existingMapping[key] = eventsConfig;
      } else {
        throwMappingExisted(nodeNameOrConfig, key);
      }
    } else {
      for (const nodeName in nodeNameOrConfig) {
        existingMapping = lookup2[nodeName] ??= createLookup$1();
        const newMapping = nodeNameOrConfig[nodeName];
        for (key in newMapping) {
          if (existingMapping[key] == null) {
            existingMapping[key] = newMapping[key];
          } else {
            throwMappingExisted(nodeName, key);
          }
        }
      }
    }
  }
  useConfigGlobal(configOrKey, eventsConfig) {
    const lookup2 = this._globalEvents;
    if (typeof configOrKey === "object") {
      for (const key in configOrKey) {
        if (lookup2[key] == null) {
          lookup2[key] = configOrKey[key];
        } else {
          throwMappingExisted("*", key);
        }
      }
    } else {
      if (lookup2[configOrKey] == null) {
        lookup2[configOrKey] = eventsConfig;
      } else {
        throwMappingExisted("*", configOrKey);
      }
    }
  }
  // deepscan-disable-nextline
  getAccessor(obj, key, requestor) {
    if (key in this._globalOverrides || key in (this._overrides[obj.tagName] ?? emptyObject)) {
      return this.getObserver(obj, key, requestor);
    }
    switch (key) {
      // class / style / css attribute will be observed using .getObserver() per overrides
      //
      // TODO: there are (many) more situation where we want to default to DataAttributeAccessor
      case "src":
      case "href":
      case "role":
      case "minLength":
      case "maxLength":
      case "placeholder":
      case "size":
      case "pattern":
      case "title":
      case "popovertarget":
      case "popovertargetaction":
        {
          if ((key === "popovertarget" || key === "popovertargetaction") && obj.nodeName !== "INPUT" && obj.nodeName !== "BUTTON") {
            console.warn(`[aurelia] Popover API are only valid on <input> or <button>. Detected ${key} on <${obj.nodeName.toLowerCase()}>`);
          }
        }
        return attrAccessor;
      default: {
        const nsProps = nsAttributes[key];
        if (nsProps !== void 0) {
          return AttributeNSAccessor.forNs(nsProps[1]);
        }
        if (isDataAttribute(obj, key, this.svg)) {
          return attrAccessor;
        }
        return elementPropertyAccessor;
      }
    }
  }
  overrideAccessor(tagNameOrOverrides, key) {
    let existingTagOverride;
    if (isString(tagNameOrOverrides)) {
      existingTagOverride = this._overrides[tagNameOrOverrides] ??= createLookup$1();
      existingTagOverride[key] = true;
    } else {
      for (const tagName in tagNameOrOverrides) {
        for (const key2 of tagNameOrOverrides[tagName]) {
          existingTagOverride = this._overrides[tagName] ??= createLookup$1();
          existingTagOverride[key2] = true;
        }
      }
    }
  }
  /**
   * For all elements:
   * compose a list of properties,
   * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`
   */
  overrideAccessorGlobal(...keys) {
    for (const key of keys) {
      this._globalOverrides[key] = true;
    }
  }
  getNodeObserverConfig(el, key) {
    return this._events[el.tagName]?.[key] ?? this._globalEvents[key];
  }
  getNodeObserver(el, key, requestor) {
    const eventsConfig = this._events[el.tagName]?.[key] ?? this._globalEvents[key];
    let observer;
    if (eventsConfig != null) {
      observer = new (eventsConfig.type ?? ValueAttributeObserver)(el, key, eventsConfig, requestor, this._locator);
      if (!observer.doNotCache) {
        getObserverLookup(el)[key] = observer;
      }
      return observer;
    }
    return null;
  }
  getObserver(el, key, requestor) {
    switch (key) {
      case "class":
        return new ClassAttributeAccessor(el);
      case "css":
      case "style":
        return new StyleAttributeAccessor(el);
    }
    const nodeObserver = this.getNodeObserver(el, key, requestor);
    if (nodeObserver != null) {
      return nodeObserver;
    }
    const nsProps = nsAttributes[key];
    if (nsProps !== void 0) {
      return AttributeNSAccessor.forNs(nsProps[1]);
    }
    if (isDataAttribute(el, key, this.svg)) {
      return attrAccessor;
    }
    if (key in el.constructor.prototype) {
      if (this.allowDirtyCheck) {
        return this._dirtyChecker.createProperty(el, key);
      }
      throw createMappedError(652, key);
    } else {
      return new SetterObserver(el, key);
    }
  }
}
NodeObserverLocator.register = createImplementationRegister(INodeObserverLocator);
function getCollectionObserver(collection, observerLocator) {
  if (collection instanceof Array) {
    return observerLocator.getArrayObserver(collection);
  }
  if (collection instanceof Map) {
    return observerLocator.getMapObserver(collection);
  }
  if (collection instanceof Set) {
    return observerLocator.getSetObserver(collection);
  }
}
function throwMappingExisted(nodeName, key) {
  throw createMappedError(653, nodeName, key);
}
function defaultMatcher(a, b) {
  return a === b;
}
class CheckedObserver {
  constructor(obj, _key, config, observerLocator) {
    this.type = atNode | atObserver | atLayout;
    this._value = void 0;
    this._oldValue = void 0;
    this._collectionObserver = void 0;
    this._valueObserver = void 0;
    this._listened = false;
    this._el = obj;
    this.oL = observerLocator;
    this._config = config;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    const currentValue = this._value;
    if (newValue === currentValue) {
      return;
    }
    this._value = newValue;
    this._oldValue = currentValue;
    this._observe();
    this._synchronizeElement();
    this._flush();
  }
  handleCollectionChange() {
    this._synchronizeElement();
  }
  handleChange(_newValue, _previousValue) {
    this._synchronizeElement();
  }
  /** @internal */
  _synchronizeElement() {
    const currentValue = this._value;
    const obj = this._el;
    const elementValue = hasOwnProperty.call(obj, "model") ? obj.model : obj.value;
    const isRadio = obj.type === "radio";
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
    if (isRadio) {
      obj.checked = !!matcher(currentValue, elementValue);
    } else if (currentValue === true) {
      obj.checked = true;
    } else {
      let hasMatch = false;
      if (isArray(currentValue)) {
        hasMatch = currentValue.findIndex((item) => !!matcher(item, elementValue)) !== -1;
      } else if (currentValue instanceof Set) {
        for (const v of currentValue) {
          if (matcher(v, elementValue)) {
            hasMatch = true;
            break;
          }
        }
      } else if (currentValue instanceof Map) {
        for (const pair of currentValue) {
          const existingItem = pair[0];
          const $isChecked = pair[1];
          if (matcher(existingItem, elementValue) && $isChecked === true) {
            hasMatch = true;
            break;
          }
        }
      }
      obj.checked = hasMatch;
    }
  }
  handleEvent() {
    let currentValue = this._oldValue = this._value;
    const obj = this._el;
    const elementValue = hasOwnProperty.call(obj, "model") ? obj.model : obj.value;
    const isChecked = obj.checked;
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
    if (obj.type === "checkbox") {
      if (isArray(currentValue)) {
        const index = currentValue.findIndex((item) => !!matcher(item, elementValue));
        if (isChecked && index === -1) {
          currentValue.push(elementValue);
        } else if (!isChecked && index !== -1) {
          currentValue.splice(index, 1);
        }
        return;
      } else if (currentValue instanceof Set) {
        const unset = {};
        let existingItem = unset;
        for (const value of currentValue) {
          if (matcher(value, elementValue) === true) {
            existingItem = value;
            break;
          }
        }
        if (isChecked && existingItem === unset) {
          currentValue.add(elementValue);
        } else if (!isChecked && existingItem !== unset) {
          currentValue.delete(existingItem);
        }
        return;
      } else if (currentValue instanceof Map) {
        let existingItem;
        for (const pair of currentValue) {
          const currItem = pair[0];
          if (matcher(currItem, elementValue) === true) {
            existingItem = currItem;
            break;
          }
        }
        currentValue.set(existingItem, isChecked);
        return;
      }
      currentValue = isChecked;
    } else if (isChecked) {
      currentValue = elementValue;
    } else {
      return;
    }
    this._value = currentValue;
    this._flush();
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    this._observe();
  }
  /**
   * Used by mixing defined methods unsubscribe
   *
   * @internal
   */
  _stop() {
    this._value = this._oldValue = void 0;
    this._collectionObserver?.unsubscribe(this);
    this._valueObserver?.unsubscribe(this);
    this._collectionObserver = this._valueObserver = void 0;
  }
  /** @internal */
  _flush() {
    oV = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV);
    oV = void 0;
  }
  /** @internal */
  _observe() {
    const obj = this._el;
    (this._valueObserver ??= obj.$observers?.model ?? obj.$observers?.value)?.subscribe(this);
    this._collectionObserver?.unsubscribe(this);
    this._collectionObserver = void 0;
    if (obj.type === "checkbox") {
      (this._collectionObserver = getCollectionObserver(this._value, this.oL))?.subscribe(this);
    }
  }
}
(() => {
  mixinNodeObserverUseConfig(CheckedObserver);
  subscriberCollection(CheckedObserver, null);
})();
let oV = void 0;
class AttrBindingBehavior {
  bind(_scope, binding) {
    if (!(binding instanceof PropertyBinding)) {
      throw createMappedError(9994, binding);
    }
    binding.useTargetObserver(attrAccessor);
  }
}
AttrBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "attr"
};
class SelfBindingBehavior {
  bind(_scope, binding) {
    if (!("handleEvent" in binding)) {
      throw createMappedError(
        801
        /* ErrorNames.self_behavior_invalid_usage */
      );
    }
    binding.self = true;
  }
  unbind(_scope, binding) {
    binding.self = false;
  }
}
SelfBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "self"
};
class UpdateTriggerBindingBehavior {
  constructor() {
    this._observerLocator = resolve(IObserverLocator);
    this._nodeObserverLocator = resolve(INodeObserverLocator);
  }
  bind(_scope, binding, ...events2) {
    if (!(this._nodeObserverLocator instanceof NodeObserverLocator)) {
      throw createMappedError(
        9993
        /* ErrorNames.update_trigger_behavior_not_supported */
      );
    }
    if (events2.length === 0) {
      throw createMappedError(
        802
        /* ErrorNames.update_trigger_behavior_no_triggers */
      );
    }
    if (!(binding instanceof PropertyBinding) || !(binding.mode & fromView)) {
      throw createMappedError(
        803
        /* ErrorNames.update_trigger_invalid_usage */
      );
    }
    const targetConfig = this._nodeObserverLocator.getNodeObserverConfig(binding.target, binding.targetProperty);
    if (targetConfig == null) {
      throw createMappedError(9992, binding);
    }
    const targetObserver = this._nodeObserverLocator.getNodeObserver(binding.target, binding.targetProperty, this._observerLocator);
    targetObserver.useConfig({ readonly: targetConfig.readonly, default: targetConfig.default, events: events2 });
    binding.useTargetObserver(targetObserver);
  }
}
UpdateTriggerBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "updateTrigger"
};
class If {
  constructor() {
    this.elseFactory = void 0;
    this.elseView = void 0;
    this.ifView = void 0;
    this.view = void 0;
    this.value = false;
    this.cache = true;
    this.pending = void 0;
    this._wantsDeactivate = false;
    this._swapId = 0;
    this._ifFactory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  attaching(_initiator, _parent) {
    return this._swap(this.value);
  }
  detaching(initiator, _parent) {
    this._wantsDeactivate = true;
    return onResolve(this.pending, () => {
      this._wantsDeactivate = false;
      this.pending = void 0;
      void this.view?.deactivate(initiator, this.$controller);
    });
  }
  valueChanged(newValue, oldValue) {
    if (!this.$controller.isActive)
      return;
    newValue = !!newValue;
    oldValue = !!oldValue;
    if (newValue !== oldValue)
      return this._swap(newValue);
  }
  /** @internal */
  _swap(value) {
    const currView = this.view;
    const ctrl = this.$controller;
    const swapId = this._swapId++;
    const isCurrent = () => !this._wantsDeactivate && this._swapId === swapId + 1;
    let view;
    return onResolve(this.pending, () => this.pending = onResolve(currView?.deactivate(currView, ctrl), () => {
      if (!isCurrent()) {
        return;
      }
      if (value) {
        view = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this._ifFactory.create();
      } else {
        view = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create();
      }
      if (view == null) {
        return;
      }
      view.setLocation(this._location);
      return onResolve(view.activate(view, ctrl, ctrl.scope), () => {
        if (isCurrent()) {
          this.pending = void 0;
        }
      });
    }));
  }
  dispose() {
    this.ifView?.dispose();
    this.elseView?.dispose();
    this.ifView = this.elseView = this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
If.$au = {
  type: attrTypeName,
  name: "if",
  isTemplateController: true,
  bindables: {
    value: true,
    cache: {
      set: (v) => v === "" || !!v && v !== "false"
    }
  }
};
class Else {
  constructor() {
    this._factory = resolve(IViewFactory);
  }
  link(controller, _childController, _target, _instruction) {
    const children = controller.children;
    const ifBehavior = children[children.length - 1];
    if (ifBehavior instanceof If) {
      ifBehavior.elseFactory = this._factory;
    } else if (ifBehavior.viewModel instanceof If) {
      ifBehavior.viewModel.elseFactory = this._factory;
    } else {
      throw createMappedError(
        810
        /* ErrorNames.else_without_if */
      );
    }
  }
}
Else.$au = {
  type: "custom-attribute",
  name: "else",
  isTemplateController: true
};
function dispose(disposable) {
  disposable.dispose();
}
const wrappedExprs = [
  "BindingBehavior",
  "ValueConverter"
];
class Repeat {
  constructor() {
    this.views = [];
    this.key = null;
    this._oldViews = [];
    this._scopes = [];
    this._oldScopes = [];
    this._scopeMap = /* @__PURE__ */ new Map();
    this._observer = void 0;
    this._observingInnerItems = false;
    this._reevaluating = false;
    this._innerItemsExpression = null;
    this._normalizedItems = void 0;
    this._hasDestructuredLocal = false;
    this._location = resolve(IRenderLocation);
    this._parent = resolve(IController);
    this._factory = resolve(IViewFactory);
    this._resolver = resolve(IRepeatableHandlerResolver);
    const instruction = resolve(IInstruction);
    const keyProp = instruction.props[0].props[0];
    if (keyProp !== void 0) {
      const { to, value, command } = keyProp;
      if (to === "key") {
        if (command === null) {
          this.key = value;
        } else if (command === "bind") {
          this.key = resolve(IExpressionParser).parse(value, etIsProperty);
        } else {
          throw createMappedError(775, command);
        }
      } else {
        throw createMappedError(776, to);
      }
    }
  }
  binding(_initiator, _parent) {
    const bindings = this._parent.bindings;
    const ii = bindings.length;
    let binding = void 0;
    let forOf;
    let i = 0;
    for (; ii > i; ++i) {
      binding = bindings[i];
      if (binding.target === this && binding.targetProperty === "items") {
        forOf = this.forOf = binding.ast;
        this._forOfBinding = binding;
        let expression = forOf.iterable;
        while (expression != null && wrappedExprs.includes(expression.$kind)) {
          expression = expression.expression;
          this._observingInnerItems = true;
        }
        this._innerItemsExpression = expression;
        break;
      }
    }
    this._refreshCollectionObserver();
    const dec = forOf.declaration;
    if (!(this._hasDestructuredLocal = dec.$kind === "ArrayDestructuring" || dec.$kind === "ObjectDestructuring")) {
      this.local = astEvaluate(dec, this.$controller.scope, binding, null);
    }
  }
  attaching(initiator, _parent) {
    this._normalizeToArray();
    this._createScopes(void 0);
    return this._activateAllViews(initiator, this._normalizedItems ?? emptyArray);
  }
  detaching(initiator, _parent) {
    this._refreshCollectionObserver();
    return this._deactivateAllViews(initiator);
  }
  unbinding(_initiator, _parent) {
    this._scopeMap.clear();
  }
  // called by SetterObserver
  itemsChanged() {
    if (!this.$controller.isActive) {
      return;
    }
    this._refreshCollectionObserver();
    this._normalizeToArray();
    this._createScopes(void 0);
    this._applyIndexMap(void 0);
  }
  handleCollectionChange(collection, indexMap) {
    const $controller = this.$controller;
    if (!$controller.isActive) {
      return;
    }
    if (this._observingInnerItems) {
      if (this._reevaluating) {
        return;
      }
      this._reevaluating = true;
      this.items = astEvaluate(this.forOf.iterable, $controller.scope, this._forOfBinding, null);
      this._reevaluating = false;
      return;
    }
    this._normalizeToArray();
    this._createScopes(this.key === null ? indexMap : void 0);
    this._applyIndexMap(indexMap);
  }
  /** @internal */
  _applyIndexMap(indexMap) {
    const oldViews = this.views;
    this._oldViews = oldViews.slice();
    const oldLen = oldViews.length;
    const key = this.key;
    const hasKey = key !== null;
    const oldScopes = this._oldScopes;
    const newScopes = this._scopes;
    if (hasKey || indexMap === void 0) {
      const local = this.local;
      const newItems = this._normalizedItems;
      const newLen = newItems.length;
      const forOf = this.forOf;
      const dec = forOf.declaration;
      const binding = this._forOfBinding;
      const hasDestructuredLocal = this._hasDestructuredLocal;
      indexMap = createIndexMap(newLen);
      let i = 0;
      if (oldLen === 0) {
        for (; i < newLen; ++i) {
          indexMap[i] = -2;
        }
      } else if (newLen === 0) {
        for (i = 0; i < oldLen; ++i) {
          indexMap.deletedIndices.push(i);
          indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));
        }
      } else if (hasKey) {
        const oldKeys = Array(oldLen);
        for (i = 0; i < oldLen; ++i) {
          oldKeys[i] = getKeyValue(hasDestructuredLocal, key, dec, oldScopes[i], binding, local);
        }
        const newKeys = Array(oldLen);
        for (i = 0; i < newLen; ++i) {
          newKeys[i] = getKeyValue(hasDestructuredLocal, key, dec, newScopes[i], binding, local);
        }
        for (i = 0; i < newLen; ++i) {
          if (oldKeys.includes(newKeys[i])) {
            indexMap[i] = oldKeys.indexOf(newKeys[i]);
          } else {
            indexMap[i] = -2;
          }
        }
        for (i = 0; i < oldLen; ++i) {
          if (!newKeys.includes(oldKeys[i])) {
            indexMap.deletedIndices.push(i);
            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));
          }
        }
      } else {
        for (i = 0; i < newLen; ++i) {
          if (oldScopes.includes(newScopes[i])) {
            indexMap[i] = oldScopes.indexOf(newScopes[i]);
          } else {
            indexMap[i] = -2;
          }
        }
        for (i = 0; i < oldLen; ++i) {
          if (!newScopes.includes(oldScopes[i])) {
            indexMap.deletedIndices.push(i);
            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));
          }
        }
      }
    }
    if (indexMap.deletedIndices.length > 0) {
      const ret = onResolve(this._deactivateAndRemoveViewsByKey(indexMap), () => {
        return this._createAndActivateAndSortViewsByKey(indexMap);
      });
      if (isPromise(ret)) {
        ret.catch(rethrow);
      }
    } else {
      this._createAndActivateAndSortViewsByKey(indexMap);
    }
  }
  // todo: subscribe to collection from inner expression
  /** @internal */
  _refreshCollectionObserver() {
    const scope = this.$controller.scope;
    let innerItems = this._innerItems;
    let observingInnerItems = this._observingInnerItems;
    let newObserver;
    if (observingInnerItems) {
      innerItems = this._innerItems = astEvaluate(this._innerItemsExpression, scope, this._forOfBinding, null) ?? null;
      observingInnerItems = this._observingInnerItems = !areEqual(this.items, innerItems);
    }
    const oldObserver = this._observer;
    if (this.$controller.isActive) {
      const items = observingInnerItems ? innerItems : this.items;
      newObserver = this._observer = this._resolver.resolve(items).getObserver?.(items);
      if (oldObserver !== newObserver) {
        oldObserver?.unsubscribe(this);
        newObserver?.subscribe(this);
      }
    } else {
      oldObserver?.unsubscribe(this);
      this._observer = void 0;
    }
  }
  /** @internal */
  _createScopes(indexMap) {
    const oldScopes = this._scopes;
    this._oldScopes = oldScopes.slice();
    const items = this._normalizedItems;
    const len = items.length;
    const scopes = this._scopes = Array(items.length);
    const oldScopeMap = this._scopeMap;
    const newScopeMap = /* @__PURE__ */ new Map();
    const parentScope = this.$controller.scope;
    const binding = this._forOfBinding;
    const forOf = this.forOf;
    const local = this.local;
    const hasDestructuredLocal = this._hasDestructuredLocal;
    if (indexMap === void 0) {
      const key = this.key;
      const hasKey = key !== null;
      if (hasKey) {
        const keys = Array(len);
        if (typeof key === "string") {
          for (let i = 0; i < len; ++i) {
            keys[i] = items[i][key];
          }
        } else {
          for (let i = 0; i < len; ++i) {
            const scope = createScope(items[i], forOf, parentScope, binding, local, hasDestructuredLocal);
            setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, items[i]);
            keys[i] = astEvaluate(key, scope, binding, null);
          }
        }
        for (let i = 0; i < len; ++i) {
          scopes[i] = getScope(oldScopeMap, newScopeMap, keys[i], items[i], forOf, parentScope, binding, local, hasDestructuredLocal);
        }
      } else {
        for (let i = 0; i < len; ++i) {
          scopes[i] = getScope(oldScopeMap, newScopeMap, items[i], items[i], forOf, parentScope, binding, local, hasDestructuredLocal);
        }
      }
    } else {
      const oldLen = oldScopes.length;
      for (let i = 0; i < len; ++i) {
        const src = indexMap[i];
        if (src >= 0 && src < oldLen) {
          scopes[i] = oldScopes[src];
        } else {
          scopes[i] = createScope(items[i], forOf, parentScope, binding, local, hasDestructuredLocal);
        }
        setItem(hasDestructuredLocal, forOf.declaration, scopes[i], binding, local, items[i]);
      }
    }
    oldScopeMap.clear();
    this._scopeMap = newScopeMap;
  }
  /** @internal */
  _normalizeToArray() {
    const items = this.items;
    if (isArray(items)) {
      this._normalizedItems = items.slice(0);
      return;
    }
    const normalizedItems = [];
    this._resolver.resolve(items).iterate(items, (item, index) => {
      normalizedItems[index] = item;
    });
    this._normalizedItems = normalizedItems;
  }
  /** @internal */
  _activateAllViews(initiator, $items) {
    let promises = void 0;
    let ret;
    let view;
    let scope;
    const { $controller, _factory, _location, _scopes } = this;
    const newLen = $items.length;
    const views = this.views = Array(newLen);
    for (let i = 0; i < newLen; ++i) {
      view = views[i] = _factory.create().setLocation(_location);
      view.nodes.unlink();
      scope = _scopes[i];
      setContextualProperties(scope.overrideContext, i, newLen);
      ret = view.activate(initiator ?? view, $controller, scope);
      if (isPromise(ret)) {
        (promises ??= []).push(ret);
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _deactivateAllViews(initiator) {
    let promises = void 0;
    let ret;
    let view;
    let i = 0;
    const { views, $controller } = this;
    const ii = views.length;
    for (; ii > i; ++i) {
      view = views[i];
      view.release();
      ret = view.deactivate(initiator ?? view, $controller);
      if (isPromise(ret)) {
        (promises ?? (promises = [])).push(ret);
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _deactivateAndRemoveViewsByKey(indexMap) {
    let promises = void 0;
    let ret;
    let view;
    const { $controller, views } = this;
    const deleted = indexMap.deletedIndices.slice().sort(compareNumber);
    const deletedLen = deleted.length;
    let i = 0;
    for (; deletedLen > i; ++i) {
      view = views[deleted[i]];
      view.release();
      ret = view.deactivate(view, $controller);
      if (isPromise(ret)) {
        (promises ?? (promises = [])).push(ret);
      }
    }
    i = 0;
    for (; deletedLen > i; ++i) {
      views.splice(deleted[i] - i, 1);
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _createAndActivateAndSortViewsByKey(indexMap) {
    let promises = void 0;
    let ret;
    let view;
    let i = 0;
    const { $controller, _factory, _location, views, _scopes, _oldViews } = this;
    const newLen = indexMap.length;
    for (; newLen > i; ++i) {
      if (indexMap[i] === -2) {
        view = _factory.create();
        views.splice(i, 0, view);
      }
    }
    if (views.length !== newLen) {
      throw createMappedError(814, [views.length, newLen]);
    }
    let source = 0;
    i = 0;
    for (; i < indexMap.length; ++i) {
      if ((source = indexMap[i]) !== -2) {
        views[i] = _oldViews[source];
      }
    }
    const seq = longestIncreasingSubsequence(indexMap);
    const seqLen = seq.length;
    let next;
    let j = seqLen - 1;
    i = newLen - 1;
    for (; i >= 0; --i) {
      view = views[i];
      next = views[i + 1];
      if (indexMap[i] === -2) {
        view.nodes.link(next?.nodes ?? _location);
        view.setLocation(_location);
        setContextualProperties(_scopes[i].overrideContext, i, newLen);
        ret = view.activate(view, $controller, _scopes[i]);
        if (isPromise(ret)) {
          (promises ?? (promises = [])).push(ret);
        }
      } else if (j < 0 || i !== seq[j]) {
        view.nodes.link(next?.nodes ?? _location);
        setContextualProperties(view.scope.overrideContext, i, newLen);
        view.nodes.insertBefore(view.location);
      } else {
        setContextualProperties(view.scope.overrideContext, i, newLen);
        --j;
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  dispose() {
    this.views.forEach(dispose);
    this.views = void 0;
  }
  accept(visitor) {
    const { views } = this;
    if (views !== void 0) {
      for (let i = 0, ii = views.length; i < ii; ++i) {
        if (views[i].accept(visitor) === true) {
          return true;
        }
      }
    }
  }
}
Repeat.$au = {
  type: attrTypeName,
  name: "repeat",
  isTemplateController: true,
  bindables: ["items"]
};
let maxLen = 16;
let prevIndices = new Int32Array(maxLen);
let tailIndices = new Int32Array(maxLen);
function longestIncreasingSubsequence(indexMap) {
  const len = indexMap.length;
  if (len > maxLen) {
    maxLen = len;
    prevIndices = new Int32Array(len);
    tailIndices = new Int32Array(len);
  }
  let cursor = 0;
  let cur = 0;
  let prev = 0;
  let i = 0;
  let j = 0;
  let low = 0;
  let high = 0;
  let mid = 0;
  for (; i < len; i++) {
    cur = indexMap[i];
    if (cur !== -2) {
      j = prevIndices[cursor];
      prev = indexMap[j];
      if (prev !== -2 && prev < cur) {
        tailIndices[i] = j;
        prevIndices[++cursor] = i;
        continue;
      }
      low = 0;
      high = cursor;
      while (low < high) {
        mid = low + high >> 1;
        prev = indexMap[prevIndices[mid]];
        if (prev !== -2 && prev < cur) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      prev = indexMap[prevIndices[low]];
      if (cur < prev || prev === -2) {
        if (low > 0) {
          tailIndices[i] = prevIndices[low - 1];
        }
        prevIndices[low] = i;
      }
    }
  }
  i = ++cursor;
  const result = new Int32Array(i);
  cur = prevIndices[cursor - 1];
  while (cursor-- > 0) {
    result[cursor] = cur;
    cur = tailIndices[cur];
  }
  while (i-- > 0)
    prevIndices[i] = 0;
  return result;
}
class RepeatOverrideContext {
  get $odd() {
    return !this.$even;
  }
  get $even() {
    return this.$index % 2 === 0;
  }
  get $first() {
    return this.$index === 0;
  }
  get $middle() {
    return !this.$first && !this.$last;
  }
  get $last() {
    return this.$index === this.$length - 1;
  }
  constructor($index2 = 0, $length2 = 1) {
    this.$index = $index2;
    this.$length = $length2;
  }
}
const setContextualProperties = (oc, index, length) => {
  oc.$index = index;
  oc.$length = length;
};
const IRepeatableHandlerResolver = /* @__PURE__ */ createInterface("IRepeatableHandlerResolver", (x) => x.singleton(RepeatableHandlerResolver));
class RepeatableHandlerResolver {
  constructor() {
    this._handlers = resolve(all(IRepeatableHandler));
  }
  resolve(value) {
    if (_arrayHandler.handles(value)) {
      return _arrayHandler;
    }
    if (_setHandler.handles(value)) {
      return _setHandler;
    }
    if (_mapHandler.handles(value)) {
      return _mapHandler;
    }
    if (_numberHandler.handles(value)) {
      return _numberHandler;
    }
    if (_nullishHandler.handles(value)) {
      return _nullishHandler;
    }
    const handler = this._handlers.find((x) => x.handles(value));
    if (handler !== void 0) {
      return handler;
    }
    return _unknownHandler;
  }
}
const IRepeatableHandler = /* @__PURE__ */ createInterface("IRepeatableHandler");
const _arrayHandler = {
  handles: isArray,
  getObserver: getCollectionObserver$1,
  /* istanbul ignore next */
  iterate(value, func) {
    const ii = value.length;
    let i = 0;
    for (; i < ii; ++i) {
      func(value[i], i, value);
    }
  }
  // getCount: items => items.length,
};
const _setHandler = {
  handles: isSet,
  getObserver: getCollectionObserver$1,
  iterate(value, func) {
    let i = 0;
    let key;
    for (key of value.keys()) {
      func(key, i++, value);
    }
  }
  // getCount: s => s.size,
};
const _mapHandler = {
  handles: isMap,
  getObserver: getCollectionObserver$1,
  iterate(value, func) {
    let i = 0;
    let entry;
    for (entry of value.entries()) {
      func(entry, i++, value);
    }
  }
  // getCount: s => s.size,
};
const _numberHandler = {
  handles: isNumber,
  iterate(value, func) {
    let i = 0;
    for (; i < value; ++i) {
      func(i, i, value);
    }
  }
  // getCount: v => v,
};
const _nullishHandler = {
  handles: (v) => v == null,
  iterate() {
  }
  // getCount: () => 0,
};
const _unknownHandler = {
  handles(_value) {
    return false;
  },
  iterate(value, _func) {
    throw createMappedError(777, value);
  }
  // getCount: () => 0,
};
const setItem = (hasDestructuredLocal, dec, scope, binding, local, item) => {
  if (hasDestructuredLocal) {
    astAssign(dec, scope, binding, null, item);
  } else {
    scope.bindingContext[local] = item;
  }
};
const getItem = (hasDestructuredLocal, dec, scope, binding, local) => {
  return hasDestructuredLocal ? astEvaluate(dec, scope, binding, null) : scope.bindingContext[local];
};
const getKeyValue = (hasDestructuredLocal, key, dec, scope, binding, local) => {
  if (typeof key === "string") {
    const item = getItem(hasDestructuredLocal, dec, scope, binding, local);
    return item[key];
  }
  return astEvaluate(key, scope, binding, null);
};
const getScope = (oldScopeMap, newScopeMap, key, item, forOf, parentScope, binding, local, hasDestructuredLocal) => {
  let scope = oldScopeMap.get(key);
  if (scope === void 0) {
    scope = createScope(item, forOf, parentScope, binding, local, hasDestructuredLocal);
  } else if (scope instanceof Scope) {
    oldScopeMap.delete(key);
  } else if (scope.length === 1) {
    scope = scope[0];
    oldScopeMap.delete(key);
  } else {
    scope = scope.shift();
  }
  if (newScopeMap.has(key)) {
    const entry = newScopeMap.get(key);
    if (entry instanceof Scope) {
      newScopeMap.set(key, [entry, scope]);
    } else {
      entry.push(scope);
    }
  } else {
    newScopeMap.set(key, scope);
  }
  setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, item);
  return scope;
};
const createScope = (item, forOf, parentScope, binding, local, hasDestructuredLocal) => {
  if (hasDestructuredLocal) {
    const scope = Scope.fromParent(parentScope, new BindingContext(), new RepeatOverrideContext());
    astAssign(forOf.declaration, scope, binding, null, item);
  }
  return Scope.fromParent(parentScope, new BindingContext(local, item), new RepeatOverrideContext());
};
const compareNumber = (a, b) => a - b;
class With {
  constructor() {
    this.view = resolve(IViewFactory).create().setLocation(resolve(IRenderLocation));
  }
  valueChanged(newValue, _oldValue) {
    const $controller = this.$controller;
    const bindings = this.view.bindings;
    let scope;
    let i = 0, ii = 0;
    if ($controller.isActive && bindings != null) {
      scope = Scope.fromParent($controller.scope, newValue === void 0 ? {} : newValue);
      for (ii = bindings.length; ii > i; ++i) {
        bindings[i].bind(scope);
      }
    }
  }
  attaching(initiator, _parent) {
    const { $controller, value } = this;
    const scope = Scope.fromParent($controller.scope, value === void 0 ? {} : value);
    return this.view.activate(initiator, $controller, scope);
  }
  detaching(initiator, _parent) {
    return this.view.deactivate(initiator, this.$controller);
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
With.$au = {
  type: attrTypeName,
  name: "with",
  isTemplateController: true,
  bindables: ["value"]
};
class Switch {
  constructor() {
    this.cases = [];
    this.activeCases = [];
    this.promise = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(_controller, _childController, _target, _instruction) {
    this.view = this._factory.create(this.$controller).setLocation(this._location);
  }
  attaching(initiator, _parent) {
    const view = this.view;
    const $controller = this.$controller;
    this.queue(() => view.activate(initiator, $controller, $controller.scope));
    this.queue(() => this.swap(initiator, this.value));
    return this.promise;
  }
  detaching(initiator, _parent) {
    this.queue(() => {
      const view = this.view;
      return view.deactivate(initiator, this.$controller);
    });
    return this.promise;
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
  valueChanged(_newValue, _oldValue) {
    if (!this.$controller.isActive) {
      return;
    }
    this.queue(() => this.swap(null, this.value));
  }
  caseChanged($case) {
    this.queue(() => this._handleCaseChange($case));
  }
  /** @internal */
  _handleCaseChange($case) {
    const isMatch = $case.isMatch(this.value);
    const activeCases = this.activeCases;
    const numActiveCases = activeCases.length;
    if (!isMatch) {
      if (numActiveCases > 0 && activeCases[0].id === $case.id) {
        return this._clearActiveCases(null);
      }
      return;
    }
    if (numActiveCases > 0 && activeCases[0].id < $case.id) {
      return;
    }
    const newActiveCases = [];
    let fallThrough = $case.fallThrough;
    if (!fallThrough) {
      newActiveCases.push($case);
    } else {
      const cases = this.cases;
      const idx = cases.indexOf($case);
      for (let i = idx, ii = cases.length; i < ii && fallThrough; i++) {
        const c = cases[i];
        newActiveCases.push(c);
        fallThrough = c.fallThrough;
      }
    }
    return onResolve(this._clearActiveCases(null, newActiveCases), () => {
      this.activeCases = newActiveCases;
      return this._activateCases(null);
    });
  }
  swap(initiator, value) {
    const newActiveCases = [];
    let fallThrough = false;
    for (const $case of this.cases) {
      if (fallThrough || $case.isMatch(value)) {
        newActiveCases.push($case);
        fallThrough = $case.fallThrough;
      }
      if (newActiveCases.length > 0 && !fallThrough) {
        break;
      }
    }
    const defaultCase = this.defaultCase;
    if (newActiveCases.length === 0 && defaultCase !== void 0) {
      newActiveCases.push(defaultCase);
    }
    return onResolve(this.activeCases.length > 0 ? this._clearActiveCases(initiator, newActiveCases) : void 0, () => {
      this.activeCases = newActiveCases;
      if (newActiveCases.length === 0) {
        return;
      }
      return this._activateCases(initiator);
    });
  }
  /** @internal */
  _activateCases(initiator) {
    const controller = this.$controller;
    if (!controller.isActive) {
      return;
    }
    const cases = this.activeCases;
    const length = cases.length;
    if (length === 0) {
      return;
    }
    const scope = controller.scope;
    if (length === 1) {
      return cases[0].activate(initiator, scope);
    }
    return onResolveAll(...cases.map(($case) => $case.activate(initiator, scope)));
  }
  /** @internal */
  _clearActiveCases(initiator, newActiveCases = []) {
    const cases = this.activeCases;
    const numCases = cases.length;
    if (numCases === 0) {
      return;
    }
    if (numCases === 1) {
      const firstCase = cases[0];
      if (!newActiveCases.includes(firstCase)) {
        cases.length = 0;
        return firstCase.deactivate(initiator);
      }
      return;
    }
    return onResolve(onResolveAll(...cases.reduce((acc, $case) => {
      if (!newActiveCases.includes($case)) {
        acc.push($case.deactivate(initiator));
      }
      return acc;
    }, [])), () => {
      cases.length = 0;
    });
  }
  queue(action) {
    const previousPromise = this.promise;
    let promise = void 0;
    promise = this.promise = onResolve(onResolve(previousPromise, action), () => {
      if (this.promise === promise) {
        this.promise = void 0;
      }
    });
  }
  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }
    if (this.activeCases.some((x) => x.accept(visitor))) {
      return true;
    }
  }
}
Switch.$au = {
  type: attrTypeName,
  name: "switch",
  isTemplateController: true,
  bindables: ["value"]
};
let caseId = 0;
const bindables$2 = [
  "value",
  {
    name: "fallThrough",
    mode: oneTime,
    set(v) {
      switch (v) {
        case "true":
          return true;
        case "false":
          return false;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        default:
          return !!v;
      }
    }
  }
];
class Case {
  constructor() {
    this.id = ++caseId;
    this.fallThrough = false;
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._locator = resolve(IObserverLocator);
    this._location = resolve(IRenderLocation);
    this._logger = resolve(ILogger).scopeTo(`Case-#${this.id}`);
  }
  link(controller, _childController, _target, _instruction) {
    const switchController = controller.parent;
    const $switch = switchController?.viewModel;
    if ($switch instanceof Switch) {
      this.$switch = $switch;
      this.linkToSwitch($switch);
    } else {
      throw createMappedError(
        815
        /* ErrorNames.switch_invalid_usage */
      );
    }
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  isMatch(value) {
    this._logger.debug("isMatch()");
    const $value = this.value;
    if (isArray($value)) {
      if (this._observer === void 0) {
        this._observer = this._observeCollection($value);
      }
      return $value.includes(value);
    }
    return $value === value;
  }
  valueChanged(newValue, _oldValue) {
    if (isArray(newValue)) {
      this._observer?.unsubscribe(this);
      this._observer = this._observeCollection(newValue);
    } else if (this._observer !== void 0) {
      this._observer.unsubscribe(this);
    }
    this.$switch.caseChanged(this);
  }
  handleCollectionChange() {
    this.$switch.caseChanged(this);
  }
  activate(initiator, scope) {
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(initiator ?? view, this.$controller, scope);
  }
  deactivate(initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(initiator ?? view, this.$controller);
  }
  dispose() {
    this._observer?.unsubscribe(this);
    this.view?.dispose();
    this.view = void 0;
  }
  linkToSwitch(auSwitch) {
    auSwitch.cases.push(this);
  }
  /** @internal */
  _observeCollection($value) {
    const observer = this._locator.getArrayObserver($value);
    observer.subscribe(this);
    return observer;
  }
  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }
    return this.view?.accept(visitor);
  }
}
(() => {
  defineAttribute({ name: "case", bindables: bindables$2, isTemplateController: true }, Case);
})();
class DefaultCase extends Case {
  linkToSwitch($switch) {
    if ($switch.defaultCase !== void 0) {
      throw createMappedError(
        816
        /* ErrorNames.switch_no_multiple_default */
      );
    }
    $switch.defaultCase = this;
  }
}
(() => {
  defineAttribute({ name: "default-case", bindables: bindables$2, isTemplateController: true }, DefaultCase);
})();
var _a, _b, _c;
class PromiseTemplateController {
  constructor() {
    this.preSettledTask = null;
    this.postSettledTask = null;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
    this._platform = resolve(IPlatform);
    this.logger = resolve(ILogger).scopeTo("promise.resolve");
  }
  link(_controller, _childController, _target, _instruction) {
    this.view = this._factory.create(this.$controller).setLocation(this._location);
  }
  attaching(initiator, _parent) {
    const view = this.view;
    const $controller = this.$controller;
    return onResolve(view.activate(initiator, $controller, this.viewScope = Scope.fromParent($controller.scope, {})), () => this.swap(initiator));
  }
  valueChanged(_newValue, _oldValue) {
    if (!this.$controller.isActive) {
      return;
    }
    this.swap(null);
  }
  swap(initiator) {
    const value = this.value;
    if (!isPromise(value)) {
      {
        this.logger.warn(`The value '${safeString(value)}' is not a promise. No change will be done.`);
      }
      return;
    }
    const fulfilled = this.fulfilled;
    const rejected = this.rejected;
    const pending = this.pending;
    const s = this.viewScope;
    let preSettlePromise;
    const $swap = () => {
      void onResolveAll(
        // At first deactivate the fulfilled and rejected views, as well as activate the pending view.
        // The order of these 3 should not necessarily be sequential (i.e. order-irrelevant).
        preSettlePromise = (this.preSettledTask = queueAsyncTask(() => {
          return onResolveAll(fulfilled?.deactivate(initiator), rejected?.deactivate(initiator), pending?.activate(initiator, s));
        })).result.catch((err) => {
          throw err;
        }),
        value.then((data) => {
          if (this.value !== value) {
            return;
          }
          const fulfill = () => {
            this.postSettlePromise = (this.postSettledTask = queueAsyncTask(() => onResolveAll(pending?.deactivate(initiator), rejected?.deactivate(initiator), fulfilled?.activate(initiator, s, data)))).result;
          };
          if (this.preSettledTask.status === tsRunning) {
            void preSettlePromise.then(fulfill);
          } else {
            this.preSettledTask.cancel();
            fulfill();
          }
        }, (err) => {
          if (this.value !== value) {
            return;
          }
          const reject = () => {
            this.postSettlePromise = (this.postSettledTask = queueAsyncTask(() => onResolveAll(pending?.deactivate(initiator), fulfilled?.deactivate(initiator), rejected?.activate(initiator, s, err)))).result;
          };
          if (this.preSettledTask.status === tsRunning) {
            void preSettlePromise.then(reject);
          } else {
            this.preSettledTask.cancel();
            reject();
          }
        })
      );
    };
    if (this.postSettledTask?.status === tsRunning) {
      void this.postSettlePromise.then($swap);
    } else {
      this.postSettledTask?.cancel();
      $swap();
    }
  }
  detaching(initiator, _parent) {
    this.preSettledTask?.cancel();
    this.postSettledTask?.cancel();
    this.preSettledTask = this.postSettledTask = null;
    return this.view.deactivate(initiator, this.$controller);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
PromiseTemplateController.$au = {
  type: attrTypeName,
  name: "promise",
  isTemplateController: true,
  bindables: ["value"]
};
class PendingTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).pending = this;
  }
  activate(initiator, scope) {
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
PendingTemplateController.$au = {
  type: attrTypeName,
  name: "pending",
  isTemplateController: true,
  bindables: {
    value: { mode: toView }
  }
};
class FulfilledTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).fulfilled = this;
  }
  activate(initiator, scope, resolvedValue) {
    this.value = resolvedValue;
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
FulfilledTemplateController.$au = {
  type: attrTypeName,
  name: "then",
  isTemplateController: true,
  bindables: {
    value: { mode: fromView }
  }
};
class RejectedTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).rejected = this;
  }
  activate(initiator, scope, error2) {
    this.value = error2;
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
RejectedTemplateController.$au = {
  type: attrTypeName,
  name: "catch",
  isTemplateController: true,
  bindables: {
    value: { mode: fromView }
  }
};
function getPromiseController(controller) {
  const promiseController = controller.parent;
  const $promise = promiseController?.viewModel;
  if ($promise instanceof PromiseTemplateController) {
    return $promise;
  }
  throw createMappedError(
    813
    /* ErrorNames.promise_invalid_usage */
  );
}
class PromiseAttributePattern {
  "promise.resolve"(name2, value) {
    return new AttrSyntax(name2, value, "promise", "bind");
  }
}
_a = Symbol.metadata;
PromiseAttributePattern[_a] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "promise.resolve", symbols: "" }], PromiseAttributePattern)
};
class FulfilledAttributePattern {
  "then"(name2, value) {
    return new AttrSyntax(name2, value, "then", "from-view");
  }
}
_b = Symbol.metadata;
FulfilledAttributePattern[_b] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "then", symbols: "" }], FulfilledAttributePattern)
};
class RejectedAttributePattern {
  "catch"(name2, value) {
    return new AttrSyntax(name2, value, "catch", "from-view");
  }
}
_c = Symbol.metadata;
RejectedAttributePattern[_c] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "catch", symbols: "" }], RejectedAttributePattern)
};
class Focus {
  constructor() {
    this._needsApply = false;
    this._element = resolve(INode);
    this._platform = resolve(IPlatform);
  }
  binding() {
    this.valueChanged();
  }
  /**
   * Invoked everytime the bound value changes.
   *
   * @param newValue - The new value.
   */
  valueChanged() {
    if (this.$controller.isActive) {
      this._apply();
    } else {
      this._needsApply = true;
    }
  }
  /**
   * Invoked when the attribute is attached to the DOM.
   */
  attached() {
    if (this._needsApply) {
      this._needsApply = false;
      this._apply();
    }
    this._element.addEventListener("focus", this);
    this._element.addEventListener("blur", this);
  }
  /**
   * Invoked when the attribute is afterDetachChildren from the DOM.
   */
  detaching() {
    const el = this._element;
    el.removeEventListener("focus", this);
    el.removeEventListener("blur", this);
  }
  /**
   * EventTarget interface handler for better memory usage
   */
  handleEvent(e) {
    if (e.type === "focus") {
      this.value = true;
    } else if (!this._isElFocused) {
      this.value = false;
    }
  }
  /**
   * Focus/blur based on current value
   *
   * @internal
   */
  _apply() {
    const el = this._element;
    const isFocused = this._isElFocused;
    const shouldFocus = this.value;
    if (shouldFocus && !isFocused) {
      el.focus();
    } else if (!shouldFocus && isFocused) {
      el.blur();
    }
  }
  /** @internal */
  get _isElFocused() {
    return this._element === this._platform.document.activeElement;
  }
}
Focus.$au = {
  type: attrTypeName,
  name: "focus",
  bindables: {
    value: { mode: twoWay }
  }
};
class Portal {
  constructor() {
    this.position = "beforeend";
    this.strict = false;
    const factory = resolve(IViewFactory);
    const originalLoc = resolve(IRenderLocation);
    const p = resolve(IPlatform);
    this._platform = p;
    this._resolvedTarget = p.document.createElement("div");
    (this.view = factory.create()).setLocation(this._targetLocation = createLocation(p));
    setEffectiveParentNode(this.view.nodes, originalLoc);
  }
  attaching(initiator) {
    if (this.callbackContext == null) {
      this.callbackContext = this.$controller.scope.bindingContext;
    }
    const newTarget = this._resolvedTarget = this._getTarget();
    this._moveLocation(newTarget, this.position);
    return this._activating(initiator, newTarget);
  }
  detaching(initiator) {
    return this._deactivating(initiator, this._resolvedTarget);
  }
  targetChanged() {
    const { $controller } = this;
    if (!$controller.isActive) {
      return;
    }
    const newTarget = this._getTarget();
    if (this._resolvedTarget === newTarget) {
      return;
    }
    this._resolvedTarget = newTarget;
    const ret = onResolve(this._deactivating(null, newTarget), () => {
      this._moveLocation(newTarget, this.position);
      return this._activating(null, newTarget);
    });
    if (isPromise(ret)) {
      ret.catch(rethrow);
    }
  }
  positionChanged() {
    const { $controller, _resolvedTarget } = this;
    if (!$controller.isActive) {
      return;
    }
    const ret = onResolve(this._deactivating(null, _resolvedTarget), () => {
      this._moveLocation(_resolvedTarget, this.position);
      return this._activating(null, _resolvedTarget);
    });
    if (isPromise(ret)) {
      ret.catch(rethrow);
    }
  }
  /** @internal */
  _activating(initiator, target) {
    const { activating: activating2, callbackContext, view } = this;
    return onResolve(activating2?.call(callbackContext, target, view), () => {
      return this._activate(initiator, target);
    });
  }
  /** @internal */
  _activate(initiator, target) {
    const { $controller, view } = this;
    if (initiator === null) {
      view.nodes.insertBefore(this._targetLocation);
    } else {
      return onResolve(view.activate(initiator ?? view, $controller, $controller.scope), () => {
        return this._activated(target);
      });
    }
    return this._activated(target);
  }
  /** @internal */
  _activated(target) {
    const { activated: activated2, callbackContext, view } = this;
    return activated2?.call(callbackContext, target, view);
  }
  /** @internal */
  _deactivating(initiator, target) {
    const { deactivating: deactivating2, callbackContext, view } = this;
    return onResolve(deactivating2?.call(callbackContext, target, view), () => {
      return this._deactivate(initiator, target);
    });
  }
  /** @internal */
  _deactivate(initiator, target) {
    const { $controller, view } = this;
    if (initiator === null) {
      view.nodes.remove();
    } else {
      return onResolve(view.deactivate(initiator, $controller), () => {
        return this._deactivated(target);
      });
    }
    return this._deactivated(target);
  }
  /** @internal */
  _deactivated(target) {
    const { deactivated: deactivated2, callbackContext, view } = this;
    return onResolve(deactivated2?.call(callbackContext, target, view), () => this._removeLocation());
  }
  /** @internal */
  _getTarget() {
    const p = this._platform;
    const $document = p.document;
    let target = this.target;
    let context = this.renderContext;
    if (target === "") {
      if (this.strict) {
        throw createMappedError(
          811
          /* ErrorNames.portal_query_empty */
        );
      }
      return $document.body;
    }
    if (isString(target)) {
      let queryContext = $document;
      if (isString(context)) {
        context = $document.querySelector(context);
      }
      if (context instanceof p.Node) {
        queryContext = context;
      }
      target = queryContext.querySelector(target);
    }
    if (target instanceof p.Node) {
      return target;
    }
    if (target == null) {
      if (this.strict) {
        throw createMappedError(
          812
          /* ErrorNames.portal_no_target */
        );
      }
      return $document.body;
    }
    return target;
  }
  /** @internal */
  _removeLocation() {
    this._targetLocation.remove();
    this._targetLocation.$start.remove();
  }
  /** @internal */
  _moveLocation(target, position) {
    const end2 = this._targetLocation;
    const start2 = end2.$start;
    const parent = target.parentNode;
    const nodes = [start2, end2];
    switch (position) {
      case "beforeend":
        insertManyBefore(target, null, nodes);
        break;
      case "afterbegin":
        insertManyBefore(target, target.firstChild, nodes);
        break;
      case "beforebegin":
        insertManyBefore(parent, target, nodes);
        break;
      case "afterend":
        insertManyBefore(parent, target.nextSibling, nodes);
        break;
      /* istanbul ignore next */
      default:
        throw createMappedError(779, position);
    }
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
    this.callbackContext = null;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
Portal.$au = {
  type: attrTypeName,
  name: "portal",
  isTemplateController: true,
  bindables: [
    { name: "target", primary: true },
    "position",
    "activated",
    "activating",
    "callbackContext",
    { name: "renderContext", callback: "targetChanged" },
    "strict",
    "deactivated",
    "deactivating"
  ]
  // bindables: {
  //   target: { primary: true },
  //   position: true,
  //   renderContext: { callback: 'targetChanged' },
  //   activated: true,
  //   activating: true,
  //   callbackContext: true,
  //   deactivated: true,
  //   deactivating: true,
  //   strict: true
  // }
};
let emptyTemplate;
class AuSlot {
  constructor() {
    this._parentScope = null;
    this._outerScope = null;
    this._attached = false;
    this.expose = null;
    this.slotchange = null;
    this._subs = /* @__PURE__ */ new Set();
    this._observer = null;
    const hdrContext = resolve(IHydrationContext);
    const location = resolve(IRenderLocation);
    const instruction = resolve(IInstruction);
    const rendering = resolve(IRendering);
    const slotName = this.name = instruction.data.name;
    const fallback = instruction.projections?.[defaultSlotName];
    const projection = hdrContext.instruction?.projections?.[slotName];
    const contextContainer = hdrContext.controller.container;
    let factory;
    let container;
    if (projection == null) {
      container = contextContainer.createChild({ inheritParentResources: true });
      factory = rendering.getViewFactory(fallback ?? (emptyTemplate ??= CustomElementDefinition.create({
        name: "au-slot-empty-template",
        template: "",
        needsCompile: false
      })), container);
      this._hasProjection = false;
    } else {
      container = contextContainer.createChild();
      container.useResources(hdrContext.parent.controller.container);
      registerResolver(container, IHydrationContext, new InstanceProvider(void 0, hdrContext.parent));
      factory = rendering.getViewFactory(projection, container);
      this._hasProjection = true;
      this._slotwatchers = contextContainer.getAll(IAuSlotWatcher, false)?.filter((w) => w.slotName === "*" || w.slotName === slotName) ?? emptyArray;
    }
    this._hasSlotWatcher = (this._slotwatchers ??= emptyArray).length > 0;
    this._hdrContext = hdrContext;
    this.view = factory.create().setLocation(this._location = location);
  }
  get nodes() {
    const nodes = [];
    const location = this._location;
    let curr = location.$start.nextSibling;
    while (curr != null && curr !== location) {
      if (curr.nodeType !== /* comment */
      8) {
        nodes.push(curr);
      }
      curr = curr.nextSibling;
    }
    return nodes;
  }
  subscribe(subscriber) {
    this._subs.add(subscriber);
  }
  unsubscribe(subscriber) {
    this._subs.delete(subscriber);
  }
  binding(_initiator, parent) {
    this._parentScope = parent.scope;
    while (parent.vmKind === "synthetic" && parent.parent?.viewModel instanceof AuSlot) {
      parent = parent.parent.parent;
    }
    const host = parent.scope.bindingContext;
    let outerScope;
    if (this._hasProjection) {
      outerScope = this._hdrContext.controller.scope.parent;
      (this._outerScope = Scope.fromParent(outerScope, outerScope.bindingContext)).overrideContext.$host = this.expose ?? host;
    }
  }
  attaching(initiator, _parent) {
    return onResolve(this.view.activate(initiator, this.$controller, this._hasProjection ? this._outerScope : this._parentScope), () => {
      if (this._hasSlotWatcher || isFunction(this.slotchange)) {
        this._slotwatchers.forEach((w) => w.watch(this));
        this._observe();
        this._notifySlotChange();
        this._attached = true;
      }
    });
  }
  detaching(initiator, _parent) {
    this._attached = false;
    this._unobserve();
    this._slotwatchers.forEach((w) => w.unwatch(this));
    return this.view.deactivate(initiator, this.$controller);
  }
  exposeChanged(v) {
    if (this._hasProjection && this._outerScope != null) {
      this._outerScope.overrideContext.$host = v;
    }
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
  /** @internal */
  _observe() {
    if (this._observer != null) {
      return;
    }
    const location = this._location;
    const parent = location.parentElement;
    if (parent == null) {
      return;
    }
    (this._observer = createMutationObserver(parent, (records) => {
      if (isMutationWithinLocation(location, records)) {
        this._notifySlotChange();
      }
    })).observe(parent, { childList: true });
  }
  /** @internal */
  _unobserve() {
    this._observer?.disconnect();
    this._observer = null;
  }
  /** @internal */
  _notifySlotChange() {
    const nodes = this.nodes;
    const subs = new Set(this._subs);
    let sub;
    if (this._attached) {
      this.slotchange?.call(void 0, this.name, nodes);
    }
    for (sub of subs) {
      sub.handleSlotChange(this, nodes);
    }
  }
}
AuSlot.$au = {
  type: elementTypeName,
  name: "au-slot",
  template: null,
  containerless: true,
  processContent(el, p, data) {
    data.name = el.getAttribute("name") ?? defaultSlotName;
    let node = el.firstChild;
    let next = null;
    while (node !== null) {
      next = node.nextSibling;
      if (isElement$1(node) && node.hasAttribute(auslotAttr)) {
        {
          console.warn(`[DEV:aurelia] detected [au-slot] attribute on a child node`, `of an <au-slot> element: "<${node.nodeName} au-slot>".`, `This element will be ignored and removed`);
        }
        el.removeChild(node);
      }
      node = next;
    }
  },
  bindables: ["expose", "slotchange"]
};
const comparePosition = (a, b) => a.compareDocumentPosition(b);
const isMutationWithinLocation = (location, records) => {
  for (const { addedNodes, removedNodes, nextSibling } of records) {
    let i = 0;
    let ii = addedNodes.length;
    let node;
    for (; i < ii; ++i) {
      node = addedNodes[i];
      if (comparePosition(location.$start, node) === /* DOCUMENT_POSITION_FOLLOWING */
      4 && comparePosition(location, node) === /* DOCUMENT_POSITION_PRECEDING */
      2) {
        return true;
      }
    }
    if (removedNodes.length > 0) {
      if (nextSibling != null && comparePosition(location.$start, nextSibling) === /* DOCUMENT_POSITION_FOLLOWING */
      4 && comparePosition(location, nextSibling) === /* DOCUMENT_POSITION_PRECEDING */
      2) {
        return true;
      }
    }
  }
};
class AuCompose {
  constructor() {
    this.scopeBehavior = "auto";
    this._composition = void 0;
    this.tag = null;
    this._container = resolve(IContainer);
    this.parent = resolve(IController);
    this._host = resolve(INode);
    this._location = resolve(IRenderLocation);
    this._platform = resolve(IPlatform);
    this._rendering = resolve(IRendering);
    this._instruction = resolve(IInstruction);
    this._contextFactory = resolve(transient(CompositionContextFactory));
    this._compiler = resolve(ITemplateCompiler);
    this._hydrationContext = resolve(IHydrationContext);
    this._exprParser = resolve(IExpressionParser);
    this._observerLocator = resolve(IObserverLocator);
    this._attached = false;
  }
  get composing() {
    return this._composing;
  }
  get composition() {
    return this._composition;
  }
  attaching(initiator, _parent) {
    this._attached = true;
    return this._composing = onResolve(this.queue(new ChangeInfo(this.template, this.component, this.model, void 0), initiator), (context) => {
      if (this._contextFactory._isCurrent(context)) {
        this._composing = void 0;
      }
    });
  }
  detaching(initiator) {
    this._attached = false;
    const cmpstn = this._composition;
    const pending = this._composing;
    this._contextFactory.invalidate();
    this._composition = this._composing = void 0;
    return onResolve(pending, () => cmpstn?.deactivate(initiator));
  }
  /** @internal */
  propertyChanged(name2) {
    if (!this._attached)
      return;
    if (name2 === "composing" || name2 === "composition")
      return;
    if (name2 === "model" && this._composition != null) {
      this._composition.update(this.model);
      return;
    }
    if (name2 === "tag" && this._composition?.controller.vmKind === vmkCe) {
      {
        console.warn("[DEV:aurelia] Changing tag name of a custom element composition is ignored.");
      }
      return;
    }
    this._composing = onResolve(this._composing, () => onResolve(this.queue(new ChangeInfo(this.template, this.component, this.model, name2), void 0), (context) => {
      if (this._contextFactory._isCurrent(context)) {
        this._composing = void 0;
      }
    }));
  }
  /** @internal */
  queue(change, initiator) {
    const factory = this._contextFactory;
    const prevCompositionCtrl = this._composition;
    return onResolve(factory.create(change), (context) => {
      if (factory._isCurrent(context)) {
        return onResolve(this.compose(context), (result) => {
          if (factory._isCurrent(context)) {
            return onResolve(result.activate(initiator), () => {
              if (factory._isCurrent(context)) {
                this._composition = result;
                return onResolve(prevCompositionCtrl?.deactivate(initiator), () => context);
              } else {
                return onResolve(
                  result.controller.deactivate(result.controller, this.$controller),
                  // todo: do we need to deactivate?
                  () => {
                    result.controller.dispose();
                    return context;
                  }
                );
              }
            });
          }
          result.controller.dispose();
          return context;
        });
      }
      return context;
    });
  }
  /** @internal */
  compose(context) {
    const { _template: template2, _component: component, _model: model } = context.change;
    const { _container: container, $controller, _location: loc, _instruction } = this;
    const vmDef = this._getDefinition(this._hydrationContext.controller.container, component);
    const childCtn = container.createChild();
    const compositionHost = this._platform.document.createElement(vmDef == null ? this.tag ?? "div" : vmDef.name);
    loc.parentNode.insertBefore(compositionHost, loc);
    let compositionLocation;
    if (vmDef == null) {
      compositionLocation = this.tag == null ? convertToRenderLocation(compositionHost) : null;
    } else {
      compositionLocation = vmDef.containerless ? convertToRenderLocation(compositionHost) : null;
    }
    const removeCompositionHost = () => {
      compositionHost.remove();
      if (compositionLocation != null) {
        let curr = compositionLocation.$start.nextSibling;
        let next = null;
        while (curr !== null && curr !== compositionLocation) {
          next = curr.nextSibling;
          curr.remove();
          curr = next;
        }
        compositionLocation.$start?.remove();
        compositionLocation.remove();
      }
    };
    const comp = this._createComponentInstance(childCtn, typeof component === "string" ? vmDef.Type : component, compositionHost, compositionLocation);
    const compose = () => {
      const aucomposeCapturedAttrs = _instruction.captures ?? emptyArray;
      if (vmDef !== null) {
        const capture = vmDef.capture;
        const [capturedBindingAttrs, transferedToHostBindingAttrs] = aucomposeCapturedAttrs.reduce((attrGroups, attr) => {
          const shouldCapture = !(attr.target in vmDef.bindables) && (capture === true || isFunction(capture) && !!capture(attr.target));
          attrGroups[shouldCapture ? 0 : 1].push(attr);
          return attrGroups;
        }, [[], []]);
        const controller = Controller.$el(childCtn, comp, compositionHost, {
          projections: _instruction.projections,
          captures: capturedBindingAttrs
        }, vmDef, compositionLocation);
        this._createSpreadBindings(compositionHost, vmDef, transferedToHostBindingAttrs).forEach((b) => controller.addBinding(b));
        return new CompositionController(
          controller,
          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, $controller.scope.parent),
          // todo: call deactivate on the component component
          (deactachInitiator) => onResolve(controller.deactivate(deactachInitiator ?? controller, $controller), removeCompositionHost),
          // casting is technically incorrect
          // but it's ignored in the caller anyway
          (model2) => comp.activate?.(model2),
          context
        );
      } else {
        const targetDef = CustomElementDefinition.create({
          name: CustomElement.generateName(),
          template: template2
        });
        const viewFactory = this._rendering.getViewFactory(targetDef, childCtn);
        const controller = Controller.$view(viewFactory, $controller);
        const scope = this.scopeBehavior === "auto" ? Scope.fromParent(this.parent.scope, comp) : Scope.create(comp);
        controller.setHost(compositionHost);
        if (compositionLocation == null) {
          this._createSpreadBindings(compositionHost, targetDef, aucomposeCapturedAttrs).forEach((b) => controller.addBinding(b));
        } else {
          controller.setLocation(compositionLocation);
        }
        return new CompositionController(
          controller,
          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, scope),
          // todo: call deactivate on the component
          // a difference with composing custom element is that we leave render location/host alone
          // as they all share the same host/render location
          (detachInitiator) => onResolve(controller.deactivate(detachInitiator ?? controller, $controller), removeCompositionHost),
          // casting is technically incorrect
          // but it's ignored in the caller anyway
          (model2) => comp.activate?.(model2),
          context
        );
      }
    };
    if ("activate" in comp) {
      return onResolve(comp.activate(model), () => compose());
    } else {
      return compose();
    }
  }
  /** @internal */
  _createComponentInstance(container, comp, host, location) {
    if (comp == null) {
      return new EmptyComponent();
    }
    if (typeof comp === "object") {
      return comp;
    }
    const p = this._platform;
    registerHostNode(container, host, p);
    registerResolver(container, IRenderLocation, new InstanceProvider("IRenderLocation", location));
    const instance = container.invoke(comp);
    registerResolver(container, comp, new InstanceProvider("au-compose.component", instance));
    return instance;
  }
  /** @internal */
  _getDefinition(container, component) {
    if (typeof component === "string") {
      const def2 = CustomElement.find(container, component);
      if (def2 == null) {
        throw createMappedError(806, component);
      }
      return def2;
    }
    const Ctor = isFunction(component) ? component : component?.constructor;
    return CustomElement.isType(Ctor, void 0) ? CustomElement.getDefinition(Ctor, null) : null;
  }
  /** @internal */
  _createSpreadBindings(host, def2, capturedAttrs) {
    const transferHydrationContext = new HydrationContext(this.$controller, { projections: null, captures: capturedAttrs }, this._hydrationContext.parent);
    return SpreadBinding.create(transferHydrationContext, host, def2, this._rendering, this._compiler, this._platform, this._exprParser, this._observerLocator);
  }
}
AuCompose.$au = {
  type: elementTypeName,
  name: "au-compose",
  capture: true,
  containerless: true,
  bindables: [
    "template",
    "component",
    "model",
    { name: "scopeBehavior", set: (v) => {
      if (v === "scoped" || v === "auto") {
        return v;
      }
      throw createMappedError(805, v);
    } },
    { name: "composing", mode: fromView },
    { name: "composition", mode: fromView },
    "tag"
  ]
};
class EmptyComponent {
}
class CompositionContextFactory {
  constructor() {
    this.id = 0;
  }
  _isCurrent(context) {
    return context.id === this.id;
  }
  create(changes) {
    return onResolve(changes.load(), (loaded) => new CompositionContext(++this.id, loaded));
  }
  // simplify increasing the id will invalidate all previously created context
  invalidate() {
    this.id++;
  }
}
class ChangeInfo {
  constructor(_template, _component, _model, _src) {
    this._template = _template;
    this._component = _component;
    this._model = _model;
    this._src = _src;
  }
  load() {
    if (isPromise(this._template) || isPromise(this._component)) {
      return Promise.all([this._template, this._component]).then(([template2, component]) => {
        return new LoadedChangeInfo(template2, component, this._model, this._src);
      });
    } else {
      return new LoadedChangeInfo(this._template, this._component, this._model, this._src);
    }
  }
}
class LoadedChangeInfo {
  constructor(_template, _component, _model, _src) {
    this._template = _template;
    this._component = _component;
    this._model = _model;
    this._src = _src;
  }
}
class CompositionContext {
  constructor(id2, change) {
    this.id = id2;
    this.change = change;
  }
}
class CompositionController {
  constructor(controller, start2, stop, update, context) {
    this.controller = controller;
    this.start = start2;
    this.stop = stop;
    this.update = update;
    this.context = context;
    this.state = 0;
  }
  activate(initiator) {
    if (this.state !== 0) {
      throw createMappedError(807, this);
    }
    this.state = 1;
    return this.start(initiator);
  }
  deactivate(detachInitator) {
    switch (this.state) {
      case 1:
        this.state = -1;
        return this.stop(detachInitator);
      case -1:
        throw createMappedError(
          808
          /* ErrorNames.au_compose_duplicate_deactivate */
        );
      default:
        this.state = -1;
    }
  }
}
const ISanitizer = /* @__PURE__ */ createInterface("ISanitizer", (x) => x.singleton(class {
  sanitize() {
    throw createMappedError(99, "sanitize");
  }
}));
class SanitizeValueConverter {
  constructor() {
    this._sanitizer = resolve(ISanitizer);
  }
  /**
   * Process the provided markup that flows to the view.
   *
   * @param untrustedMarkup - The untrusted markup to be sanitized.
   */
  toView(untrustedMarkup) {
    if (untrustedMarkup == null) {
      return null;
    }
    return this._sanitizer.sanitize(untrustedMarkup);
  }
}
SanitizeValueConverter.$au = {
  type: converterTypeName,
  name: "sanitize"
};
class Show {
  constructor() {
    this.el = resolve(INode);
    this.p = resolve(IPlatform);
    this._isActive = false;
    this._isQueued = false;
    this.$val = "";
    this.$prio = "";
    this.update = () => {
      this._isQueued = false;
      if (Boolean(this.value) !== this._isToggled) {
        if (this._isToggled === this._base) {
          this._isToggled = !this._base;
          this.$val = this.el.style.getPropertyValue("display");
          this.$prio = this.el.style.getPropertyPriority("display");
          this.el.style.setProperty("display", "none", "important");
        } else {
          this._isToggled = this._base;
          this.el.style.setProperty("display", this.$val, this.$prio);
          if (this.el.getAttribute("style") === "") {
            this.el.removeAttribute("style");
          }
        }
      }
    };
    const instr = resolve(IInstruction);
    this._isToggled = this._base = instr.alias !== "hide";
  }
  binding() {
    this._isActive = true;
    this.update();
  }
  detaching() {
    this._isActive = false;
    this._isQueued = false;
  }
  valueChanged() {
    if (this._isActive && !this._isQueued) {
      this._isQueued = true;
      queueTask(this.update);
    }
  }
}
Show.$au = {
  type: attrTypeName,
  name: "show",
  bindables: ["value"],
  aliases: ["hide"]
};
const DefaultComponents$1 = [
  RuntimeTemplateCompilerImplementation,
  DirtyChecker,
  NodeObserverLocator
];
const DefaultBindingSyntax = [
  RefAttributePattern,
  DotSeparatedAttributePattern,
  EventAttributePattern,
  EventModifierRegistration
];
const DefaultBindingLanguage = [
  DefaultBindingCommand,
  OneTimeBindingCommand,
  FromViewBindingCommand,
  ToViewBindingCommand,
  TwoWayBindingCommand,
  ForBindingCommand,
  RefBindingCommand,
  TriggerBindingCommand,
  CaptureBindingCommand,
  ClassBindingCommand,
  StyleBindingCommand,
  AttrBindingCommand,
  SpreadValueBindingCommand
];
const DefaultResources$1 = [
  DebounceBindingBehavior,
  OneTimeBindingBehavior,
  ToViewBindingBehavior,
  FromViewBindingBehavior,
  SignalBindingBehavior,
  ThrottleBindingBehavior,
  TwoWayBindingBehavior,
  SanitizeValueConverter,
  If,
  Else,
  Repeat,
  With,
  Switch,
  Case,
  DefaultCase,
  PromiseTemplateController,
  PendingTemplateController,
  FulfilledTemplateController,
  RejectedTemplateController,
  PromiseAttributePattern,
  FulfilledAttributePattern,
  RejectedAttributePattern,
  AttrBindingBehavior,
  SelfBindingBehavior,
  UpdateTriggerBindingBehavior,
  AuCompose,
  Portal,
  Focus,
  Show,
  AuSlot
];
const DefaultRenderers = [
  PropertyBindingRenderer,
  IteratorBindingRenderer,
  RefBindingRenderer,
  InterpolationBindingRenderer,
  SetPropertyRenderer,
  CustomElementRenderer,
  CustomAttributeRenderer,
  TemplateControllerRenderer,
  LetElementRenderer,
  ListenerBindingRenderer,
  AttributeBindingRenderer,
  SetAttributeRenderer,
  SetClassAttributeRenderer,
  SetStyleAttributeRenderer,
  StylePropertyBindingRenderer,
  TextBindingRenderer,
  SpreadRenderer,
  SpreadValueRenderer
];
const StandardConfiguration = /* @__PURE__ */ createConfiguration(noop);
function createConfiguration(optionsProvider) {
  return {
    optionsProvider,
    /**
     * Apply this configuration to the provided container.
     */
    register(container) {
      const runtimeConfigurationOptions = {
        coercingOptions: {
          enableCoercion: false,
          coerceNullish: false
        }
      };
      optionsProvider(runtimeConfigurationOptions);
      return container.register(instanceRegistration(ICoercionConfiguration, runtimeConfigurationOptions.coercingOptions), ExpressionParser, ...DefaultComponents$1, ...DefaultResources$1, ...DefaultBindingSyntax, ...DefaultBindingLanguage, ...DefaultRenderers);
    },
    customize(cb) {
      return createConfiguration(cb ?? optionsProvider);
    }
  };
}
const PLATFORM = BrowserPlatform.getOrCreate(globalThis);
function createContainer() {
  return DI.createContainer().register(Registration.instance(IPlatform, PLATFORM), StandardConfiguration);
}
class Aurelia2 extends Aurelia$1 {
  constructor(container = createContainer()) {
    super(container);
  }
  static app(config) {
    return new Aurelia2().app(config);
  }
  static enhance(config) {
    return new Aurelia2().enhance(config);
  }
  static register(...params) {
    return new Aurelia2().register(...params);
  }
  app(config) {
    if (CustomElement.isType(config)) {
      const definition = CustomElement.getDefinition(config);
      let host = document.querySelector(definition.name);
      if (host === null) {
        host = document.body;
      }
      return super.app({
        host,
        component: config
      });
    }
    return super.app(config);
  }
}
class Parameter {
  constructor(name2, isOptional, isStar, pattern) {
    this.name = name2;
    this.isOptional = isOptional;
    this.isStar = isStar;
    this.pattern = pattern;
  }
  satisfiesPattern(value) {
    if (this.pattern === null)
      return true;
    this.pattern.lastIndex = 0;
    return this.pattern.test(value);
  }
}
class ConfigurableRoute {
  constructor(path, caseSensitive, handler) {
    this.path = path;
    this.caseSensitive = caseSensitive;
    this.handler = handler;
  }
}
class Endpoint {
  get residualEndpoint() {
    return this._residualEndpoint;
  }
  /** @internal */
  set residualEndpoint(endpoint) {
    if (this._residualEndpoint !== null)
      throw new Error("Residual endpoint is already set");
    this._residualEndpoint = endpoint;
  }
  constructor(route2, params) {
    this.route = route2;
    this.params = params;
    this._residualEndpoint = null;
  }
  equalsOrResidual(other) {
    return other != null && this === other || this._residualEndpoint === other;
  }
}
class RecognizedRoute {
  constructor(endpoint, params) {
    this.endpoint = endpoint;
    const $params = /* @__PURE__ */ Object.create(null);
    for (const key in params) {
      const value = params[key];
      $params[key] = value != null ? decodeURIComponent(value) : value;
    }
    this.params = Object.freeze($params);
  }
}
class Candidate {
  constructor(chars, states, skippedStates, result) {
    this.chars = chars;
    this.states = states;
    this.skippedStates = skippedStates;
    this.result = result;
    this.params = null;
    this.isConstrained = false;
    this.satisfiesConstraints = null;
    this.head = states[states.length - 1];
    this.endpoint = this.head?.endpoint;
  }
  advance(ch) {
    const { chars, states, skippedStates, result } = this;
    let stateToAdd = null;
    let matchCount = 0;
    const state = states[states.length - 1];
    function $process(nextState, skippedState) {
      if (nextState.isMatch(ch)) {
        if (++matchCount === 1) {
          stateToAdd = nextState;
        } else {
          result.add(new Candidate(chars.concat(ch), states.concat(nextState), skippedState === null ? skippedStates : skippedStates.concat(skippedState), result));
        }
      }
      if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {
        if (nextState.nextStates.length > 1) {
          throw createError(`${nextState.nextStates.length} nextStates`);
        }
        const separator = nextState.nextStates[0];
        if (!separator.isSeparator) {
          throw createError(`Not a separator`);
        }
        if (separator.nextStates !== null) {
          for (const $nextState of separator.nextStates) {
            $process($nextState, nextState);
          }
        }
      }
    }
    if (state.isDynamic) {
      $process(state, null);
    }
    if (state.nextStates !== null) {
      for (const nextState of state.nextStates) {
        $process(nextState, null);
      }
    }
    if (stateToAdd !== null) {
      states.push(this.head = stateToAdd);
      chars.push(ch);
      this.isConstrained = this.isConstrained || stateToAdd.isDynamic && stateToAdd.segment.isConstrained;
      if (stateToAdd.endpoint !== null) {
        this.endpoint = stateToAdd.endpoint;
      }
    }
    if (matchCount === 0) {
      result.remove(this);
    }
  }
  /** @internal */
  _finalize() {
    function collectSkippedStates(skippedStates, state) {
      const nextStates = state.nextStates;
      if (nextStates !== null) {
        if (nextStates.length === 1 && nextStates[0].segment === null) {
          collectSkippedStates(skippedStates, nextStates[0]);
        } else {
          for (const nextState of nextStates) {
            if (nextState.isOptional && nextState.endpoint !== null) {
              skippedStates.push(nextState);
              if (nextState.nextStates !== null) {
                for (const $nextState of nextState.nextStates) {
                  collectSkippedStates(skippedStates, $nextState);
                }
              }
              break;
            }
          }
        }
      }
    }
    collectSkippedStates(this.skippedStates, this.head);
    if (!this.isConstrained)
      return true;
    this._getParams();
    return this.satisfiesConstraints;
  }
  /** @internal */
  _getParams() {
    let params = this.params;
    if (params != null)
      return params;
    const { states, chars, endpoint } = this;
    params = {};
    this.satisfiesConstraints = true;
    for (const param of endpoint.params) {
      params[param.name] = void 0;
    }
    for (let i = 0, ii = states.length; i < ii; ++i) {
      const state = states[i];
      if (state.isDynamic) {
        const segment = state.segment;
        const name2 = segment.name;
        if (params[name2] === void 0) {
          params[name2] = chars[i];
        } else {
          params[name2] += chars[i];
        }
        const checkConstraint = state.isConstrained && !Object.is(states[i + 1]?.segment, segment);
        if (!checkConstraint)
          continue;
        this.satisfiesConstraints = this.satisfiesConstraints && state.satisfiesConstraint(params[name2]);
      }
    }
    if (this.satisfiesConstraints) {
      this.params = params;
    }
    return params;
  }
  /**
   * Compares this candidate to another candidate to determine the correct sorting order.
   *
   * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares
   * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types
   *
   * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the
   * same sorting value because they both consist of two static segments and one dynamic segment.
   *
   * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,
   * and static wins over dynamic.
   *
   * ### NOTE
   * This algorithm violates some of the invariants of v1's algorithm,
   * but those invariants were arguably not very sound to begin with. Example:
   *
   * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`
   * - in v1, the first would win because that match has fewer stars
   * - in v2, the second will win because there is a bigger static match at the start of the pattern
   *
   * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of
   * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,
   * intentionally or unintentionally.
   *
   * @param b - The candidate to compare this to.
   * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.
   * This will bring the candidate with the highest score to the first position of the array.
   */
  compareTo(b) {
    const statesA = this.states;
    const statesB = b.states;
    for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {
      let stateA = statesA[iA];
      if (stateA === void 0) {
        return 1;
      }
      let stateB = statesB[iB];
      if (stateB === void 0) {
        return -1;
      }
      let segmentA = stateA.segment;
      let segmentB = stateB.segment;
      if (segmentA === null) {
        if (segmentB === null) {
          ++iB;
          continue;
        }
        if ((stateA = statesA[++iA]) === void 0) {
          return 1;
        }
        segmentA = stateA.segment;
      } else if (segmentB === null) {
        if ((stateB = statesB[++iB]) === void 0) {
          return -1;
        }
        segmentB = stateB.segment;
      }
      if (segmentA.kind < segmentB.kind) {
        return 1;
      }
      if (segmentA.kind > segmentB.kind) {
        return -1;
      }
      ++iB;
    }
    const skippedStatesA = this.skippedStates;
    const skippedStatesB = b.skippedStates;
    const skippedStatesALen = skippedStatesA.length;
    const skippedStatesBLen = skippedStatesB.length;
    if (skippedStatesALen < skippedStatesBLen) {
      return 1;
    }
    if (skippedStatesALen > skippedStatesBLen) {
      return -1;
    }
    for (let i = 0; i < skippedStatesALen; ++i) {
      const skippedStateA = skippedStatesA[i];
      const skippedStateB = skippedStatesB[i];
      if (skippedStateA.length < skippedStateB.length) {
        return 1;
      }
      if (skippedStateA.length > skippedStateB.length) {
        return -1;
      }
    }
    return 0;
  }
}
function hasEndpoint(candidate) {
  return candidate.head.endpoint !== null;
}
function compareChains(a, b) {
  return a.compareTo(b);
}
class RecognizeResult {
  get isEmpty() {
    return this.candidates.length === 0;
  }
  constructor(rootState) {
    this.candidates = [];
    this.candidates = [new Candidate([""], [rootState], [], this)];
  }
  getSolution() {
    const candidates = this.candidates.filter((x) => hasEndpoint(x) && x._finalize());
    if (candidates.length === 0) {
      return null;
    }
    candidates.sort(compareChains);
    return candidates[0];
  }
  add(candidate) {
    this.candidates.push(candidate);
  }
  remove(candidate) {
    this.candidates.splice(this.candidates.indexOf(candidate), 1);
  }
  advance(ch) {
    const candidates = this.candidates.slice();
    for (const candidate of candidates) {
      candidate.advance(ch);
    }
  }
}
const RESIDUE = "$$residue";
const routeParameterPattern = /^:(?<name>[^?\s{}]+)(?:\{\{(?<constraint>.+)\}\})?(?<optional>\?)?$/g;
class RouteRecognizer {
  constructor() {
    this.rootState = new State(null, null, "");
    this.cache = /* @__PURE__ */ new Map();
    this.endpointLookup = /* @__PURE__ */ new Map();
  }
  add(routeOrRoutes, addResidue = false) {
    let params;
    let endpoint;
    if (routeOrRoutes instanceof Array) {
      for (const route2 of routeOrRoutes) {
        endpoint = this.$add(route2, false);
        params = endpoint.params;
        if (!addResidue || (params[params.length - 1]?.isStar ?? false))
          continue;
        endpoint.residualEndpoint = this.$add({ ...route2, path: `${route2.path}/*${RESIDUE}` }, true);
      }
    } else {
      endpoint = this.$add(routeOrRoutes, false);
      params = endpoint.params;
      if (addResidue && !(params[params.length - 1]?.isStar ?? false)) {
        endpoint.residualEndpoint = this.$add({ ...routeOrRoutes, path: `${routeOrRoutes.path}/*${RESIDUE}` }, true);
      }
    }
    this.cache.clear();
  }
  $add(route2, addResidue) {
    const path = route2.path;
    const lookup2 = this.endpointLookup;
    if (lookup2.has(path))
      throw createError(`Cannot add duplicate path '${path}'.`);
    const $route = new ConfigurableRoute(path, route2.caseSensitive === true, route2.handler);
    const parts = path === "" ? [""] : path.split("/").filter(isNotEmpty);
    const params = [];
    let state = this.rootState;
    for (const part of parts) {
      state = state.append(null, "/");
      switch (part.charAt(0)) {
        case ":": {
          routeParameterPattern.lastIndex = 0;
          const match = routeParameterPattern.exec(part);
          const { name: name2, optional: optional2 } = match?.groups ?? {};
          const isOptional = optional2 === "?";
          if (name2 === RESIDUE)
            throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);
          const constraint = match?.groups?.constraint;
          const pattern = constraint != null ? new RegExp(constraint) : null;
          params.push(new Parameter(name2, isOptional, false, pattern));
          state = new DynamicSegment2(name2, isOptional, pattern).appendTo(state);
          break;
        }
        case "*": {
          const name2 = part.slice(1);
          let kind;
          if (name2 === RESIDUE) {
            if (!addResidue)
              throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);
            kind = 1;
          } else {
            kind = 2;
          }
          params.push(new Parameter(name2, true, true, null));
          state = new StarSegment(name2, kind).appendTo(state);
          break;
        }
        default: {
          state = new StaticSegment2(part, $route.caseSensitive).appendTo(state);
          break;
        }
      }
    }
    const endpoint = new Endpoint($route, params);
    state.setEndpoint(endpoint);
    lookup2.set(path, endpoint);
    return endpoint;
  }
  recognize(path) {
    let result = this.cache.get(path);
    if (result === void 0) {
      this.cache.set(path, result = this.$recognize(path));
    }
    return result;
  }
  $recognize(path) {
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    if (path.length > 1 && path.endsWith("/")) {
      path = path.slice(0, -1);
    }
    const result = new RecognizeResult(this.rootState);
    for (let i = 0, ii = path.length; i < ii; ++i) {
      const ch = path.charAt(i);
      result.advance(ch);
      if (result.isEmpty) {
        return null;
      }
    }
    const candidate = result.getSolution();
    if (candidate === null) {
      return null;
    }
    const { endpoint } = candidate;
    const params = candidate._getParams();
    return new RecognizedRoute(endpoint, params);
  }
  getEndpoint(path) {
    return this.endpointLookup.get(path) ?? null;
  }
}
class State {
  constructor(prevState, segment, value) {
    this.prevState = prevState;
    this.segment = segment;
    this.value = value;
    this.nextStates = null;
    this.endpoint = null;
    this.isConstrained = false;
    switch (segment?.kind) {
      case 3:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = segment.optional;
        this.isConstrained = segment.isConstrained;
        break;
      case 2:
      case 1:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = false;
        break;
      case 4:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = false;
        this.isOptional = false;
        break;
      case void 0:
        this.length = prevState === null ? 0 : prevState.length;
        this.isSeparator = true;
        this.isDynamic = false;
        this.isOptional = false;
        break;
    }
  }
  append(segment, value) {
    let state;
    let nextStates = this.nextStates;
    if (nextStates === null) {
      state = void 0;
      nextStates = this.nextStates = [];
    } else if (segment === null) {
      state = nextStates.find((s) => s.value === value);
    } else {
      state = nextStates.find((s) => s.segment?.equals(segment));
    }
    if (state === void 0) {
      nextStates.push(state = new State(this, segment, value));
    }
    return state;
  }
  setEndpoint(endpoint) {
    if (this.endpoint !== null) {
      throw createError(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);
    }
    this.endpoint = endpoint;
    if (this.isOptional) {
      this.prevState.setEndpoint(endpoint);
      if (this.prevState.isSeparator && this.prevState.prevState !== null) {
        this.prevState.prevState.setEndpoint(endpoint);
      }
    }
  }
  isMatch(ch) {
    const segment = this.segment;
    switch (segment?.kind) {
      case 3:
        return !this.value.includes(ch);
      case 2:
      case 1:
        return true;
      case 4:
      case void 0:
        return this.value.includes(ch);
    }
  }
  satisfiesConstraint(value) {
    return this.isConstrained ? this.segment.satisfiesPattern(value) : true;
  }
}
function isNotEmpty(segment) {
  return segment.length > 0;
}
class StaticSegment2 {
  get kind() {
    return 4;
  }
  constructor(value, caseSensitive) {
    this.value = value;
    this.caseSensitive = caseSensitive;
  }
  appendTo(state) {
    const { value, value: { length } } = this;
    if (this.caseSensitive) {
      for (let i = 0; i < length; ++i) {
        state = state.append(
          /* segment */
          this,
          /* value   */
          value.charAt(i)
        );
      }
    } else {
      for (let i = 0; i < length; ++i) {
        const ch = value.charAt(i);
        state = state.append(
          /* segment */
          this,
          /* value   */
          ch.toUpperCase() + ch.toLowerCase()
        );
      }
    }
    return state;
  }
  equals(b) {
    return b.kind === 4 && b.caseSensitive === this.caseSensitive && b.value === this.value;
  }
}
class DynamicSegment2 {
  get kind() {
    return 3;
  }
  constructor(name2, optional2, pattern) {
    this.name = name2;
    this.optional = optional2;
    this.pattern = pattern;
    if (pattern === void 0)
      throw new Error(`Pattern is undefined`);
    this.isConstrained = pattern !== null;
  }
  appendTo(state) {
    state = state.append(
      /* segment */
      this,
      /* value   */
      "/"
    );
    return state;
  }
  equals(b) {
    return b.kind === 3 && b.optional === this.optional && b.name === this.name;
  }
  satisfiesPattern(value) {
    if (this.pattern === null)
      return true;
    this.pattern.lastIndex = 0;
    return this.pattern.test(value);
  }
}
class StarSegment {
  constructor(name2, kind) {
    this.name = name2;
    this.kind = kind;
  }
  appendTo(state) {
    state = state.append(
      /* segment */
      this,
      /* value   */
      ""
    );
    return state;
  }
  equals(b) {
    return (b.kind === 2 || b.kind === 1) && b.name === this.name;
  }
}
const createError = (msg) => new Error(msg);
const eventMessageMap = {
  // #region viewport
  [
    3e3
    /* Events.vpHydrated */
  ]: "hydrated",
  [
    3001
    /* Events.vpAttaching */
  ]: "attaching",
  [
    3002
    /* Events.vpDetaching */
  ]: "detaching",
  [
    3003
    /* Events.vpDispose */
  ]: "dispose",
  // #endregion
  // #region component agent
  [
    3050
    /* Events.caCreated */
  ]: "created",
  [
    3051
    /* Events.caActivateSelf */
  ]: "activating - self",
  [
    3052
    /* Events.caActivateInitiator */
  ]: "activating - via initiator",
  [
    3053
    /* Events.caDeactivateSelf */
  ]: "deactivating - self",
  [
    3054
    /* Events.caDeactivateInitiator */
  ]: "deactivating - via initiator",
  [
    3055
    /* Events.caDispose */
  ]: "disposing",
  [
    3056
    /* Events.caCanUnload */
  ]: "canUnload(next:%s) - invoking %s hooks",
  [
    3057
    /* Events.caCanLoad */
  ]: "canLoad(next:%s) - invoking %s hooks",
  [
    3058
    /* Events.caUnloading */
  ]: "unloading(next:%s) - invoking %s hooks",
  [
    3059
    /* Events.caLoading */
  ]: "loading(next:%s) - invoking %s hooks",
  // #endregion
  // #region location manager
  [
    3100
    /* Events.lmBaseHref */
  ]: "baseHref set to path: %s",
  [
    3101
    /* Events.lmStartListening */
  ]: "starting listening to %s",
  [
    3102
    /* Events.lmStopListening */
  ]: "stopping listening to %s",
  [
    3103
    /* Events.lmPushState */
  ]: "pushing to history state: %s (title: '%s', url: '%s')",
  [
    3104
    /* Events.lmReplaceState */
  ]: "replacing history state: %s (title: '%s', url: '%s')",
  [
    3105
    /* Events.lmPushStateNonSerializable */
  ]: "pushing to history state: NOT_SERIALIZABLE (title: '%s', url: '%s')",
  [
    3106
    /* Events.lmReplaceStateNonSerializable */
  ]: "replacing history state: NOT_SERIALIZABLE (title: '%s', url: '%s')",
  // #endregion
  // #region route context
  [
    3150
    /* Events.rcCreated */
  ]: "created",
  [
    3151
    /* Events.rcNodeChanged */
  ]: "Node changed from %s to %s",
  [
    3152
    /* Events.rcResolveNullishContext */
  ]: "The given context is nullish (%s); resolving to root RouteContext",
  [
    3153
    /* Events.rcResolveInstance */
  ]: "The given context (%s) is an instance of RouteContext; resolving to it",
  [
    3154
    /* Events.rcResolveNode */
  ]: "The given context is a node (nodeName:%s); resolving RouteContext from controller's RenderContext",
  [
    3155
    /* Events.rcResolveNodeFailed */
  ]: "Failed to resolve RouteContext from node %s; error: %s",
  [
    3156
    /* Events.rcResolveCe */
  ]: "The given context is a custom element viewmodel (name:%s); resolving RouteContext from controller's RenderContext",
  [
    3157
    /* Events.rcResolveCtrl */
  ]: "The given context is a custom element controller (name:%s); resolving RouteContext from controller's RenderContext",
  [
    3158
    /* Events.rcResolveVpa */
  ]: "Resolving viewport agent for the request: %s",
  [
    3159
    /* Events.rcCreateCa */
  ]: "Creating component agent for the node: %s",
  [
    3160
    /* Events.rcRegisterVp */
  ]: "Registering viewport: %s",
  [
    3161
    /* Events.rcRegisterVpSkip */
  ]: "Skipping registering viewport: %s; it is already registered",
  [
    3162
    /* Events.rcUnregisterVp */
  ]: "Unregistering viewport: %s",
  [
    3163
    /* Events.rcUnregisterVpSkip */
  ]: "Skipping unregistering viewport: %s; it is not registered",
  [
    3164
    /* Events.rcRecognizePath */
  ]: "Recognizing path: %s",
  [
    3165
    /* Events.rcAddRoute */
  ]: "Adding route: %s",
  [
    3166
    /* Events.rcEagerPathGenerationFailed */
  ]: "Unable to eagerly generate path for %s; reasons: %s",
  [
    3167
    /* Events.rcNoAppRoot */
  ]: "The provided container has no registered IAppRoot. RouteContext.setRoot can only be used after Aurelia.app was called, on a container that is within that app's component tree.",
  [
    3168
    /* Events.rcHasRootContext */
  ]: 'A root RouteContext is already registered. A possible cause is the RouterConfiguration being registered more than once in the same container tree. If you have a multi-rooted app, make sure you register RouterConfiguration only in the "forked" containers and not in the common root.',
  [
    3169
    /* Events.rcNoRootCtrl */
  ]: "The provided IAppRoot does not (yet) have a controller. A possible cause is calling this API manually before Aurelia.start() is called",
  [
    3170
    /* Events.rcResolveInvalidCtxType */
  ]: "Invalid context type: %s",
  [
    3171
    /* Events.rcNoNode */
  ]: "Invariant violation: RouteNode should be set immediately after the RouteContext is created. Context: %s",
  [
    3172
    /* Events.rcNoVpa */
  ]: "RouteContext has no ViewportAgent: %s",
  [
    3173
    /* Events.rcNoPathLazyImport */
  ]: "Invalid route config. When the component property is a lazy import, the path must be specified.",
  [
    3174
    /* Events.rcNoAvailableVpa */
  ]: "Failed to resolve %s at:\n%s",
  [
    3175
    /* Events.rcInvalidLazyImport */
  ]: "%s does not appear to be a component or CustomElement recognizable by Aurelia; make sure to use the @customElement decorator for your class if not using conventions.",
  // #endregion
  // #region router events
  [
    3200
    /* Events.rePublishingEvent */
  ]: "Publishing event: %s",
  [
    3201
    /* Events.reInvokingSubscriber */
  ]: "Invoking subscriber #%s (event: %s)",
  // #endregion
  // #region router
  [
    3250
    /* Events.rtrLoading */
  ]: "Loading instruction: %s",
  [
    3251
    /* Events.rtrIsActive */
  ]: "Checking if the route %s is active in context %s",
  [
    3252
    /* Events.rtrResolvingRcExisting */
  ]: "Resolving existing RouteContext for %s",
  [
    3253
    /* Events.rtrResolvingRcNew */
  ]: "Creating new RouteContext for %s",
  [
    3254
    /* Events.rtrIgnoringIdenticalNav */
  ]: "Ignoring navigation triggered by '%s' because it is the same URL as the previous navigation which was triggered by 'api'.",
  [
    3255
    /* Events.rtrReusingPromise */
  ]: "Reusing promise/resolve/reject from the previously failed transition %s",
  [
    3256
    /* Events.rtrSchedulingTr */
  ]: "Scheduling transition: %s",
  [
    3257
    /* Events.rtrTrSucceeded */
  ]: "Transition succeeded: %s",
  [
    3258
    /* Events.rtrRunBegin */
  ]: "Running transition: %s",
  [
    3259
    /* Events.rtrRunCancelled */
  ]: "Aborting transition %s because a new transition was queued in response to the NavigationStartEvent",
  [
    3260
    /* Events.rtrRunVitCompile */
  ]: "Compiling viewport instructions tree %s",
  [
    3261
    /* Events.rtrRunCanUnload */
  ]: "invoking canUnload on %s nodes",
  [
    3262
    /* Events.rtrRunCanLoad */
  ]: "invoking canLoad on %s nodes",
  [
    3263
    /* Events.rtrRunUnloading */
  ]: "invoking unloading on %s nodes",
  [
    3264
    /* Events.rtrRunLoading */
  ]: "invoking loading on %s nodes",
  [
    3265
    /* Events.rtrRunSwapping */
  ]: "invoking swapping on %s nodes",
  [
    3266
    /* Events.rtrRunFinalizing */
  ]: "finalizing transition",
  [
    3267
    /* Events.rtrCancelNavigationStart */
  ]: "navigation %s",
  [
    3268
    /* Events.rtrCancelNavigationCompleted */
  ]: "navigation %s; finished.",
  [
    3269
    /* Events.rtrNextTr */
  ]: "scheduling next transition: %s",
  [
    3270
    /* Events.rtrTrFailed */
  ]: "Transition %s failed with error: %s",
  [
    3271
    /* Events.rtrNoCtx */
  ]: "Root RouteContext is not set. Did you forget to register RouteConfiguration, or try to navigate before calling Aurelia.start()?",
  // #endregion
  // #region viewport agent
  [
    3300
    /* Events.vpaCreated */
  ]: "created",
  [
    3301
    /* Events.vpaActivateFromVpNone */
  ]: "Nothing to activate at %s",
  [
    3302
    /* Events.vpaActivateFromVpExisting */
  ]: "Activating existing component agent at %s",
  [
    3303
    /* Events.vpaActivateFromVpNext */
  ]: "Activating next component agent at %s",
  [
    3304
    /* Events.vpaDeactivateFromVpNone */
  ]: "Nothing to deactivate at %s",
  [
    3305
    /* Events.vpaDeactivateFromVpExisting */
  ]: "Deactivating existing component agent at %s",
  [
    3306
    /* Events.vpaDeactivationFromVpRunning */
  ]: "Already deactivating at %s",
  [
    3307
    /* Events.vpaDeactivateFromVpCurrent */
  ]: "Deactivating current component agent at %s",
  [
    3308
    /* Events.vpaHandlesVpMismatch */
  ]: "Cannot handle the request %s due to viewport name mismatch %s",
  [
    3309
    /* Events.vpaHandlesUsedByMismatch */
  ]: "Cannot handle the request %s as componentName not included in usedBy %s",
  [
    3310
    /* Events.vpaHandles */
  ]: "Viewport %s can handle the request %s",
  [
    3311
    /* Events.vpaIsAvailableInactive */
  ]: "Viewport is not available as it is inactive",
  [
    3312
    /* Events.vpaIsAvailableScheduled */
  ]: "Viewport is not available as an update is scheduled for %s",
  [
    3313
    /* Events.vpaCanUnloadChildren */
  ]: "Invoking on children at %s",
  [
    3314
    /* Events.vpaCanUnloadExisting */
  ]: "Invoking on existing component at %s",
  [
    3315
    /* Events.vpaCanUnloadSelf */
  ]: "Finished invoking on children, now invoking on own component at %s",
  [
    3316
    /* Events.vpaCanUnloadFinished */
  ]: "Finished at %s",
  [
    3317
    /* Events.vpaCanUnloadNone */
  ]: "Nothing to unload at %s",
  [
    3318
    /* Events.vpaCanLoadNext */
  ]: "Invoking on next component at %s",
  [
    3319
    /* Events.vpaCanLoadNone */
  ]: "Nothing to load at %s",
  [
    3320
    /* Events.vpaCanLoadResidue */
  ]: "Compiling residue for %s; plan is set to %s",
  [
    3321
    /* Events.vpaCanLoadResidueDelay */
  ]: "Delaying residue compilation for %s until activate",
  [
    3322
    /* Events.vpaCanLoadChildren */
  ]: "Finished own component; invoking on children at %s",
  [
    3323
    /* Events.vpaCanLoadFinished */
  ]: "Finished at %s",
  [
    3324
    /* Events.vpaUnloadingChildren */
  ]: "Invoking on children at %s",
  [
    3325
    /* Events.vpaUnloadingExisting */
  ]: "Invoking on existing component at %s",
  [
    3326
    /* Events.vpaUnloadingSelf */
  ]: "Finished invoking on children, now invoking on own component at %s",
  [
    3327
    /* Events.vpaUnloadingFinished */
  ]: "Finished at %s",
  [
    3328
    /* Events.vpaUnloadingNone */
  ]: "Nothing to unload at %s",
  [
    3329
    /* Events.vpaLoadingNext */
  ]: "Invoking on next component at %s",
  [
    3330
    /* Events.vpaLoadingNone */
  ]: "Nothing to load at %s",
  [
    3331
    /* Events.vpaLoadingChildren */
  ]: "Finished own component; invoking on children at %s",
  [
    3332
    /* Events.vpaLoadingFinished */
  ]: "Finished at %s",
  [
    3333
    /* Events.vpaDeactivateCurrent */
  ]: "Invoking on the current component at %s",
  [
    3334
    /* Events.vpaDeactivateNone */
  ]: "Nothing to deactivate at %s",
  [
    3335
    /* Events.vpaDeactivationRunning */
  ]: "Already deactivating at %s",
  [
    3336
    /* Events.vpaActivateNextScheduled */
  ]: "Invoking canLoad(), loading() and activate() on the next component at %s",
  [
    3337
    /* Events.vpaActivateNext */
  ]: "Invoking on the next component at %s",
  [
    3338
    /* Events.vpaActivateNone */
  ]: "Nothing to activate at %s",
  [
    3339
    /* Events.vpaSwapEmptyCurr */
  ]: "Running activate on next instead, because there is nothing to deactivate at %s",
  [
    3340
    /* Events.vpaSwapEmptyNext */
  ]: "Running deactivate on current instead, because there is nothing to activate at %s",
  [
    3341
    /* Events.vpaSwapSkipToChildren */
  ]: "Skipping this level and swapping children instead at %s",
  [
    3342
    /* Events.vpaSwap */
  ]: "Swapping current and next at %s",
  [
    3343
    /* Events.vpaProcessDynamicChildren */
  ]: "Processing dynamic children at %s",
  [
    3344
    /* Events.vpaScheduleUpdate */
  ]: "Scheduling update for %s; plan is set to %s",
  [
    3345
    /* Events.vpaCancelUpdate */
  ]: "Cancelling update for %s",
  [
    3346
    /* Events.vpaEndTransitionEmptyCurr */
  ]: "setting currState to State.currIsEmpty at %s",
  [
    3347
    /* Events.vpaEndTransitionActiveCurrLifecycle */
  ]: "setting currState to State.currIsActive at %s",
  [
    3348
    /* Events.vpaEndTransitionActiveCurrReplace */
  ]: "setting currState to State.currIsActive and reassigning curCA at %s",
  [
    3349
    /* Events.vpaDispose */
  ]: "disposing at %s",
  [
    3350
    /* Events.vpaUnexpectedActivation */
  ]: "Unexpected viewport activation outside of a transition context at %s",
  [
    3351
    /* Events.vpaUnexpectedDeactivation */
  ]: "Unexpected viewport deactivation outside of a transition context at %s",
  [
    3352
    /* Events.vpaUnexpectedState */
  ]: "Unexpected state at %s of %s",
  [
    3353
    /* Events.vpaUnexpectedGuardsResult */
  ]: "Unexpected guardsResult %s at %s",
  [
    3354
    /* Events.vpaCanLoadGuardsResult */
  ]: "canLoad returned redirect result %s by the component agent %s",
  // #endregion
  // #region instruction
  [
    3400
    /* Events.instrInvalid */
  ]: "Invalid component %s: must be either a class, a custom element ViewModel, or a (partial) custom element definition",
  [
    3401
    /* Events.instrNoFallback */
  ]: "Neither the route '%s' matched any configured route at '%s' nor a fallback is configured for the viewport '%s' - did you forget to add '%s' to the routes list of the route decorator of '%s'?",
  [
    3402
    /* Events.instrUnknownRedirect */
  ]: "'%s' did not match any configured route or registered component name at '%s' - did you forget to add '%s' to the routes list of the route decorator of '%s'?",
  [
    3403
    /* Events.instrInvalidUrlComponentOperation */
  ]: 'Invalid instruction type %s for "toUrlComponent" operation. If you are seeing this error, then it is probably because of an internal bug. Please report it.',
  [
    3404
    /* Events.instrIncompatiblePathGenerationInstr */
  ]: "The given instruction is not compatible for eagerly generating path: %s",
  // #endregion
  // #region navigation model
  [
    3450
    /* Events.nmNoEndpoint */
  ]: "No endpoint found for path '%s'",
  // #endregion
  // #region expression
  [
    3500
    /* Events.exprUnexpectedSegment */
  ]: "Expected %s at index %s of '%s', but got: '%s' (rest='%s')",
  [
    3501
    /* Events.exprNotDone */
  ]: "Unexpected '%s' at index %s of '%s'",
  [
    3502
    /* Events.exprUnexpectedKind */
  ]: "Unexpected expression kind %s",
  // #endregion
  // #region route
  [
    3550
    /* Events.rtConfigFromHookApplied */
  ]: "Invalid operation, the configuration from the get hook is already applied.",
  [
    3551
    /* Events.rtNoCtxStrComponent */
  ]: "When retrieving the RouteConfig for a component name, a RouteContext (that can resolve it) must be provided",
  [
    3552
    /* Events.rtNoComponent */
  ]: "Could not find a CustomElement named '%s' in the current container scope of %s. This means the component is neither registered at Aurelia startup nor via the 'dependencies' decorator or static property.",
  [
    3553
    /* Events.rtNoCtxLazyImport */
  ]: "RouteContext must be provided when resolving an imported module",
  [
    3554
    /* Events.rtInvalidConfigProperty */
  ]: 'Invalid route config property: "%s". Expected %s, but got %s.',
  [
    3555
    /* Events.rtInvalidConfig */
  ]: "Invalid route config: expected an object or string, but got: %s",
  [
    3556
    /* Events.rtUnknownConfigProperty */
  ]: 'Unknown route config property: "%s.%s". Please specify known properties only.',
  [
    3557
    /* Events.rtUnknownRedirectConfigProperty */
  ]: `Unknown redirect route config property: "%s.%s". Only 'path' and 'redirectTo' should be specified for redirects.`,
  [
    3558
    /* Events.rtInvalidOperationNavigationStrategyComponent */
  ]: "Invalid operation, the component is not yet resolved for the navigation strategy (id: %s)."
  // #endregion
};
function trace(logger, event, ...optionalParameters) {
  const message = eventMessageMap[event] ?? "Unknown event";
  logger.trace(`AUR${event}: ${message}`, ...optionalParameters);
}
function debug(logger, event, ...optionalParameters) {
  const message = eventMessageMap[event] ?? "Unknown event";
  logger.debug(`AUR${event}: ${message}`, ...optionalParameters);
}
function warn(logger, event, ...optionalParameters) {
  {
    const message = eventMessageMap[event];
    logger.warn(`AUR${event}: ${message}`, ...optionalParameters);
  }
}
function error(logger, event, ...optionalParameters) {
  {
    const message = eventMessageMap[event];
    logger.error(`AUR${event}: ${message}`, ...optionalParameters);
  }
}
function getMessage(event, ...optionalParameters) {
  {
    let message = eventMessageMap[event];
    let offset2 = 0;
    while (message.includes("%s") || offset2 < optionalParameters.length) {
      message = message.replace("%s", String(optionalParameters[offset2++]));
    }
    return `AUR${event}: ${message}`;
  }
}
function logAndThrow(err, logger) {
  logger.error(err);
  throw err;
}
class Batch {
  constructor(_stack, _cb, head) {
    this._stack = _stack;
    this._cb = _cb;
    this._done = false;
    this._next = null;
    this._head = head ?? this;
  }
  static _start(cb) {
    return new Batch(0, cb, null);
  }
  _push() {
    let cur = this;
    do {
      ++cur._stack;
      cur = cur._next;
    } while (cur !== null);
  }
  _pop() {
    let cur = this;
    do {
      if (--cur._stack === 0) {
        cur._invoke();
      }
      cur = cur._next;
    } while (cur !== null);
  }
  _invoke() {
    const cb = this._cb;
    if (cb !== null) {
      this._cb = null;
      cb(this);
      this._done = true;
    }
  }
  _continueWith(cb) {
    if (this._next === null) {
      return this._next = new Batch(this._stack, cb, this._head);
    } else {
      return this._next._continueWith(cb);
    }
  }
  _start() {
    this._head._push();
    this._head._pop();
    return this;
  }
}
function mergeDistinct(prev, next) {
  prev = prev.slice();
  next = next.slice();
  const merged = [];
  while (prev.length > 0) {
    const p = prev.shift();
    const prevVpa = p.context.vpa;
    if (merged.every((m3) => m3.context.vpa !== prevVpa)) {
      const i = next.findIndex((n) => n.context.vpa === prevVpa);
      if (i >= 0) {
        merged.push(...next.splice(0, i + 1));
      } else {
        merged.push(p);
      }
    }
  }
  merged.push(...next);
  return merged;
}
function tryStringify(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return Object.prototype.toString.call(value);
  }
}
function ensureArrayOfStrings(value) {
  return typeof value === "string" ? [value] : value;
}
function ensureString(value) {
  return typeof value === "string" ? value : value[0];
}
function mergeURLSearchParams(source, other, clone) {
  const query = clone ? new URLSearchParams(source) : source;
  if (other == null)
    return query;
  for (const [key, value] of Object.entries(other)) {
    if (value == null)
      continue;
    if (isArray(value)) {
      for (const v of value) {
        query.append(key, v);
      }
      continue;
    }
    query.append(key, value);
  }
  return query;
}
function mergeQueryParams(source, other) {
  if (other == null)
    return source;
  for (const [key, value] of Object.entries(other)) {
    if (value == null)
      continue;
    if (source[key] == null) {
      source[key] = value;
    } else {
      const values = source[key];
      source[key] = [...isArray(values) ? values : [values], ...isArray(value) ? value : [value]];
    }
  }
  return source;
}
const bmToView = BindingMode.toView;
const bmFromView = BindingMode.fromView;
function isNotNullishOrTypeOrViewModel(value) {
  return typeof value === "object" && value !== null && !isCustomElementViewModel(value);
}
function isPartialCustomElementDefinition(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "name") === true;
}
function isPartialChildRouteConfig(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "component") === true;
}
function isPartialRedirectRouteConfig(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "redirectTo") === true;
}
function isPartialViewportInstruction(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "component") === true;
}
function expectType(expected, prop, value) {
  throw new Error(getMessage(3554, prop, expected, tryStringify(value)));
}
function validateRouteConfig(config, parentPath) {
  if (config == null)
    throw new Error(getMessage(3555, config));
  const keys = Object.keys(config);
  for (const key of keys) {
    const value = config[key];
    const path = [parentPath, key].join(".");
    switch (key) {
      case "id":
      case "viewport":
      case "redirectTo":
        if (typeof value !== "string") {
          expectType("string", path, value);
        }
        break;
      case "caseSensitive":
      case "nav":
        if (typeof value !== "boolean") {
          expectType("boolean", path, value);
        }
        break;
      case "data":
        if (typeof value !== "object" || value === null) {
          expectType("object", path, value);
        }
        break;
      case "title":
        switch (typeof value) {
          case "string":
          case "function":
            break;
          default:
            expectType("string or function", path, value);
        }
        break;
      case "path":
        if (value instanceof Array) {
          for (let i = 0; i < value.length; ++i) {
            if (typeof value[i] !== "string") {
              expectType("string", `${path}[${i}]`, value[i]);
            }
          }
        } else if (typeof value !== "string") {
          expectType("string or Array of strings", path, value);
        }
        break;
      case "component":
        validateComponent(value, path, "component");
        break;
      case "routes": {
        if (!(value instanceof Array)) {
          expectType("Array", path, value);
        }
        for (const route2 of value) {
          const childPath = `${path}[${value.indexOf(route2)}]`;
          validateComponent(route2, childPath, "component");
        }
        break;
      }
      case "transitionPlan":
        switch (typeof value) {
          case "string":
            switch (value) {
              case "none":
              case "replace":
              case "invoke-lifecycles":
                break;
              default:
                expectType("string('none'|'replace'|'invoke-lifecycles') or function", path, value);
            }
            break;
          case "function":
            break;
          default:
            expectType("string('none'|'replace'|'invoke-lifecycles') or function", path, value);
        }
        break;
      case "fallback":
        validateComponent(value, path, "fallback");
        break;
      default:
        throw new Error(getMessage(3556, parentPath, key));
    }
  }
}
function validateRedirectRouteConfig(config, parentPath) {
  if (config == null)
    throw new Error(getMessage(3555, config));
  const keys = Object.keys(config);
  for (const key of keys) {
    const value = config[key];
    const path = [parentPath, key].join(".");
    switch (key) {
      case "path":
        if (value instanceof Array) {
          for (let i = 0; i < value.length; ++i) {
            if (typeof value[i] !== "string") {
              expectType("string", `${path}[${i}]`, value[i]);
            }
          }
        } else if (typeof value !== "string") {
          expectType("string or Array of strings", path, value);
        }
        break;
      case "redirectTo":
        if (typeof value !== "string") {
          expectType("string", path, value);
        }
        break;
      default:
        throw new Error(getMessage(3557, parentPath, key));
    }
  }
}
function validateComponent(component, parentPath, property) {
  switch (typeof component) {
    case "function":
      break;
    case "object":
      if (component instanceof Promise || component instanceof NavigationStrategy) {
        break;
      }
      if (isPartialRedirectRouteConfig(component)) {
        validateRedirectRouteConfig(component, parentPath);
        break;
      }
      if (isPartialChildRouteConfig(component)) {
        validateRouteConfig(component, parentPath);
        break;
      }
      if (!isCustomElementViewModel(component) && !isPartialCustomElementDefinition(component)) {
        expectType(`an object with at least a '${property}' property (see Routeable)`, parentPath, component);
      }
      break;
    case "string":
      break;
    default:
      expectType("function, object or string (see Routeable)", parentPath, component);
  }
}
function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a === null || b === null) {
    return false;
  }
  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {
    return false;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  for (let i = 0, ii = aKeys.length; i < ii; ++i) {
    const key = aKeys[i];
    if (key !== bKeys[i]) {
      return false;
    }
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
const AuNavId = "au-nav-id";
class Subscription {
  constructor(_events, _serial, _inner) {
    this._events = _events;
    this._serial = _serial;
    this._inner = _inner;
    this._disposed = false;
  }
  dispose() {
    if (!this._disposed) {
      this._disposed = true;
      this._inner.dispose();
      const subscriptions = this._events["_subscriptions"];
      subscriptions.splice(subscriptions.indexOf(this), 1);
    }
  }
}
const IRouterEvents = /* @__PURE__ */ DI.createInterface("IRouterEvents", (x) => x.singleton(RouterEvents));
class RouterEvents {
  constructor() {
    this._subscriptionSerial = 0;
    this._subscriptions = [];
    this._ea = resolve(IEventAggregator);
    this._logger = resolve(ILogger).scopeTo("RouterEvents");
  }
  publish(event) {
    trace(this._logger, 3200, event);
    this._ea.publish(event.name, event);
  }
  subscribe(event, callback) {
    const subscription = new Subscription(this, ++this._subscriptionSerial, this._ea.subscribe(event, (message) => {
      trace(this._logger, 3201, subscription._serial, event);
      callback(message);
    }));
    this._subscriptions.push(subscription);
    return subscription;
  }
}
class LocationChangeEvent {
  get name() {
    return "au:router:location-change";
  }
  constructor(id2, url, trigger, state) {
    this.id = id2;
    this.url = url;
    this.trigger = trigger;
    this.state = state;
  }
  toString() {
    return `LocationChangeEvent(id:${this.id},url:'${this.url}',trigger:'${this.trigger}')`;
  }
}
class NavigationStartEvent {
  get name() {
    return "au:router:navigation-start";
  }
  constructor(id2, instructions, trigger, managedState) {
    this.id = id2;
    this.instructions = instructions;
    this.trigger = trigger;
    this.managedState = managedState;
  }
  toString() {
    return `NavigationStartEvent(id:${this.id},instructions:'${this.instructions}',trigger:'${this.trigger}')`;
  }
}
class NavigationEndEvent {
  get name() {
    return "au:router:navigation-end";
  }
  constructor(id2, instructions, finalInstructions) {
    this.id = id2;
    this.instructions = instructions;
    this.finalInstructions = finalInstructions;
  }
  toString() {
    return `NavigationEndEvent(id:${this.id},instructions:'${this.instructions}',finalInstructions:'${this.finalInstructions}')`;
  }
}
class NavigationCancelEvent {
  get name() {
    return "au:router:navigation-cancel";
  }
  constructor(id2, instructions, reason) {
    this.id = id2;
    this.instructions = instructions;
    this.reason = reason;
  }
  toString() {
    return `NavigationCancelEvent(id:${this.id},instructions:'${this.instructions}',reason:${String(this.reason)})`;
  }
}
class NavigationErrorEvent {
  get name() {
    return "au:router:navigation-error";
  }
  constructor(id2, instructions, error2) {
    this.id = id2;
    this.instructions = instructions;
    this.error = error2;
  }
  toString() {
    return `NavigationErrorEvent(id:${this.id},instructions:'${this.instructions}',error:${String(this.error)})`;
  }
}
const IBaseHref = /* @__PURE__ */ DI.createInterface("IBaseHref");
const ILocationManager = /* @__PURE__ */ DI.createInterface("ILocationManager", (x) => x.singleton(BrowserLocationManager));
class BrowserLocationManager {
  constructor() {
    this._eventId = 0;
    this._logger = resolve(ILogger).root.scopeTo("LocationManager");
    this._events = resolve(IRouterEvents);
    this._history = resolve(IHistory);
    this._location = resolve(ILocation);
    this._window = resolve(IWindow);
    this._baseHref = resolve(IBaseHref);
    this._event = resolve(IRouterOptions).useUrlFragmentHash ? "hashchange" : "popstate";
    debug(this._logger, 3100, this._baseHref.href);
  }
  startListening() {
    trace(this._logger, 3101, this._event);
    this._window.addEventListener(this._event, this, false);
  }
  stopListening() {
    trace(this._logger, 3102, this._event);
    this._window.removeEventListener(this._event, this, false);
  }
  handleEvent(event) {
    this._events.publish(new LocationChangeEvent(++this._eventId, this.getPath(), this._event, "state" in event ? event.state : null));
  }
  pushState(state, title, url) {
    url = this.addBaseHref(url);
    {
      try {
        const stateString = JSON.stringify(state);
        trace(this._logger, 3103, stateString, title, url);
      } catch (_err) {
        warn(this._logger, 3105, title, url);
      }
    }
    this._history.pushState(state, title, url);
  }
  replaceState(state, title, url) {
    url = this.addBaseHref(url);
    {
      try {
        const stateString = JSON.stringify(state);
        trace(this._logger, 3104, stateString, title, url);
      } catch (err) {
        warn(this._logger, 3106, title, url);
      }
    }
    this._history.replaceState(state, title, url);
  }
  getPath() {
    const { pathname, search, hash: hash2 } = this._location;
    return this.removeBaseHref(`${pathname}${normalizeQuery(search)}${hash2}`);
  }
  addBaseHref(path) {
    let fullPath;
    let base = this._baseHref.href;
    if (base.endsWith("/")) {
      base = base.slice(0, -1);
    }
    if (base.length === 0) {
      fullPath = path;
    } else {
      if (path.startsWith("/")) {
        path = path.slice(1);
      }
      fullPath = `${base}/${path}`;
    }
    return fullPath;
  }
  removeBaseHref(path) {
    const basePath = this._baseHref.pathname;
    if (path.startsWith(basePath)) {
      path = path.slice(basePath.length);
    }
    return normalizePath(path);
  }
}
function normalizePath(path) {
  let start2;
  let end2;
  let index;
  if ((index = path.indexOf("?")) >= 0 || (index = path.indexOf("#")) >= 0) {
    start2 = path.slice(0, index);
    end2 = path.slice(index);
  } else {
    start2 = path;
    end2 = "";
  }
  if (start2.endsWith("/")) {
    start2 = start2.slice(0, -1);
  } else if (start2.endsWith("/index.html")) {
    start2 = start2.slice(
      0,
      -11
      /* '/index.html'.length */
    );
  }
  return `${start2}${end2}`;
}
function normalizeQuery(query) {
  return query.length > 0 && !query.startsWith("?") ? `?${query}` : query;
}
const noRoutes = emptyArray;
class RouteConfig {
  get path() {
    const path = this._path;
    if (path.length > 0)
      return path;
    const ceDfn = CustomElement.getDefinition(this._component);
    return this._path = [ceDfn.name, ...ceDfn.aliases];
  }
  get component() {
    return this._getComponent();
  }
  constructor(id2, _path, title, redirectTo, caseSensitive, transitionPlan, viewport2, data, routes, fallback, component, nav) {
    this.id = id2;
    this._path = _path;
    this.title = title;
    this.redirectTo = redirectTo;
    this.caseSensitive = caseSensitive;
    this.transitionPlan = transitionPlan;
    this.viewport = viewport2;
    this.data = data;
    this.routes = routes;
    this.fallback = fallback;
    this.nav = nav;
    this._configurationFromHookApplied = false;
    this._currentComponent = null;
    this._component = component;
    this._isNavigationStrategy = component instanceof NavigationStrategy;
  }
  /** @internal */
  static _create(configOrPath, Type) {
    if (typeof configOrPath === "string" || configOrPath instanceof Array) {
      const path = ensureArrayOfStrings(configOrPath);
      const redirectTo = Type?.redirectTo ?? null;
      const caseSensitive = Type?.caseSensitive ?? false;
      const id2 = ensureString(Type?.id ?? (path instanceof Array ? path[0] : path));
      const title = Type?.title ?? null;
      const reentryBehavior = Type?.transitionPlan ?? null;
      const viewport2 = Type?.viewport ?? defaultViewportName;
      const data = Type?.data ?? {};
      const children = Type?.routes ?? noRoutes;
      return new RouteConfig(id2, path, title, redirectTo, caseSensitive, reentryBehavior, viewport2, data, children, Type?.fallback ?? null, Type, Type?.nav ?? true);
    } else if (typeof configOrPath === "object") {
      const config = configOrPath;
      validateRouteConfig(config, "");
      const path = ensureArrayOfStrings(config.path ?? Type?.path ?? emptyArray);
      const title = config.title ?? Type?.title ?? null;
      const redirectTo = config.redirectTo ?? Type?.redirectTo ?? null;
      const caseSensitive = config.caseSensitive ?? Type?.caseSensitive ?? false;
      const id2 = config.id ?? Type?.id ?? (path instanceof Array ? path[0] : path);
      const reentryBehavior = config.transitionPlan ?? Type?.transitionPlan ?? null;
      const viewport2 = config.viewport ?? Type?.viewport ?? defaultViewportName;
      const data = {
        ...Type?.data,
        ...config.data
      };
      const children = [
        ...config.routes ?? noRoutes,
        ...Type?.routes ?? noRoutes
      ];
      return new RouteConfig(id2, path, title, redirectTo, caseSensitive, reentryBehavior, viewport2, data, children, config.fallback ?? Type?.fallback ?? null, config.component ?? Type ?? null, config.nav ?? true);
    } else {
      expectType("string, function/class or object", "", configOrPath);
    }
  }
  /**
   * Invoked when this component is used as a child under another parent.
   * Creates a new route config applying the child route config.
   * Note that the current rote config is not mutated.
   *
   * @internal
   */
  _applyChildRouteConfig(config, parentConfig) {
    validateRouteConfig(config, this.path[0] ?? "");
    const path = ensureArrayOfStrings(config.path ?? this.path);
    return new RouteConfig(
      ensureString(config.id ?? this.id ?? path),
      path,
      config.title ?? this.title,
      config.redirectTo ?? this.redirectTo,
      config.caseSensitive ?? this.caseSensitive,
      config.transitionPlan ?? this.transitionPlan ?? parentConfig?.transitionPlan ?? null,
      config.viewport ?? this.viewport,
      config.data ?? this.data,
      config.routes ?? this.routes,
      config.fallback ?? this.fallback ?? parentConfig?.fallback ?? null,
      this._component,
      // The RouteConfig is created using a definitive Type as component; do not overwrite it.
      config.nav ?? this.nav
    );
  }
  /** @internal */
  _getTransitionPlan(cur, next, overridingTransitionPlan) {
    if (hasSamePath(cur, next) && shallowEquals(cur.params, next.params))
      return "none";
    if (overridingTransitionPlan != null)
      return overridingTransitionPlan;
    const plan = this.transitionPlan ?? "replace";
    return typeof plan === "function" ? plan(cur, next) : plan;
    function cleanPath(path) {
      return path.replace(`/*${RESIDUE}`, "");
    }
    function hasSamePath(nodeA, nodeB) {
      const pathA = nodeA.finalPath;
      const pathB = nodeB.finalPath;
      return pathA.length === 0 || pathB.length === 0 || cleanPath(pathA) === cleanPath(pathB);
    }
  }
  /** @internal */
  _applyFromConfigurationHook(instance, parent, routeNode) {
    if (this._configurationFromHookApplied)
      throw new Error(getMessage(
        3550
        /* Events.rtConfigFromHookApplied */
      ));
    if (typeof instance.getRouteConfig !== "function")
      return;
    return onResolve(instance.getRouteConfig(parent, routeNode), (value) => {
      this._configurationFromHookApplied = true;
      if (value == null)
        return;
      let parentPath = parent?.path ?? "";
      if (typeof parentPath !== "string") {
        parentPath = parentPath[0];
      }
      validateRouteConfig(value, parentPath);
      this.id = value.id ?? this.id;
      this._path = ensureArrayOfStrings(value.path ?? this.path);
      this.title = value.title ?? this.title;
      this.redirectTo = value.redirectTo ?? this.redirectTo;
      this.caseSensitive = value.caseSensitive ?? this.caseSensitive;
      this.transitionPlan = value.transitionPlan ?? this.transitionPlan;
      this.viewport = value.viewport ?? this.viewport;
      this.data = value.data ?? this.data;
      this.routes = value.routes ?? this.routes;
      this.fallback = value.fallback ?? this.fallback;
      this.nav = value.nav ?? this.nav;
    });
  }
  /** @internal */
  _clone() {
    return new RouteConfig(this.id, this.path, this.title, this.redirectTo, this.caseSensitive, this.transitionPlan, this.viewport, this.data, this.routes, this.fallback, this._component, this.nav);
  }
  /** @internal */
  _getFallback(viewportInstruction, routeNode, context) {
    const fallback = this.fallback;
    return typeof fallback === "function" && !CustomElement.isType(fallback) ? fallback(viewportInstruction, routeNode, context) : fallback;
  }
  /** @internal */
  _getComponentName() {
    try {
      return this._getComponent().name;
    } catch {
      return "UNRESOLVED-NAVIGATION-STRATEGY";
    }
  }
  _getComponent(vi, ctx, node, route2) {
    if (vi == null) {
      if (this._currentComponent != null)
        return this._currentComponent;
      if (this._isNavigationStrategy)
        throw new Error(getMessage(3558, this.id));
      return this._currentComponent = this._component;
    }
    return this._currentComponent ??= this._isNavigationStrategy ? this._component.getComponent(vi, ctx, node, route2) : this._component;
  }
  /** @internal */
  _handleNavigationStart() {
    if (!this._isNavigationStrategy)
      return;
    this._currentComponent = null;
  }
  toString() {
    let value = `RConf(id: ${this.id}, isNavigationStrategy: ${this._isNavigationStrategy}`;
    value += `, path: [${this.path.join(",")}]`;
    if (this.redirectTo)
      value += `, redirectTo: ${this.redirectTo}`;
    if (this.caseSensitive)
      value += `, caseSensitive: ${this.caseSensitive}`;
    if (this.transitionPlan != null)
      value += `, transitionPlan: ${this.transitionPlan}`;
    value += `, viewport: ${this.viewport}`;
    if (this._currentComponent != null)
      value += `, component: ${this._currentComponent.name}`;
    return `${value})`;
  }
}
const Route = {
  name: /* @__PURE__ */ getResourceKeyFor("route-configuration"),
  /**
   * Returns `true` if the specified type has any static route configuration (either via static properties or a &#64;route decorator)
   */
  isConfigured(Type) {
    return Metadata.has(Route.name, Type);
  },
  /**
   * Apply the specified configuration to the specified type, overwriting any existing configuration.
   */
  configure(configOrPath, Type) {
    const config = RouteConfig._create(configOrPath, Type);
    Metadata.define(config, Type, Route.name);
    return Type;
  },
  /**
   * Get the `RouteConfig` associated with the specified type, creating a new one if it does not yet exist.
   */
  getConfig(Type) {
    if (!Route.isConfigured(Type)) {
      Route.configure({}, Type);
    }
    return Metadata.get(Route.name, Type);
  }
};
function route(configOrPath) {
  return function(target, context) {
    context.addInitializer(function() {
      Route.configure(configOrPath, this);
    });
    return target;
  };
}
function resolveRouteConfiguration(routeable, isChild, parent, routeNode, context) {
  if (isPartialRedirectRouteConfig(routeable))
    return RouteConfig._create(routeable, null);
  const [instruction, ceDef] = resolveCustomElementDefinition(routeable, context);
  if (instruction.type === 5)
    return RouteConfig._create({ ...routeable, nav: false }, null);
  return onResolve(ceDef, ($ceDef) => {
    const type = $ceDef.Type;
    const routeConfig = Route.getConfig(type);
    if (isPartialChildRouteConfig(routeable))
      return routeConfig._applyChildRouteConfig(routeable, parent);
    if (isChild)
      return routeConfig._clone();
    if (!routeConfig._configurationFromHookApplied && instruction.type === 4 && typeof routeable.getRouteConfig === "function") {
      return onResolve(routeConfig._applyFromConfigurationHook(routeable, parent, routeNode), () => routeConfig);
    }
    return routeConfig;
  });
}
function resolveCustomElementDefinition(routeable, context) {
  const instruction = createNavigationInstruction(routeable);
  let ceDef;
  switch (instruction.type) {
    case 5:
      return [instruction, null];
    case 0: {
      if (context == null)
        throw new Error(getMessage(
          3551
          /* Events.rtNoCtxStrComponent */
        ));
      const dependencies2 = context.component.dependencies;
      let component = dependencies2.find((d3) => isPartialCustomElementDefinition(d3) && d3.name === instruction.value) ?? CustomElement.find(context.container, instruction.value);
      if (component === null)
        throw new Error(getMessage(3552, instruction.value, context));
      if (!(component instanceof CustomElementDefinition)) {
        component = CustomElementDefinition.create(component);
        CustomElement.define(component);
      }
      ceDef = component;
      break;
    }
    case 2:
      ceDef = instruction.value;
      break;
    case 4:
      ceDef = CustomElement.getDefinition(instruction.value.constructor);
      break;
    case 3:
      if (context == null)
        throw new Error(getMessage(
          3553
          /* Events.rtNoCtxLazyImport */
        ));
      ceDef = context._resolveLazy(instruction.value);
      break;
  }
  return [instruction, ceDef];
}
function createNavigationInstruction(routeable) {
  return isPartialChildRouteConfig(routeable) ? createNavigationInstruction(routeable.component) : TypedNavigationInstruction.create(routeable);
}
const terminal = ["?", "#", "/", "+", "(", ")", "@", "!", "=", ",", "&", "'", "~", ";"];
class ParserState {
  get _done() {
    return this._rest.length === 0;
  }
  constructor(_input) {
    this._input = _input;
    this._buffers = [];
    this._bufferIndex = 0;
    this._index = 0;
    this._rest = _input;
  }
  _startsWith(...values) {
    const rest = this._rest;
    return values.some(function(value) {
      return rest.startsWith(value);
    });
  }
  _consumeOptional(str) {
    if (this._startsWith(str)) {
      this._rest = this._rest.slice(str.length);
      this._index += str.length;
      this._append(str);
      return true;
    }
    return false;
  }
  _consume(str) {
    if (!this._consumeOptional(str)) {
      this._expect(`'${str}'`);
    }
  }
  _expect(msg) {
    throw new Error(getMessage(3500, msg, this._index, this._input, this._rest, this._rest));
  }
  _ensureDone() {
    if (!this._done) {
      throw new Error(getMessage(3501, this._rest, this._index, this._input));
    }
  }
  _advance() {
    const char = this._rest[0];
    this._rest = this._rest.slice(1);
    ++this._index;
    this._append(char);
  }
  _record() {
    this._buffers[this._bufferIndex++] = "";
  }
  _playback() {
    const bufferIndex = --this._bufferIndex;
    const buffers = this._buffers;
    const buffer = buffers[bufferIndex];
    buffers[bufferIndex] = "";
    return buffer;
  }
  _discard() {
    this._buffers[--this._bufferIndex] = "";
  }
  _append(str) {
    const bufferIndex = this._bufferIndex;
    const buffers = this._buffers;
    for (let i = 0; i < bufferIndex; ++i) {
      buffers[i] += str;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
class RouteExpression {
  get kind() {
    return "Route";
  }
  constructor(isAbsolute, root, queryParams, fragment) {
    this.isAbsolute = isAbsolute;
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
  }
  static parse(value) {
    const key = value.toString();
    let result = cache.get(key);
    if (result === void 0) {
      cache.set(key, result = RouteExpression._$parse(value));
    }
    return result;
  }
  /** @internal */
  static _$parse(value) {
    const path = value.path;
    if (path === "") {
      return new RouteExpression(false, SegmentExpression.Empty, value.query, value.fragment);
    }
    const state = new ParserState(path);
    state._record();
    const isAbsolute = state._consumeOptional("/");
    const root = CompositeSegmentExpression._parse(state);
    state._ensureDone();
    state._discard();
    return new RouteExpression(isAbsolute, root, value.query, value.fragment);
  }
  toInstructionTree(options) {
    return new ViewportInstructionTree(options, this.isAbsolute, this.root._toInstructions(0, 0), mergeURLSearchParams(this.queryParams, options.queryParams, true), this.fragment ?? options.fragment);
  }
}
class CompositeSegmentExpression {
  get kind() {
    return "CompositeSegment";
  }
  constructor(siblings) {
    this.siblings = siblings;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const append = state._consumeOptional("+");
    const siblings = [];
    do {
      siblings.push(ScopedSegmentExpression._parse(state));
    } while (state._consumeOptional("+"));
    if (!append && siblings.length === 1) {
      state._discard();
      return siblings[0];
    }
    state._discard();
    return new CompositeSegmentExpression(siblings);
  }
  /** @internal */
  _toInstructions(open, close) {
    switch (this.siblings.length) {
      case 0:
        return [];
      case 1:
        return this.siblings[0]._toInstructions(open, close);
      case 2:
        return [
          ...this.siblings[0]._toInstructions(open, 0),
          ...this.siblings[1]._toInstructions(0, close)
        ];
      default:
        return [
          ...this.siblings[0]._toInstructions(open, 0),
          ...this.siblings.slice(1, -1).flatMap(function(x) {
            return x._toInstructions(0, 0);
          }),
          ...this.siblings[this.siblings.length - 1]._toInstructions(0, close)
        ];
    }
  }
}
class ScopedSegmentExpression {
  get kind() {
    return "ScopedSegment";
  }
  constructor(left2, right2) {
    this.left = left2;
    this.right = right2;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const left2 = SegmentGroupExpression._parse(state);
    if (state._consumeOptional("/")) {
      const right2 = ScopedSegmentExpression._parse(state);
      state._discard();
      return new ScopedSegmentExpression(left2, right2);
    }
    state._discard();
    return left2;
  }
  /** @internal */
  _toInstructions(open, close) {
    const leftInstructions = this.left._toInstructions(open, 0);
    const rightInstructions = this.right._toInstructions(0, close);
    let cur = leftInstructions[leftInstructions.length - 1];
    while (cur.children.length > 0) {
      cur = cur.children[cur.children.length - 1];
    }
    cur.children.push(...rightInstructions);
    return leftInstructions;
  }
}
class SegmentGroupExpression {
  get kind() {
    return "SegmentGroup";
  }
  constructor(expression) {
    this.expression = expression;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    if (state._consumeOptional("(")) {
      const expression = CompositeSegmentExpression._parse(state);
      state._consume(")");
      state._discard();
      return new SegmentGroupExpression(expression);
    }
    state._discard();
    return SegmentExpression._parse(state);
  }
  /** @internal */
  _toInstructions(open, close) {
    return this.expression._toInstructions(open + 1, close + 1);
  }
}
class SegmentExpression {
  get kind() {
    return "Segment";
  }
  static get Empty() {
    return new SegmentExpression(ComponentExpression.Empty, ViewportExpression.Empty, true);
  }
  constructor(component, viewport2, scoped) {
    this.component = component;
    this.viewport = viewport2;
    this.scoped = scoped;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const component = ComponentExpression._parse(state);
    const viewport2 = ViewportExpression._parse(state);
    const scoped = !state._consumeOptional("!");
    state._discard();
    return new SegmentExpression(component, viewport2, scoped);
  }
  /** @internal */
  _toInstructions(open, close) {
    return [
      ViewportInstruction.create({
        component: this.component.name,
        params: this.component.parameterList._toObject(),
        viewport: this.viewport.name,
        open,
        close
      })
    ];
  }
}
class ComponentExpression {
  get kind() {
    return "Component";
  }
  static get Empty() {
    return new ComponentExpression("", ParameterListExpression.Empty);
  }
  constructor(name2, parameterList) {
    this.name = name2;
    this.parameterList = parameterList;
    switch (name2.charAt(0)) {
      case ":":
        this.isParameter = true;
        this.isStar = false;
        this.isDynamic = true;
        this.parameterName = name2.slice(1);
        break;
      case "*":
        this.isParameter = false;
        this.isStar = true;
        this.isDynamic = true;
        this.parameterName = name2.slice(1);
        break;
      default:
        this.isParameter = false;
        this.isStar = false;
        this.isDynamic = false;
        this.parameterName = name2;
        break;
    }
  }
  /** @internal */
  static _parse(state) {
    state._record();
    state._record();
    if (!state._done) {
      if (state._startsWith("./")) {
        state._advance();
      } else if (state._startsWith("../")) {
        state._advance();
        state._advance();
      } else {
        while (!state._done && !state._startsWith(...terminal)) {
          state._advance();
        }
      }
    }
    const name2 = state._playback();
    if (name2.length === 0) {
      state._expect("component name");
    }
    const parameterList = ParameterListExpression._parse(state);
    state._discard();
    return new ComponentExpression(name2, parameterList);
  }
}
class ViewportExpression {
  get kind() {
    return "Viewport";
  }
  static get Empty() {
    return new ViewportExpression("");
  }
  constructor(name2) {
    this.name = name2;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    let name2 = null;
    if (state._consumeOptional("@")) {
      state._record();
      while (!state._done && !state._startsWith(...terminal)) {
        state._advance();
      }
      name2 = decodeURIComponent(state._playback());
      if (name2.length === 0) {
        state._expect("viewport name");
      }
    }
    state._discard();
    return new ViewportExpression(name2);
  }
}
class ParameterListExpression {
  get kind() {
    return "ParameterList";
  }
  static get Empty() {
    return new ParameterListExpression([]);
  }
  constructor(expressions) {
    this.expressions = expressions;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const expressions = [];
    if (state._consumeOptional("(")) {
      do {
        expressions.push(ParameterExpression._parse(state, expressions.length));
        if (!state._consumeOptional(",")) {
          break;
        }
      } while (!state._done && !state._startsWith(")"));
      state._consume(")");
    }
    state._discard();
    return new ParameterListExpression(expressions);
  }
  /** @internal */
  _toObject() {
    const params = {};
    for (const expr of this.expressions) {
      params[expr.key] = expr.value;
    }
    return params;
  }
}
class ParameterExpression {
  get kind() {
    return "Parameter";
  }
  static get Empty() {
    return new ParameterExpression("", "");
  }
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /** @internal */
  static _parse(state, index) {
    state._record();
    state._record();
    while (!state._done && !state._startsWith(...terminal)) {
      state._advance();
    }
    let key = state._playback();
    if (key.length === 0) {
      state._expect("parameter key");
    }
    let value;
    if (state._consumeOptional("=")) {
      state._record();
      while (!state._done && !state._startsWith(...terminal)) {
        state._advance();
      }
      value = decodeURIComponent(state._playback());
      if (value.length === 0) {
        state._expect("parameter value");
      }
    } else {
      value = key;
      key = index.toString();
    }
    state._discard();
    return new ParameterExpression(key, value);
  }
}
class ViewportRequest {
  constructor(viewportName, componentName) {
    this.viewportName = viewportName;
    this.componentName = componentName;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `VR(viewport:'${this.viewportName}',component:'${this.componentName}')`;
  }
}
const viewportAgentLookup = /* @__PURE__ */ new WeakMap();
class ViewportAgent {
  /** @internal */
  get _currState() {
    return this._state & 16256;
  }
  /** @internal */
  set _currState(state) {
    this._state = this._state & 127 | state;
  }
  /** @internal */
  get _nextState() {
    return this._state & 127;
  }
  /** @internal */
  set _nextState(state) {
    this._state = this._state & 16256 | state;
  }
  constructor(viewport2, hostController, ctx) {
    this.viewport = viewport2;
    this.hostController = hostController;
    this._isActive = false;
    this._curCA = null;
    this._nextCA = null;
    this._state = 8256;
    this._$plan = "replace";
    this._currNode = null;
    this._nextNode = null;
    this._currTransition = null;
    this._cancellationPromise = null;
    this._logger = ctx.container.get(ILogger).scopeTo(`ViewportAgent<${ctx.routeConfigContext._friendlyPath}>`);
    trace(
      this._logger,
      3300
      /* Events.vpaCreated */
    );
  }
  static for(viewport2, ctx) {
    let viewportAgent = viewportAgentLookup.get(viewport2);
    if (viewportAgent === void 0) {
      const controller = Controller.getCachedOrThrow(viewport2);
      viewportAgentLookup.set(viewport2, viewportAgent = new ViewportAgent(viewport2, controller, ctx));
    }
    return viewportAgent;
  }
  /** @internal */
  _activateFromViewport(initiator, parent) {
    const tr = this._currTransition;
    if (tr !== null) {
      ensureTransitionHasNotErrored(tr);
    }
    this._isActive = true;
    const logger = /* @__PURE__ */ this._logger.scopeTo("activateFromViewport()");
    switch (this._nextState) {
      case 64:
        switch (this._currState) {
          case 8192:
            trace(logger, 3301, this);
            return;
          case 4096:
            trace(logger, 3302, this);
            return this._curCA._activate(initiator, parent);
          default:
            this._unexpectedState("activateFromViewport 1");
        }
      case 2: {
        if (this._currTransition === null)
          throw new Error(getMessage(3350, this));
        trace(logger, 3303, this);
        const b = Batch._start((b1) => {
          this._activate(initiator, this._currTransition, b1);
        });
        const p = new Promise((resolve2) => {
          b._continueWith(() => {
            resolve2();
          });
        });
        return b._start()._done ? void 0 : p;
      }
      default:
        this._unexpectedState("activateFromViewport 2");
    }
  }
  /** @internal */
  _deactivateFromViewport(initiator, parent) {
    const tr = this._currTransition;
    if (tr !== null) {
      ensureTransitionHasNotErrored(tr);
    }
    this._isActive = false;
    const logger = /* @__PURE__ */ this._logger.scopeTo("deactivateFromViewport()");
    switch (this._currState) {
      case 8192:
        trace(logger, 3304, this);
        return;
      case 4096:
        trace(logger, 3305, this);
        return this._curCA._deactivate(initiator, parent);
      case 128:
        trace(logger, 3306, this);
        return;
      default: {
        if (this._currTransition === null)
          throw new Error(getMessage(3351, this));
        trace(logger, 3307, this);
        const b = Batch._start((b1) => {
          this._deactivate(initiator, this._currTransition, b1);
        });
        const p = new Promise((resolve2) => {
          b._continueWith(() => {
            resolve2();
          });
        });
        return b._start()._done ? void 0 : p;
      }
    }
  }
  /** @internal */
  _handles(req) {
    if (!this._isAvailable()) {
      return false;
    }
    const $vp = this.viewport;
    const reqVp = req.viewportName;
    const vp = $vp.name;
    const logger = /* @__PURE__ */ this._logger.scopeTo("handles()");
    if (reqVp !== defaultViewportName && vp !== reqVp) {
      trace(logger, 3308, req, vp);
      return false;
    }
    const usedBy = $vp.usedBy;
    if (usedBy.length > 0 && !usedBy.split(",").includes(req.componentName)) {
      trace(logger, 3309, req, usedBy);
      return false;
    }
    trace(logger, 3310, vp, req);
    return true;
  }
  /** @internal */
  _isAvailable() {
    const logger = /* @__PURE__ */ this._logger.scopeTo("isAvailable()");
    if (!this._isActive) {
      trace(
        logger,
        3311
        /* Events.vpaIsAvailableInactive */
      );
      return false;
    }
    if (this._nextState !== 64) {
      trace(logger, 3312, this._nextNode);
      return false;
    }
    return true;
  }
  /** @internal */
  _canUnload(tr, b) {
    if (this._currTransition === null) {
      this._currTransition = tr;
    }
    ensureTransitionHasNotErrored(tr);
    if (tr.guardsResult !== true) {
      return;
    }
    b._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("canUnload()");
    void onResolve(this._cancellationPromise, () => {
      Batch._start((b1) => {
        trace(logger, 3313, this);
        for (const node of this._currNode.children) {
          node.context.vpa._canUnload(tr, b1);
        }
      })._continueWith((b1) => {
        switch (this._currState) {
          case 4096:
            trace(logger, 3314, this);
            switch (this._$plan) {
              case "none":
                this._currState = 1024;
                return;
              case "invoke-lifecycles":
              case "replace":
                this._currState = 2048;
                b1._push();
                Batch._start((b2) => {
                  trace(logger, 3315, this);
                  this._curCA._canUnload(tr, this._nextNode, b2);
                })._continueWith(() => {
                  trace(logger, 3316, this);
                  this._currState = 1024;
                  b1._pop();
                })._start();
                return;
            }
          case 8192:
            trace(logger, 3317, this);
            return;
          default:
            tr._handleError(new Error(`Unexpected state at canUnload of ${this}`));
        }
      })._continueWith(() => {
        b._pop();
      })._start();
    });
  }
  /** @internal */
  _canLoad(tr, b) {
    if (this._currTransition === null) {
      this._currTransition = tr;
    }
    ensureTransitionHasNotErrored(tr);
    if (tr.guardsResult !== true) {
      return;
    }
    b._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("canLoad()");
    Batch._start((b1) => {
      switch (this._nextState) {
        case 32:
          trace(logger, 3318, this);
          this._nextState = 16;
          switch (this._$plan) {
            case "none":
              return;
            case "invoke-lifecycles":
              return this._curCA._canLoad(tr, this._nextNode, b1);
            case "replace":
              b1._push();
              void onResolve(this._nextNode.context._createComponentAgent(this.hostController, this._nextNode), (ca) => {
                (this._nextCA = ca)._canLoad(tr, this._nextNode, b1);
                b1._pop();
              });
          }
        case 64:
          trace(logger, 3319, this);
          return;
        default:
          this._unexpectedState("canLoad");
      }
    })._continueWith((b1) => {
      if (tr.guardsResult !== true) {
        trace(logger, 3354, tr.guardsResult, this._nextCA);
        return;
      }
      const next = this._nextNode;
      switch (this._$plan) {
        case "none":
        case "invoke-lifecycles": {
          trace(logger, 3320, next, this._$plan);
          b1._push();
          const ctx = next.context;
          void onResolve(ctx.routeConfigContext.allResolved, () => onResolve(onResolve(onResolveAll(...next.residue.splice(0).map((vi) => createAndAppendNodes(this._logger, next, vi))), () => onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
            const vp = vpa.viewport;
            const component = vp.default;
            if (component === null)
              return acc;
            acc.push(createAndAppendNodes(this._logger, next, ViewportInstruction.create({ component, viewport: vp.name })));
            return acc;
          }, []))), () => {
            b1._pop();
          }));
          return;
        }
        case "replace":
          trace(logger, 3321, next);
          return;
      }
    })._continueWith((b1) => {
      switch (this._nextState) {
        case 16:
          trace(logger, 3322, this);
          this._nextState = 8;
          for (const node of this._nextNode.children) {
            node.context.vpa._canLoad(tr, b1);
          }
          return;
        case 64:
          return;
        default:
          this._unexpectedState("canLoad");
      }
    })._continueWith(() => {
      trace(logger, 3323, this);
      b._pop();
    })._start();
  }
  /** @internal */
  _unloading(tr, b) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("unloading()");
    Batch._start((b1) => {
      trace(logger, 3324, this);
      for (const node of this._currNode.children) {
        node.context.vpa._unloading(tr, b1);
      }
    })._continueWith((b1) => {
      switch (this._currState) {
        case 1024:
          trace(logger, 3325, this);
          switch (this._$plan) {
            case "none":
              this._currState = 256;
              return;
            case "invoke-lifecycles":
            case "replace":
              this._currState = 512;
              b1._push();
              Batch._start((b2) => {
                trace(logger, 3326, this);
                this._curCA._unloading(tr, this._nextNode, b2);
              })._continueWith(() => {
                trace(logger, 3327, this);
                this._currState = 256;
                b1._pop();
              })._start();
              return;
          }
        case 8192:
          trace(logger, 3328, this);
          for (const node of this._currNode.children) {
            node.context.vpa._unloading(tr, b);
          }
          return;
        default:
          this._unexpectedState("unloading");
      }
    })._continueWith(() => {
      b._pop();
    })._start();
  }
  /** @internal */
  _loading(tr, b) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("loading()");
    Batch._start((b1) => {
      switch (this._nextState) {
        case 8: {
          trace(logger, 3329, this);
          this._nextState = 4;
          switch (this._$plan) {
            case "none":
              return;
            case "invoke-lifecycles":
              return this._curCA._loading(tr, this._nextNode, b1);
            case "replace":
              return this._nextCA._loading(tr, this._nextNode, b1);
          }
        }
        case 64:
          trace(logger, 3330, this);
          return;
        default:
          this._unexpectedState("loading");
      }
    })._continueWith((b1) => {
      switch (this._nextState) {
        case 4:
          trace(logger, 3331, this);
          this._nextState = 2;
          for (const node of this._nextNode.children) {
            node.context.vpa._loading(tr, b1);
          }
          return;
        case 64:
          return;
        default:
          this._unexpectedState("loading");
      }
    })._continueWith(() => {
      trace(logger, 3332, this);
      b._pop();
    })._start();
  }
  /** @internal */
  _deactivate(initiator, tr, b) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("deactivate()");
    switch (this._currState) {
      case 256:
        trace(logger, 3333, this);
        this._currState = 128;
        switch (this._$plan) {
          case "none":
          case "invoke-lifecycles":
            b._pop();
            return;
          case "replace": {
            const controller = this.hostController;
            const curCa = this._curCA;
            tr._run(() => {
              return onResolve(curCa._deactivate(initiator, controller), () => {
                if (initiator === null) {
                  curCa._dispose();
                }
              });
            }, () => {
              b._pop();
            });
          }
        }
        return;
      case 8192:
        trace(logger, 3334, this);
        b._pop();
        return;
      case 128:
        trace(logger, 3335, this);
        b._pop();
        return;
      default:
        this._unexpectedState("deactivate");
    }
  }
  /** @internal */
  _activate(initiator, tr, b) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("activate()");
    if (this._nextState === 32) {
      trace(logger, 3336, this);
      Batch._start((b1) => {
        this._canLoad(tr, b1);
      })._continueWith((b1) => {
        this._loading(tr, b1);
      })._continueWith((b1) => {
        this._activate(initiator, tr, b1);
      })._continueWith(() => {
        b._pop();
      })._start();
      return;
    }
    switch (this._nextState) {
      case 2:
        trace(logger, 3337, this);
        this._nextState = 1;
        Batch._start((b1) => {
          switch (this._$plan) {
            case "none":
            case "invoke-lifecycles":
              return;
            case "replace": {
              const controller = this.hostController;
              tr._run(() => {
                b1._push();
                return this._nextCA._activate(initiator, controller);
              }, () => {
                b1._pop();
              });
            }
          }
        })._continueWith((b1) => {
          this._processDynamicChildren(tr, b1);
        })._continueWith(() => {
          b._pop();
        })._start();
        return;
      case 64:
        trace(logger, 3338, this);
        b._pop();
        return;
      default:
        this._unexpectedState("activate");
    }
  }
  /** @internal */
  _swap(tr, b) {
    const logger = /* @__PURE__ */ this._logger.scopeTo("swap()");
    if (this._currState === 8192) {
      trace(logger, 3339, this);
      this._activate(null, tr, b);
      return;
    }
    if (this._nextState === 64) {
      trace(logger, 3340, this);
      this._deactivate(null, tr, b);
      return;
    }
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    if (!(this._currState === 256 && this._nextState === 2)) {
      this._unexpectedState("swap");
    }
    this._currState = 128;
    this._nextState = 1;
    switch (this._$plan) {
      case "none":
      case "invoke-lifecycles": {
        trace(logger, 3341, this);
        const nodes = mergeDistinct(this._nextNode.children, this._currNode.children);
        for (const node of nodes) {
          node.context.vpa._swap(tr, b);
        }
        return;
      }
      case "replace": {
        trace(logger, 3342, this);
        const controller = this.hostController;
        const curCA = this._curCA;
        const nextCA = this._nextCA;
        b._push();
        Batch._start((b1) => {
          tr._run(() => {
            b1._push();
            return onResolve(curCA._deactivate(null, controller), () => curCA._dispose());
          }, () => {
            b1._pop();
          });
        })._continueWith((b1) => {
          tr._run(() => {
            b1._push();
            return nextCA._activate(null, controller);
          }, () => {
            b1._pop();
          });
        })._continueWith((b1) => {
          this._processDynamicChildren(tr, b1);
        })._continueWith(() => {
          b._pop();
        })._start();
        return;
      }
    }
  }
  /** @internal */
  _processDynamicChildren(tr, b) {
    trace(this._logger, 3343, this);
    const next = this._nextNode;
    tr._run(() => {
      b._push();
      const ctx = next.context;
      return onResolve(ctx.routeConfigContext.allResolved, () => {
        const existingChildren = next.children.slice();
        return onResolve(onResolveAll(...next.residue.splice(0).map((vi) => createAndAppendNodes(this._logger, next, vi))), () => onResolve(onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
          const vp = vpa.viewport;
          const component = vp.default;
          if (component === null)
            return acc;
          acc.push(createAndAppendNodes(this._logger, next, ViewportInstruction.create({ component, viewport: vp.name })));
          return acc;
        }, [])), () => next.children.filter((x) => !existingChildren.includes(x))));
      });
    }, (newChildren) => {
      Batch._start((b1) => {
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._canLoad(tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith((b1) => {
        if (tr.guardsResult !== true)
          return;
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._loading(tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith((b1) => {
        if (tr.guardsResult !== true)
          return;
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._activate(null, tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith(() => {
        b._pop();
      })._start();
    });
  }
  /** @internal */
  _scheduleUpdate(options, next) {
    switch (this._nextState) {
      case 64:
        this._nextNode = next;
        this._nextState = 32;
        break;
      default:
        this._unexpectedState("scheduleUpdate 1");
    }
    switch (this._currState) {
      case 8192:
      case 4096:
      case 1024:
        break;
      default:
        this._unexpectedState("scheduleUpdate 2");
    }
    const cur = this._curCA?._routeNode ?? null;
    if (cur === null || cur.component !== next.component) {
      this._$plan = "replace";
    } else {
      this._$plan = next.context.routeConfigContext.config._getTransitionPlan(cur, next, options.transitionPlan);
    }
    trace(this._logger, 3344, this);
  }
  /** @internal */
  _cancelUpdate() {
    if (this._currNode !== null) {
      this._currNode.children.forEach(function(node) {
        node.context.vpa._cancelUpdate();
      });
    }
    if (this._nextNode !== null) {
      this._nextNode.children.forEach(function(node) {
        node.context.vpa._cancelUpdate();
      });
    }
    trace(this._logger, 3345, this._nextNode);
    let currentDeactivationPromise = null;
    let nextDeactivationPromise = null;
    switch (this._currState) {
      case 8192:
      case 4096:
        this._currTransition = null;
        break;
      case 2048:
      case 1024:
        this._currState = 4096;
        this._currTransition = null;
        break;
      case 512:
      case 256:
      case 128:
        currentDeactivationPromise = onResolve(this._curCA?._deactivate(null, this.hostController), () => {
          this._curCA?._dispose();
          this._currState = 8192;
          this._curCA = null;
        });
        break;
    }
    switch (this._nextState) {
      case 64:
      case 32:
      case 16:
      case 8:
        this._nextNode = null;
        this._nextState = 64;
        break;
      case 4:
      case 2:
      case 1: {
        nextDeactivationPromise = onResolve(this._nextCA?._deactivate(null, this.hostController), () => {
          this._nextCA?._dispose();
          this._$plan = "replace";
          this._nextState = 64;
          this._nextCA = null;
          this._nextNode = null;
        });
        break;
      }
    }
    if (currentDeactivationPromise !== null && nextDeactivationPromise !== null) {
      this._cancellationPromise = onResolve(onResolveAll(currentDeactivationPromise, nextDeactivationPromise), () => {
        this._currTransition = null;
        this._cancellationPromise = null;
      });
    }
  }
  /** @internal */
  _endTransition() {
    if (this._currNode !== null) {
      this._currNode.children.forEach(function(node) {
        node.context.vpa._endTransition();
      });
    }
    if (this._nextNode !== null) {
      this._nextNode.children.forEach(function(node) {
        node.context.vpa._endTransition();
      });
    }
    if (this._currTransition !== null) {
      const logger = /* @__PURE__ */ this._logger.scopeTo("endTransition()");
      ensureTransitionHasNotErrored(this._currTransition);
      switch (this._nextState) {
        case 64:
          switch (this._currState) {
            case 8192:
            case 128:
              trace(logger, 3346, this);
              this._currState = 8192;
              this._curCA = null;
              break;
            default:
              this._unexpectedState("endTransition 1");
          }
          break;
        case 1:
          switch (this._currState) {
            case 8192:
            case 128:
              switch (this._$plan) {
                case "none":
                  trace(logger, 3347, this);
                  this._currState = 4096;
                  break;
                case "invoke-lifecycles":
                  trace(logger, 3347, this);
                  this._currState = 4096;
                  this._curCA._routeNode = this._nextNode;
                  break;
                case "replace":
                  trace(logger, 3348, this);
                  this._currState = 4096;
                  this._curCA = this._nextCA;
                  break;
              }
              this._currNode = this._nextNode;
              break;
            default:
              this._unexpectedState("endTransition 2");
          }
          break;
        default:
          this._unexpectedState("endTransition 3");
      }
      this._$plan = "replace";
      this._nextState = 64;
      this._nextNode = null;
      this._nextCA = null;
      this._currTransition = null;
    }
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `VPA(state:${$state(this._state)},plan:'${this._$plan}',n:${this._nextNode},c:${this._currNode},viewport:${this.viewport})`;
  }
  /** @internal */
  _dispose() {
    trace(this._logger, 3349, this);
    this._curCA?._dispose();
  }
  /** @internal */
  _unexpectedState(label) {
    throw new Error(getMessage(3352, label, this));
  }
}
function ensureGuardsResultIsTrue(vpa, tr) {
  if (tr.guardsResult !== true)
    throw new Error(getMessage(3353, tr.guardsResult, vpa));
}
function ensureTransitionHasNotErrored(tr) {
  if (tr.error !== void 0 && !tr.erredWithUnknownRoute)
    throw tr.error;
}
const $stateCache = /* @__PURE__ */ new Map();
function $state(state) {
  let str = $stateCache.get(state);
  if (str === void 0) {
    $stateCache.set(state, str = stringifyState(state));
  }
  return str;
}
function stringifyState(state) {
  const flags = [];
  if ((state & 8192) === 8192) {
    flags.push("currIsEmpty");
  }
  if ((state & 4096) === 4096) {
    flags.push("currIsActive");
  }
  if ((state & 2048) === 2048) {
    flags.push("currCanUnload");
  }
  if ((state & 1024) === 1024) {
    flags.push("currCanUnloadDone");
  }
  if ((state & 512) === 512) {
    flags.push("currUnload");
  }
  if ((state & 256) === 256) {
    flags.push("currUnloadDone");
  }
  if ((state & 128) === 128) {
    flags.push("currDeactivate");
  }
  if ((state & 64) === 64) {
    flags.push("nextIsEmpty");
  }
  if ((state & 32) === 32) {
    flags.push("nextIsScheduled");
  }
  if ((state & 16) === 16) {
    flags.push("nextCanLoad");
  }
  if ((state & 8) === 8) {
    flags.push("nextCanLoadDone");
  }
  if ((state & 4) === 4) {
    flags.push("nextLoad");
  }
  if ((state & 2) === 2) {
    flags.push("nextLoadDone");
  }
  if ((state & 1) === 1) {
    flags.push("nextActivate");
  }
  return flags.join("|");
}
class RouteNode {
  get root() {
    return this._tree.root;
  }
  get isInstructionsFinalized() {
    return this._isInstructionsFinalized;
  }
  constructor(path, finalPath, context, _originalInstruction, instruction, params, queryParams, fragment, data, _viewport, title, component, residue) {
    this.path = path;
    this.finalPath = finalPath;
    this.context = context;
    this._originalInstruction = _originalInstruction;
    this.instruction = instruction;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this._viewport = _viewport;
    this.title = title;
    this.component = component;
    this.residue = residue;
    this._version = 1;
    this._isInstructionsFinalized = false;
    this.children = [];
    this._originalInstruction ??= instruction;
  }
  static create(input) {
    const { [RESIDUE]: _, ...params } = input.params ?? {};
    return new RouteNode(
      /*        path */
      input.path,
      /*   finalPath */
      input.finalPath,
      /*     context */
      input.context,
      /* originalIns */
      input.originalInstruction ?? input.instruction,
      /* instruction */
      input.instruction,
      /*      params */
      Object.freeze(params),
      /* queryParams */
      input.queryParams ?? emptyQuery,
      /*    fragment */
      input.fragment ?? null,
      /*        data */
      Object.freeze(input.data ?? emptyObject),
      /*    viewport */
      input._viewport ?? null,
      /*       title */
      input.title ?? null,
      /*   component */
      input.component,
      /*     residue */
      input.residue ?? []
    );
  }
  contains(instructions, matchEndpoint = false) {
    if (this.context.routeConfigContext === instructions.options.context.routeConfigContext) {
      const nodeChildren = this.children;
      const instructionChildren = instructions.children;
      for (let i = 0, ii = nodeChildren.length; i < ii; ++i) {
        for (let j = 0, jj = instructionChildren.length; j < jj; ++j) {
          const instructionChild = instructionChildren[j];
          const instructionEndpoint = matchEndpoint ? instructionChild.recognizedRoute?.route.endpoint : null;
          const nodeChild = nodeChildren[i + j] ?? null;
          const instruction = nodeChild !== null ? nodeChild.isInstructionsFinalized ? nodeChild.instruction : nodeChild._originalInstruction : null;
          const childEndpoint = instruction?.recognizedRoute?.route.endpoint;
          if (i + j < ii && ((instructionEndpoint?.equalsOrResidual(childEndpoint) ?? false) || (instruction?.contains(instructionChild) ?? false))) {
            if (j + 1 === jj) {
              return true;
            }
          } else {
            break;
          }
        }
      }
    }
    return this.children.some(function(x) {
      return x.contains(instructions, matchEndpoint);
    });
  }
  /** @internal */
  _appendChild(child) {
    this.children.push(child);
    child._setTree(this._tree);
  }
  /** @internal */
  _clearChildren() {
    for (const c of this.children) {
      c._clearChildren();
      c.context.vpa._cancelUpdate();
    }
    this.children.length = 0;
  }
  getTitle(separator) {
    const titleParts = [
      ...this.children.map((x) => x.getTitle(separator)),
      typeof this.title === "function" ? this.title.call(void 0, this) : this.title
    ].filter((x) => x !== null);
    return titleParts.length === 0 ? null : titleParts.join(separator);
  }
  computeAbsolutePath() {
    if (this.context.routeConfigContext.isRoot) {
      return "";
    }
    const parentPath = this.context.parent.node.computeAbsolutePath();
    const thisPath = this.instruction.toUrlComponent(false);
    return parentPath.length > 0 ? thisPath.length > 0 ? `${parentPath}/${thisPath}` : parentPath : thisPath;
  }
  /** @internal */
  _setTree(tree) {
    this._tree = tree;
    for (const child of this.children) {
      child._setTree(tree);
    }
  }
  /** @internal */
  _finalizeInstruction() {
    this._isInstructionsFinalized = true;
    const children = this.children.map((x) => x._finalizeInstruction());
    const instruction = this.instruction._clone();
    instruction.children.splice(0, instruction.children.length, ...children);
    return this.instruction = instruction;
  }
  /** @internal */
  _clone() {
    const clone = new RouteNode(
      this.path,
      this.finalPath,
      this.context,
      this._originalInstruction,
      this.instruction,
      this.params,
      // as this is frozen, it's safe to share
      this.queryParams,
      // as this is frozen, it's safe to share
      this.fragment,
      this.data,
      // as this is frozen, it's safe to share
      this._viewport,
      this.title,
      this.component,
      [...this.residue]
    );
    const children = this.children;
    const len = children.length;
    for (let i = 0; i < len; ++i) {
      clone.children.push(children[i]._clone());
    }
    clone._version = this._version + 1;
    if (clone.context.node === this) {
      clone.context.node = clone;
    }
    return clone;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const props2 = [];
    const component = this.context?.routeConfigContext.config._getComponentName() ?? "";
    if (component.length > 0) {
      props2.push(`c:'${component}'`);
    }
    const path = this.context?.routeConfigContext.config.path ?? "";
    if (path.length > 0) {
      props2.push(`path:'${path}'`);
    }
    if (this.children.length > 0) {
      props2.push(`children:[${this.children.map(String).join(",")}]`);
    }
    if (this.residue.length > 0) {
      props2.push(`residue:${this.residue.map(function(r) {
        if (typeof r === "string") {
          return `'${r}'`;
        }
        return String(r);
      }).join(",")}`);
    }
    return `RN(ctx:'${this.context?.routeConfigContext._friendlyPath}',${props2.join(",")})`;
  }
}
class RouteTree {
  constructor(options, queryParams, fragment, root) {
    this.options = options;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.root = root;
  }
  contains(instructions, matchEndpoint = false) {
    return this.root.contains(instructions, matchEndpoint);
  }
  /** @internal */
  _clone() {
    const clone = new RouteTree(
      this.options._clone(),
      this.queryParams,
      // as this is frozen, it's safe to share
      this.fragment,
      this.root._clone()
    );
    clone.root._setTree(this);
    return clone;
  }
  /** @internal */
  _finalizeInstructions() {
    return new ViewportInstructionTree(this.options, true, this.root.children.map((x) => x._finalizeInstruction()), this.queryParams, this.fragment);
  }
  /** @internal */
  _mergeQuery(other) {
    this.queryParams = Object.freeze(mergeURLSearchParams(this.queryParams, other, true));
  }
  toString() {
    return this.root.toString();
  }
}
function createAndAppendNodes(log, node, vi) {
  log.trace(`createAndAppendNodes(node:%s,vi:%s`, node, vi);
  switch (vi.component.type) {
    case 0:
      switch (vi.component.value) {
        case "..":
          node = node.context.parent?.node ?? node;
          node._clearChildren();
        // falls through
        case ".":
          return onResolveAll(...vi.children.map((childVI) => {
            return createAndAppendNodes(log, node, childVI);
          }));
        default: {
          log.trace(`createAndAppendNodes invoking createNode`);
          const ctx = node.context;
          const originalInstruction = vi._clone();
          let rr = vi.recognizedRoute;
          if (rr !== null)
            return appendNode(log, node, createConfiguredNode(log, node, vi, rr, originalInstruction));
          if (vi.children.length === 0) {
            const result = ctx.routeConfigContext._generateViewportInstruction(vi);
            if (result !== null) {
              node._tree._mergeQuery(result.query);
              const newVi = result.vi;
              newVi.children.push(...vi.children);
              return appendNode(log, node, createConfiguredNode(log, node, newVi, newVi.recognizedRoute, vi));
            }
          }
          let collapse = 0;
          let path = vi.component.value;
          let cur = vi;
          while (cur.children.length === 1) {
            cur = cur.children[0];
            if (cur.component.type === 0) {
              ++collapse;
              path = `${path}/${cur.component.value}`;
            } else {
              break;
            }
          }
          rr = ctx.routeConfigContext.recognize(path);
          log.trace("createNode recognized route: %s", rr);
          const residue = rr?.residue ?? null;
          log.trace("createNode residue:", residue);
          const noResidue = residue === null;
          if (rr === null || residue === path) {
            const eagerResult = ctx.routeConfigContext._generateViewportInstruction({
              component: vi.component.value,
              params: vi.params ?? emptyObject,
              open: vi.open,
              close: vi.close,
              viewport: vi.viewport,
              children: vi.children
            });
            if (eagerResult !== null) {
              node._tree._mergeQuery(eagerResult.query);
              return appendNode(log, node, createConfiguredNode(log, node, eagerResult.vi, eagerResult.vi.recognizedRoute, vi));
            }
            const name2 = vi.component.value;
            if (name2 === "")
              return;
            let vp = vi.viewport;
            if (vp === null || vp.length === 0)
              vp = defaultViewportName;
            const vpa = ctx.getFallbackViewportAgent(vp);
            const fallback = vpa !== null ? vpa.viewport._getFallback(vi, node, ctx) : ctx.routeConfigContext.config._getFallback(vi, node, ctx);
            if (fallback === null)
              throw new UnknownRouteError(getMessage(3401, name2, ctx.routeConfigContext._friendlyPath, vp, name2, ctx.routeConfigContext.component.name));
            if (typeof fallback === "string") {
              log.trace(`Fallback is set to '${fallback}'. Looking for a recognized route.`);
              const rd = ctx.routeConfigContext.childRoutes.find((x) => x.id === fallback);
              if (rd !== void 0)
                return appendNode(log, node, createFallbackNode(log, rd, node, vi));
              log.trace(`No route configuration for the fallback '${fallback}' is found; trying to recognize the route.`);
              const rr2 = ctx.routeConfigContext.recognize(fallback, true);
              if (rr2 !== null && rr2.residue !== fallback)
                return appendNode(log, node, createConfiguredNode(log, node, vi, rr2, null));
            }
            log.trace(`The fallback '${fallback}' is not recognized as a route; treating as custom element name.`);
            return onResolve(resolveRouteConfiguration(fallback, false, ctx.routeConfigContext.config, null, ctx.routeConfigContext), (rc) => appendNode(log, node, createFallbackNode(log, rc, node, vi)));
          }
          rr.residue = null;
          vi.component.value = noResidue ? path : path.slice(0, -(residue.length + 1));
          let addResidue = !noResidue;
          for (let i = 0; i < collapse; ++i) {
            const child = vi.children[0];
            if (residue?.startsWith(child.component.value) ?? false) {
              addResidue = false;
              break;
            }
            vi.viewport = child.viewport;
            vi.children = child.children;
          }
          if (addResidue) {
            vi.children.unshift(ViewportInstruction.create(residue));
          }
          vi.recognizedRoute = rr;
          log.trace("createNode after adjustment vi:%s", vi);
          return appendNode(log, node, createConfiguredNode(log, node, vi, rr, originalInstruction));
        }
      }
    case 3:
    case 4:
    case 2: {
      const rc = node.context;
      return onResolve(resolveCustomElementDefinition(vi.component.value, rc.routeConfigContext)[1], (ced) => {
        const { vi: newVi, query } = rc.routeConfigContext._generateViewportInstruction({
          component: ced,
          params: vi.params ?? emptyObject,
          open: vi.open,
          close: vi.close,
          viewport: vi.viewport,
          children: vi.children
        });
        node._tree._mergeQuery(query);
        return appendNode(log, node, createConfiguredNode(log, node, newVi, newVi.recognizedRoute, vi));
      });
    }
  }
}
function createConfiguredNode(log, node, vi, rr, originalVi, route2 = rr.route.endpoint.route) {
  const ctx = node.context;
  const rt = node._tree;
  return onResolve(route2.handler, ($handler) => {
    route2.handler = $handler;
    log.trace(`creatingConfiguredNode(rdc:%s, vi:%s)`, $handler, vi);
    if ($handler.redirectTo === null) {
      const viWithVp = (vi.viewport?.length ?? 0) > 0;
      const vpName = viWithVp ? vi.viewport : $handler.viewport;
      return onResolve(resolveCustomElementDefinition($handler._getComponent(vi, ctx, node, rr.route), ctx.routeConfigContext)[1], (ced) => {
        const vpa = ctx._resolveViewportAgent(new ViewportRequest(vpName, ced.name));
        if (!viWithVp) {
          vi.viewport = vpa.viewport.name;
        }
        const router = ctx.container.get(IRouter);
        return onResolve(router.getRouteContext(vpa, ced, null, vpa.hostController.container, ctx.routeConfigContext.config, ctx, $handler), (childCtx) => {
          log.trace("createConfiguredNode setting the context node");
          const $node = childCtx.node = RouteNode.create({
            path: rr.route.endpoint.route.path,
            finalPath: route2.path,
            context: childCtx,
            instruction: vi,
            originalInstruction: originalVi,
            params: rr.route.params,
            queryParams: rt.queryParams,
            fragment: rt.fragment,
            data: $handler.data,
            _viewport: vpName,
            component: ced,
            title: $handler.title,
            // Note: at this point, the residue from the recognized route should be converted to VI children. Hence the residues are not added back to the RouteNode.
            residue: vi.children.slice()
          });
          $node._setTree(node._tree);
          log.trace(`createConfiguredNode(vi:%s) -> %s`, vi, $node);
          return $node;
        });
      });
    }
    const origPath = RouteExpression.parse(pathUrlParser.parse(route2.path));
    const redirPath = RouteExpression.parse(pathUrlParser.parse($handler.redirectTo));
    let origCur;
    let redirCur;
    const newSegs = [];
    switch (origPath.root.kind) {
      case "ScopedSegment":
      case "Segment":
        origCur = origPath.root;
        break;
      default:
        throw new Error(getMessage(3502, origPath.root.kind));
    }
    switch (redirPath.root.kind) {
      case "ScopedSegment":
      case "Segment":
        redirCur = redirPath.root;
        break;
      default:
        throw new Error(getMessage(3502, redirPath.root.kind));
    }
    let origSeg;
    let redirSeg;
    let origDone = false;
    let redirDone = false;
    while (!(origDone && redirDone)) {
      if (origDone) {
        origSeg = null;
      } else if (origCur.kind === "Segment") {
        origSeg = origCur;
        origDone = true;
      } else if (origCur.left.kind === "Segment") {
        origSeg = origCur.left;
        switch (origCur.right.kind) {
          case "ScopedSegment":
          case "Segment":
            origCur = origCur.right;
            break;
          default:
            throw new Error(getMessage(3502, origCur.right.kind));
        }
      } else {
        throw new Error(getMessage(3502, origCur.left.kind));
      }
      if (redirDone) {
        redirSeg = null;
      } else if (redirCur.kind === "Segment") {
        redirSeg = redirCur;
        redirDone = true;
      } else if (redirCur.left.kind === "Segment") {
        redirSeg = redirCur.left;
        switch (redirCur.right.kind) {
          case "ScopedSegment":
          case "Segment":
            redirCur = redirCur.right;
            break;
          default:
            throw new Error(getMessage(3502, redirCur.right.kind));
        }
      } else {
        throw new Error(getMessage(3502, redirCur.left.kind));
      }
      if (redirSeg !== null) {
        if (redirSeg.component.isDynamic && (origSeg?.component.isDynamic ?? false)) {
          newSegs.push(rr.route.params[redirSeg.component.parameterName]);
        } else {
          newSegs.push(redirSeg.component.name);
        }
      }
    }
    const newPath = newSegs.filter(Boolean).join("/");
    const redirRR = ctx.routeConfigContext.recognize(newPath);
    if (redirRR === null)
      throw new UnknownRouteError(getMessage(3402, newPath, ctx.routeConfigContext._friendlyPath, newPath, ctx.routeConfigContext.component.name));
    return createConfiguredNode(log, node, ViewportInstruction.create({
      recognizedRoute: redirRR,
      component: newPath,
      children: vi.children,
      viewport: vi.viewport,
      open: vi.open,
      close: vi.close
    }), redirRR, originalVi);
  });
}
function appendNode(log, node, childNode) {
  return onResolve(childNode, ($childNode) => {
    log.trace(`appendNode($childNode:%s)`, $childNode);
    node._appendChild($childNode);
    return $childNode.context.vpa._scheduleUpdate(node._tree.options, $childNode);
  });
}
function createFallbackNode(log, rc, node, vi) {
  const rr = new $RecognizedRoute(new RecognizedRoute(new Endpoint(new ConfigurableRoute(rc.path[0], rc.caseSensitive, rc), []), emptyObject), null);
  vi.children.length = 0;
  return createConfiguredNode(log, node, vi, rr, null);
}
const emptyQuery = Object.freeze(new URLSearchParams());
function isManagedState(state) {
  return isObjectOrFunction(state) && Object.prototype.hasOwnProperty.call(state, AuNavId) === true;
}
function toManagedState(state, navId) {
  return { ...state, [AuNavId]: navId };
}
class UnknownRouteError extends Error {
}
class Transition {
  get erredWithUnknownRoute() {
    return this._erredWithUnknownRoute;
  }
  constructor(id2, prevInstructions, instructions, finalInstructions, instructionsChanged, trigger, options, managedState, previousRouteTree, routeTree, promise, resolve2, reject, guardsResult, error2) {
    this.id = id2;
    this.prevInstructions = prevInstructions;
    this.instructions = instructions;
    this.finalInstructions = finalInstructions;
    this.instructionsChanged = instructionsChanged;
    this.trigger = trigger;
    this.options = options;
    this.managedState = managedState;
    this.previousRouteTree = previousRouteTree;
    this.routeTree = routeTree;
    this.promise = promise;
    this.resolve = resolve2;
    this.reject = reject;
    this.guardsResult = guardsResult;
    this.error = error2;
    this._erredWithUnknownRoute = false;
  }
  /** @internal */
  static _create(input) {
    return new Transition(input.id, input.prevInstructions, input.instructions, input.finalInstructions, input.instructionsChanged, input.trigger, input.options, input.managedState, input.previousRouteTree, input.routeTree, input.promise, input.resolve, input.reject, input.guardsResult, void 0);
  }
  /** @internal */
  _run(cb, next) {
    if (this.guardsResult !== true) {
      return;
    }
    try {
      const ret = cb();
      if (ret instanceof Promise) {
        ret.then(next).catch((err) => {
          this._handleError(err);
        });
      } else {
        next(ret);
      }
    } catch (err) {
      this._handleError(err);
    }
  }
  /** @internal */
  _handleError(err) {
    this._erredWithUnknownRoute = err instanceof UnknownRouteError;
    this.reject(this.error = err);
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `T(id:${this.id},trigger:'${this.trigger}',instructions:${this.instructions})`;
  }
}
const IRouter = /* @__PURE__ */ DI.createInterface("IRouter", (x) => x.singleton(Router));
class Router {
  /** @internal */
  get _ctx() {
    const ctx = this._$ctx;
    if (ctx !== null)
      return ctx;
    if (!this._container.has(IRouteContext, true))
      throw new Error(getMessage(
        3271
        /* Events.rtrNoCtx */
      ));
    return this._$ctx = this._container.get(IRouteContext);
  }
  get routeTree() {
    let routeTree = this._routeTree;
    if (routeTree === null) {
      const ctx = this._ctx;
      routeTree = this._routeTree = new RouteTree(NavigationOptions.create(this.options, {}), emptyQuery, null, RouteNode.create({
        path: "",
        finalPath: "",
        context: ctx,
        instruction: null,
        component: CustomElement.getDefinition(ctx.routeConfigContext.config.component),
        title: ctx.routeConfigContext.config.title
      }));
    }
    return routeTree;
  }
  get currentTr() {
    return this._currentTr ??= Transition._create({
      id: 0,
      prevInstructions: this._instructions,
      instructions: this._instructions,
      finalInstructions: this._instructions,
      instructionsChanged: true,
      trigger: "api",
      options: NavigationOptions.create(this.options, {}),
      managedState: null,
      previousRouteTree: this.routeTree._clone(),
      routeTree: this.routeTree,
      resolve: null,
      reject: null,
      promise: null,
      guardsResult: true,
      error: void 0
    });
  }
  /** @internal */
  set currentTr(value) {
    this._currentTr = value;
  }
  get isNavigating() {
    return this._isNavigating;
  }
  constructor() {
    this._$ctx = null;
    this._routeTree = null;
    this._currentTr = null;
    this._navigated = false;
    this._navigationId = 0;
    this._nextTr = null;
    this._locationChangeSubscription = null;
    this._hasTitleBuilder = false;
    this._activeContexts = [];
    this._isNavigating = false;
    this._container = resolve(IContainer);
    this._p = resolve(IPlatform);
    this._logger = resolve(ILogger).root.scopeTo("Router");
    this._events = resolve(IRouterEvents);
    this._locationMgr = resolve(ILocationManager);
    this.options = resolve(IRouterOptions);
    this._routeConfigLookup = /* @__PURE__ */ new WeakMap();
    this._vpaLookup = /* @__PURE__ */ new Map();
    this._instructions = ViewportInstructionTree.create("", this.options, null, null);
    this._container.registerResolver(Router, Registration.instance(Router, this));
  }
  /**
   * Get the closest RouteContext relative to the provided component, controller or node.
   *
   * @param context - The object from which to resolve the closest RouteContext.
   *
   * @returns when the value is:
   * - `null`: the root
   * - `IRouteContext`: the provided value (no-op)
   * - `HTMLElement`: the context of the routeable component (page) that directly or indirectly contains this element.
   * - `ICustomElementViewModel` (the `this` object when working from inside a view model): the context of this component (if it was loaded as a route), or the routeable component (page) directly or indirectly containing it.
   * - `ICustomElementController`: same as `ICustomElementViewModel`, but using the controller object instead of the view model object (advanced users).
   *
   * @internal
   */
  _resolveContext(context) {
    return RouteContext.resolve(this._ctx, context);
  }
  start(performInitialNavigation) {
    this._hasTitleBuilder = typeof this.options.buildTitle === "function";
    this._locationMgr.startListening();
    this._locationChangeSubscription = this._events.subscribe("au:router:location-change", (e) => {
      this._p.taskQueue.queueTask(() => {
        const state = isManagedState(e.state) ? e.state : null;
        const routerOptions = this.options;
        const options = NavigationOptions.create(routerOptions, { historyStrategy: "replace" });
        const instructions = ViewportInstructionTree.create(e.url, routerOptions, options, this._ctx);
        this._enqueue(instructions, e.trigger, state, null);
      });
    });
    if (!this._navigated && performInitialNavigation) {
      return this.load(this._locationMgr.getPath(), { historyStrategy: this.options.historyStrategy !== "none" ? "replace" : "none" });
    }
  }
  stop() {
    this._locationMgr.stopListening();
    this._locationChangeSubscription?.dispose();
  }
  load(instructionOrInstructions, options) {
    return onResolve(this.createViewportInstructions(instructionOrInstructions, options ?? null), (instructions) => {
      trace(this._logger, 3250, instructions);
      return this._enqueue(instructions, "api", null, null);
    });
  }
  isActive(instructionOrInstructions, context) {
    const ctx = this._resolveContext(context);
    const instructions = instructionOrInstructions instanceof ViewportInstructionTree ? instructionOrInstructions : this.createViewportInstructions(instructionOrInstructions, { context: ctx, historyStrategy: this.options.historyStrategy });
    trace(this._logger, 3251, instructions, ctx);
    return this.routeTree.contains(instructions, false);
  }
  /**
   * Retrieve the RouteContext, which contains statically configured routes combined with the customElement metadata associated with a type.
   *
   * The customElement metadata is lazily associated with a type via the RouteContext the first time `getOrCreate` is called.
   *
   * @param viewportAgent - The ViewportAgent hosting the component associated with this RouteContext. If the RouteContext for the component+viewport combination already exists, the ViewportAgent will be updated in case it changed.
   * @param componentDefinition - The custom element definition.
   * @param container - The `controller.container` of the component hosting the viewport that the route will be loaded into.
   *
   */
  getRouteContext(viewportAgent, componentDefinition, componentInstance, container, parentRouteConfig, parentContext, $rdConfig) {
    const logger = /* @__PURE__ */ container.get(ILogger).scopeTo("RouteContext");
    return onResolve(this.getRouteConfigContext($rdConfig, componentDefinition, componentInstance, container, parentRouteConfig, parentContext?.routeConfigContext ?? null), (rdConfigContext) => {
      let routeConfigLookup = this._vpaLookup.get(viewportAgent);
      if (routeConfigLookup === void 0) {
        this._vpaLookup.set(viewportAgent, routeConfigLookup = /* @__PURE__ */ new WeakMap());
      }
      let routeContext = routeConfigLookup.get(rdConfigContext);
      if (routeContext !== void 0) {
        trace(logger, 3252, rdConfigContext);
        return routeContext;
      }
      trace(logger, 3253, rdConfigContext);
      const parent = container.has(IRouteContext, true) ? container.get(IRouteContext) : null;
      routeConfigLookup.set(rdConfigContext, routeContext = new RouteContext(viewportAgent, parent, container, this, rdConfigContext, this._locationMgr));
      return routeContext;
    });
  }
  getRouteConfigContext($rdConfig, componentDefinition, componentInstance, container, parentRouteConfig, parentRouteConfigContext) {
    return onResolve(
      // In case of navigation strategy, get the route config for the resolved component directly.
      // Conceptually, navigation strategy is another form of lazily deciding on the route config for the given component.
      // Hence, when we see a navigation strategy, we resolve the route config for the component first.
      $rdConfig instanceof RouteConfig && !$rdConfig._isNavigationStrategy ? $rdConfig : resolveRouteConfiguration(
        // getRouteConfig is prioritized over the statically configured routes via @route decorator.
        typeof componentInstance?.getRouteConfig === "function" ? componentInstance : componentDefinition.Type,
        false,
        parentRouteConfig,
        null,
        parentRouteConfigContext
      ),
      (rdConfig) => {
        let routeConfigContext = this._routeConfigLookup.get(rdConfig);
        if (routeConfigContext != null)
          return routeConfigContext;
        routeConfigContext = new RouteConfigContext(parentRouteConfigContext, componentDefinition, rdConfig, container, this);
        this._routeConfigLookup.set(rdConfig, routeConfigContext);
        return routeConfigContext;
      }
    );
  }
  /**
   * Generate a path from the provided instructions.
   *
   * @param instructionOrInstructions - The navigation instruction(s) to generate the path for.
   * @param context - The context to use for relative navigation. If not provided, the root context is used.
   */
  generatePath(instructionOrInstructions, context) {
    return onResolve(this.createViewportInstructions(createEagerInstructions(instructionOrInstructions), { context: context ?? this._ctx }, true), (vit) => vit.toUrl(true, this.options._urlParser));
  }
  createViewportInstructions(instructionOrInstructions, options, traverseChildren) {
    if (instructionOrInstructions instanceof ViewportInstructionTree)
      return instructionOrInstructions;
    let context = options?.context ?? null;
    if (context !== null)
      context = options.context = this._resolveContext(context);
    return (context ?? this._$ctx).createViewportInstructions(instructionOrInstructions, options, traverseChildren);
  }
  /**
   * Enqueue an instruction tree to be processed as soon as possible.
   *
   * Will wait for any existing in-flight transition to finish, otherwise starts immediately.
   *
   * @param instructions - The instruction tree that determines the transition
   * @param trigger - `'popstate'` or `'hashchange'` if initiated by a browser event, or `'api'` for manually initiated transitions via the `load` api.
   * @param state - The state to restore, if any.
   * @param failedTr - If this is a redirect / fallback from a failed transition, the previous transition is passed forward to ensure the original promise resolves with the latest result.
   *
   * @internal
   */
  _enqueue(instructions, trigger, state, failedTr) {
    const lastTr = this.currentTr;
    const logger = this._logger;
    if (trigger !== "api" && lastTr.trigger === "api" && lastTr.instructions.equals(instructions)) {
      debug(logger, 3254, trigger);
      return true;
    }
    let resolve2 = void 0;
    let reject = void 0;
    let promise;
    const restorePrevRT = this.options.restorePreviousRouteTreeOnError;
    if (failedTr === null || failedTr.erredWithUnknownRoute || failedTr.error != null && restorePrevRT) {
      promise = new Promise(function($resolve2, $reject2) {
        resolve2 = $resolve2;
        reject = $reject2;
      });
    } else {
      debug(logger, 3255, failedTr);
      promise = failedTr.promise;
      resolve2 = failedTr.resolve;
      reject = failedTr.reject;
    }
    const nextTr = this._nextTr = Transition._create({
      id: ++this._navigationId,
      trigger,
      managedState: state,
      prevInstructions: lastTr.finalInstructions,
      finalInstructions: instructions,
      instructionsChanged: !lastTr.finalInstructions.equals(instructions),
      instructions,
      options: instructions.options,
      promise,
      resolve: resolve2,
      reject,
      previousRouteTree: this.routeTree,
      routeTree: this._routeTree = this.routeTree._clone(),
      guardsResult: true,
      error: void 0
    });
    debug(logger, 3256, nextTr);
    if (!this._isNavigating) {
      try {
        this._run(nextTr);
      } catch (err) {
        nextTr._handleError(err);
      }
    }
    return nextTr.promise.then((ret) => {
      debug(logger, 3257, nextTr);
      return ret;
    }).catch((err) => {
      error(logger, 3270, nextTr, err);
      if (nextTr.erredWithUnknownRoute) {
        this._cancelNavigation(nextTr);
      } else {
        this._isNavigating = false;
        this._events.publish(new NavigationErrorEvent(nextTr.id, nextTr.instructions, err));
        if (restorePrevRT) {
          this._cancelNavigation(nextTr);
        } else {
          const $nextTr = this._nextTr;
          if ($nextTr !== null) {
            $nextTr.previousRouteTree = nextTr.previousRouteTree;
          } else {
            this._routeTree = nextTr.previousRouteTree;
          }
        }
      }
      throw err;
    });
  }
  /** @internal */
  _run(tr) {
    this.currentTr = tr;
    this._nextTr = null;
    this._isNavigating = true;
    for (const ctx of this._activeContexts) {
      ctx.routeConfigContext._handleNavigationStart();
    }
    let navigationContext = this._resolveContext(tr.options.context);
    const logger = /* @__PURE__ */ this._logger.scopeTo("run()");
    trace(logger, 3258, tr);
    this._events.publish(new NavigationStartEvent(tr.id, tr.instructions, tr.trigger, tr.managedState));
    if (this._nextTr !== null) {
      debug(logger, 3259, tr);
      return this._run(this._nextTr);
    }
    tr._run(() => {
      const vit = tr.finalInstructions;
      trace(logger, 3260, vit);
      const rootCtx = this._ctx;
      const rt = tr.routeTree;
      rt.options = vit.options;
      rt.queryParams = rootCtx.node._tree.queryParams = vit.queryParams;
      rt.fragment = rootCtx.node._tree.fragment = vit.fragment;
      const log = /* @__PURE__ */ navigationContext.container.get(ILogger).scopeTo("RouteTree");
      if (vit.isAbsolute) {
        navigationContext = rootCtx;
      }
      if (navigationContext === rootCtx) {
        rt.root._setTree(rt);
        rootCtx.node = rt.root;
      }
      const suffix = navigationContext.routeConfigContext.allResolved instanceof Promise ? " - awaiting promise" : "";
      log.trace(`updateRouteTree(rootCtx:%s,rt:%s,vit:%s)${suffix}`, rootCtx, rt, vit);
      return onResolve(navigationContext.routeConfigContext.allResolved, () => updateNode(log, vit, navigationContext, rootCtx.node));
    }, () => {
      const prev = tr.previousRouteTree.root.children;
      const next = tr.routeTree.root.children;
      const all2 = mergeDistinct(prev, next);
      Batch._start((b) => {
        trace(logger, 3261, prev.length);
        for (const node of prev) {
          node.context.vpa._canUnload(tr, b);
        }
      })._continueWith((b) => {
        if (tr.guardsResult !== true) {
          b._push();
          this._cancelNavigation(tr);
        }
      })._continueWith((b) => {
        trace(logger, 3262, next.length);
        for (const node of next) {
          node.context.vpa._canLoad(tr, b);
        }
      })._continueWith((b) => {
        if (tr.guardsResult !== true) {
          b._push();
          this._cancelNavigation(tr);
        }
      })._continueWith((b) => {
        trace(logger, 3263, prev.length);
        for (const node of prev) {
          node.context.vpa._unloading(tr, b);
        }
      })._continueWith((b) => {
        trace(logger, 3264, next.length);
        for (const node of next) {
          node.context.vpa._loading(tr, b);
        }
      })._continueWith((b) => {
        trace(logger, 3265, all2.length);
        for (const node of all2) {
          node.context.vpa._swap(tr, b);
        }
      })._continueWith((b) => {
        if (tr.guardsResult !== true) {
          b._push();
          this._cancelNavigation(tr);
        }
      })._continueWith(() => {
        trace(
          logger,
          3266
          /* Events.rtrRunFinalizing */
        );
        all2.forEach(function(node) {
          node.context.vpa._endTransition();
        });
        this._navigated = true;
        this._instructions = tr.finalInstructions = tr.routeTree._finalizeInstructions();
        this._isNavigating = false;
        const newUrl = tr.finalInstructions.toUrl(true, this.options._urlParser);
        switch (tr.options._getHistoryStrategy(this._instructions)) {
          case "none":
            break;
          case "push":
            this._locationMgr.pushState(toManagedState(tr.options.state, tr.id), this.updateTitle(tr), newUrl);
            break;
          case "replace":
            this._locationMgr.replaceState(toManagedState(tr.options.state, tr.id), this.updateTitle(tr), newUrl);
            break;
        }
        this._events.publish(new NavigationEndEvent(tr.id, tr.instructions, this._instructions));
        tr.resolve(true);
        this._runNextTransition();
      })._start();
    });
  }
  updateTitle(tr = this.currentTr) {
    const title = this._getTitle(tr);
    if (title.length > 0) {
      this._p.document.title = title;
    }
    return this._p.document.title;
  }
  /** @internal */
  _getTitle(tr = this.currentTr) {
    let title;
    if (this._hasTitleBuilder) {
      title = this.options.buildTitle(tr) ?? "";
    } else {
      switch (typeof tr.options.title) {
        case "function":
          title = tr.options.title.call(void 0, tr.routeTree.root) ?? "";
          break;
        case "string":
          title = tr.options.title;
          break;
        default:
          title = tr.routeTree.root.getTitle(tr.options.titleSeparator) ?? "";
          break;
      }
    }
    return title;
  }
  /** @internal */
  _subscribeNavigationStart(ctx) {
    this._activeContexts.push(ctx);
  }
  /** @internal */
  _unsubscribeNavigationStart(ctx) {
    const idx = this._activeContexts.indexOf(ctx);
    if (idx > -1) {
      this._activeContexts.splice(idx, 1);
    }
  }
  /** @internal */
  _cancelNavigation(tr) {
    const logger = /* @__PURE__ */ this._logger.scopeTo("cancelNavigation()");
    trace(logger, 3267, tr);
    const prev = tr.previousRouteTree.root.children;
    const next = tr.routeTree.root.children;
    const all2 = mergeDistinct(prev, next);
    all2.forEach(function(node) {
      node.context.vpa._cancelUpdate();
    });
    this._instructions = tr.prevInstructions;
    this._routeTree = tr.previousRouteTree;
    this._isNavigating = false;
    const guardsResult = tr.guardsResult;
    this._events.publish(new NavigationCancelEvent(tr.id, tr.instructions, `guardsResult is ${guardsResult}`));
    if (guardsResult === false) {
      tr.resolve(false);
      this._runNextTransition();
    } else {
      let instructions;
      if (this._navigated && (tr.erredWithUnknownRoute || tr.error != null && this.options.restorePreviousRouteTreeOnError))
        instructions = tr.prevInstructions;
      else if (guardsResult === true)
        return;
      else
        instructions = guardsResult;
      void onResolve(this._enqueue(instructions, "api", tr.managedState, tr), () => {
        trace(this._logger, 3268, tr);
      });
    }
  }
  /** @internal */
  _runNextTransition() {
    if (this._nextTr === null)
      return;
    trace(this._logger, 3269, this._nextTr);
    this._p.taskQueue.queueTask(() => {
      const nextTr = this._nextTr;
      if (nextTr === null)
        return;
      try {
        this._run(nextTr);
      } catch (err) {
        nextTr._handleError(err);
      }
    });
  }
}
function updateNode(log, vit, ctx, node) {
  log.trace(`updateNode(ctx:%s,node:%s)`, ctx, node);
  node.queryParams = vit.queryParams;
  node.fragment = vit.fragment;
  if (!node.context.routeConfigContext.isRoot) {
    node.context.vpa._scheduleUpdate(node._tree.options, node);
  }
  if (node.context === ctx) {
    node._clearChildren();
    return onResolve(onResolveAll(...vit.children.map((vi) => createAndAppendNodes(log, node, vi))), () => onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
      const vp = vpa.viewport;
      const component = vp.default;
      if (component === null)
        return acc;
      acc.push(createAndAppendNodes(log, node, ViewportInstruction.create({ component, viewport: vp.name })));
      return acc;
    }, [])));
  }
  return onResolveAll(...node.children.map((child) => {
    return updateNode(log, vit, ctx, child);
  }));
}
class ParsedUrl {
  constructor(path, query, fragment) {
    this.path = path;
    this.query = query;
    this.fragment = fragment;
    this.id = `${path}?${query?.toString() ?? ""}#${fragment ?? ""}`;
  }
  toString() {
    return this.id;
  }
  /** @internal */
  static _create(value) {
    let fragment = null;
    const fragmentStart = value.indexOf("#");
    if (fragmentStart >= 0) {
      const rawFragment = value.slice(fragmentStart + 1);
      fragment = decodeURIComponent(rawFragment);
      value = value.slice(0, fragmentStart);
    }
    let queryParams = null;
    const queryStart = value.indexOf("?");
    if (queryStart >= 0) {
      const queryString = value.slice(queryStart + 1);
      value = value.slice(0, queryStart);
      queryParams = Object.freeze(new URLSearchParams(queryString));
    }
    return new ParsedUrl(value, queryParams ?? emptyQuery, fragment);
  }
}
function stringify(pathOrParsedUrl, query, fragment) {
  let path;
  if (typeof pathOrParsedUrl === "string") {
    path = pathOrParsedUrl;
  } else {
    path = pathOrParsedUrl.path;
    query = pathOrParsedUrl.query;
    fragment = pathOrParsedUrl.fragment;
  }
  query ??= emptyQuery;
  let queryString = query.toString();
  queryString = queryString === "" ? "" : `?${queryString}`;
  const hash2 = fragment != null && fragment.length > 0 ? `#${encodeURIComponent(fragment)}` : "";
  return `${path}${queryString}${hash2}`;
}
const pathUrlParser = Object.freeze({
  parse(value) {
    return ParsedUrl._create(value);
  },
  stringify(pathOrParsedUrl, query, fragment) {
    return stringify(pathOrParsedUrl, query, fragment);
  }
});
const fragmentUrlParser = Object.freeze({
  parse(value) {
    const start2 = value.indexOf("#");
    if (start2 >= 0) {
      const rawFragment = value.slice(start2 + 1);
      value = decodeURIComponent(rawFragment);
    }
    return ParsedUrl._create(value);
  },
  stringify(pathOrParsedUrl, query, fragment) {
    return `/#/${stringify(pathOrParsedUrl, query, fragment)}`;
  }
});
function valueOrFuncToValue(instructions, valueOrFunc) {
  if (typeof valueOrFunc === "function") {
    return valueOrFunc(instructions);
  }
  return valueOrFunc;
}
const IRouterOptions = /* @__PURE__ */ DI.createInterface("RouterOptions");
class RouterOptions {
  constructor(useUrlFragmentHash, useHref, historyStrategy, buildTitle, useNavigationModel, activeClass, restorePreviousRouteTreeOnError) {
    this.useUrlFragmentHash = useUrlFragmentHash;
    this.useHref = useHref;
    this.historyStrategy = historyStrategy;
    this.buildTitle = buildTitle;
    this.useNavigationModel = useNavigationModel;
    this.activeClass = activeClass;
    this.restorePreviousRouteTreeOnError = restorePreviousRouteTreeOnError;
    this._urlParser = useUrlFragmentHash ? fragmentUrlParser : pathUrlParser;
  }
  static create(input) {
    return new RouterOptions(input.useUrlFragmentHash ?? false, input.useHref ?? true, input.historyStrategy ?? "push", input.buildTitle ?? null, input.useNavigationModel ?? true, input.activeClass ?? null, input.restorePreviousRouteTreeOnError ?? true);
  }
  toString() {
    return `RO(${[
      ["historyStrategy", "history"]
    ].map(([key, name2]) => {
      const value = this[key];
      return `${name2}:${typeof value === "function" ? value : `'${value}'`}`;
    }).join(",")})`;
  }
}
class NavigationOptions {
  constructor(historyStrategy, title, titleSeparator, context, queryParams, fragment, state, transitionPlan) {
    this.historyStrategy = historyStrategy;
    this.title = title;
    this.titleSeparator = titleSeparator;
    this.context = context;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.state = state;
    this.transitionPlan = transitionPlan;
  }
  static create(routerOptions, input) {
    return new NavigationOptions(input.historyStrategy ?? routerOptions.historyStrategy, input.title ?? null, input.titleSeparator ?? " | ", input.context ?? null, input.queryParams ?? null, input.fragment ?? "", input.state ?? null, input.transitionPlan ?? null);
  }
  /** @internal */
  _clone() {
    return new NavigationOptions(this.historyStrategy, this.title, this.titleSeparator, this.context, { ...this.queryParams }, this.fragment, this.state === null ? null : { ...this.state }, this.transitionPlan);
  }
  /** @internal */
  _getHistoryStrategy(instructions) {
    return valueOrFuncToValue(instructions, this.historyStrategy);
  }
}
const defaultViewportName = "default";
class ViewportInstruction {
  constructor(open, close, recognizedRoute, component, viewport2, params, children) {
    this.open = open;
    this.close = close;
    this.recognizedRoute = recognizedRoute;
    this.component = component;
    this.viewport = viewport2;
    this.params = params;
    this.children = children;
  }
  static create(instruction) {
    if (instruction instanceof ViewportInstruction)
      return instruction;
    if (isPartialViewportInstruction(instruction)) {
      const component = TypedNavigationInstruction.create(instruction.component);
      const children = instruction.children?.map(ViewportInstruction.create) ?? [];
      return new ViewportInstruction(instruction.open ?? 0, instruction.close ?? 0, instruction.recognizedRoute ?? null, component, instruction.viewport ?? null, Object.freeze(instruction.params ?? null), children);
    }
    const typedInstruction = TypedNavigationInstruction.create(instruction);
    return new ViewportInstruction(0, 0, null, typedInstruction, null, null, []);
  }
  contains(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length < otherChildren.length) {
      return false;
    }
    if (!this.component.equals(other.component))
      return false;
    const vp = this.viewport ?? null;
    const otherVp = other.viewport ?? null;
    if (vp !== null && otherVp !== null && vp !== otherVp)
      return false;
    for (let i = 0, ii = otherChildren.length; i < ii; ++i) {
      if (!thisChildren[i].contains(otherChildren[i])) {
        return false;
      }
    }
    return true;
  }
  equals(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length !== otherChildren.length) {
      return false;
    }
    if (!this.component.equals(other.component) || this.viewport !== other.viewport || !shallowEquals(this.params, other.params)) {
      return false;
    }
    for (let i = 0, ii = thisChildren.length; i < ii; ++i) {
      if (!thisChildren[i].equals(otherChildren[i])) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _clone() {
    return new ViewportInstruction(this.open, this.close, this.recognizedRoute, this.component._clone(), this.viewport, this.params, [...this.children]);
  }
  toUrlComponent(recursive = true) {
    const component = this.component.toUrlComponent();
    const vp = this.viewport;
    const viewport2 = component.length === 0 || vp === null || vp.length === 0 || vp === defaultViewportName ? "" : `@${vp}`;
    const thisPart = `${"(".repeat(this.open)}${component}${stringifyParams(this.params)}${viewport2}${")".repeat(this.close)}`;
    const childPart = recursive ? this.children.map((x) => x.toUrlComponent()).join("+") : "";
    return thisPart.length > 0 ? childPart.length > 0 ? `${thisPart}/${childPart}` : thisPart : childPart;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const component = `c:${this.component}`;
    const viewport2 = this.viewport === null || this.viewport.length === 0 ? "" : `viewport:${this.viewport}`;
    const children = this.children.length === 0 ? "" : `children:[${this.children.map(String).join(",")}]`;
    const props2 = [component, viewport2, children].filter(Boolean).join(",");
    return `VPI(${props2})`;
  }
}
function stringifyParams(params) {
  if (params === null)
    return "";
  const keys = Object.keys(params);
  const numKeys = keys.length;
  if (numKeys === 0)
    return "";
  const values = Array(numKeys);
  const indexKeys = [];
  const namedKeys = [];
  for (const key of keys) {
    if (isArrayIndex(key)) {
      indexKeys.push(Number(key));
    } else {
      namedKeys.push(key);
    }
  }
  for (let i = 0; i < numKeys; ++i) {
    const indexKeyIdx = indexKeys.indexOf(i);
    if (indexKeyIdx > -1) {
      values[i] = params[i];
      indexKeys.splice(indexKeyIdx, 1);
    } else {
      const namedKey = namedKeys.shift();
      values[i] = `${namedKey}=${params[namedKey]}`;
    }
  }
  return `(${values.join(",")})`;
}
class ViewportInstructionTree {
  constructor(options, isAbsolute, children, queryParams, fragment) {
    this.options = options;
    this.isAbsolute = isAbsolute;
    this.children = children;
    this.queryParams = queryParams;
    this.fragment = fragment;
    Object.freeze(queryParams);
  }
  static create(instructionOrInstructions, routerOptions, options, rootCtx, traverseChildren) {
    options = options instanceof NavigationOptions ? options : NavigationOptions.create(routerOptions, options ?? emptyObject);
    let context = options.context;
    if (!(context instanceof RouteContext) && rootCtx != null) {
      context = options.context = RouteContext.resolve(rootCtx, context);
    }
    const hasContext = context != null;
    if (instructionOrInstructions instanceof Array) {
      const len = instructionOrInstructions.length;
      const children = new Array(len);
      const query = new URLSearchParams(options.queryParams ?? emptyObject);
      const promises = new Array(len);
      for (let i = 0; i < len; i++) {
        const instruction = instructionOrInstructions[i];
        promises[i] = onResolve(hasContext ? context.routeConfigContext._generateViewportInstruction(instruction, traverseChildren) : null, (eagerVi) => {
          if (eagerVi !== null) {
            children[i] = eagerVi.vi;
            mergeURLSearchParams(query, eagerVi.query, false);
          } else {
            children[i] = ViewportInstruction.create(instruction);
          }
        });
      }
      return onResolve(onResolveAll(...promises), () => new ViewportInstructionTree(options, false, children, query, options.fragment));
    }
    if (typeof instructionOrInstructions === "string") {
      const expr = RouteExpression.parse(routerOptions._urlParser.parse(instructionOrInstructions));
      return expr.toInstructionTree(options);
    }
    return onResolve(hasContext ? context.routeConfigContext._generateViewportInstruction(isPartialViewportInstruction(instructionOrInstructions) ? { ...instructionOrInstructions, params: instructionOrInstructions.params ?? emptyObject } : { component: instructionOrInstructions, params: emptyObject }, traverseChildren) : null, (eagerVi) => {
      const query = new URLSearchParams(options.queryParams ?? emptyObject);
      return eagerVi !== null ? new ViewportInstructionTree(options, false, [eagerVi.vi], mergeURLSearchParams(query, eagerVi.query, false), options.fragment) : new ViewportInstructionTree(options, false, [ViewportInstruction.create(instructionOrInstructions)], query, options.fragment);
    });
  }
  equals(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length !== otherChildren.length) {
      return false;
    }
    for (let i = 0, ii = thisChildren.length; i < ii; ++i) {
      if (!thisChildren[i].equals(otherChildren[i])) {
        return false;
      }
    }
    return true;
  }
  toUrl(isFinalInstruction, parser) {
    let parentPath = "";
    if (!isFinalInstruction) {
      const parentPaths = [];
      let ctx = this.options.context;
      if (ctx != null && !(ctx instanceof RouteContext))
        throw new Error("Invalid operation; incompatible navigation context.");
      while (ctx != null && !ctx.routeConfigContext.isRoot) {
        const vpa = ctx.vpa;
        const node = vpa._currState === 4096 ? vpa._currNode : vpa._nextNode;
        if (node == null)
          throw new Error("Invalid operation; nodes of the viewport agent are not set.");
        parentPaths.splice(0, 0, node.instruction.toUrlComponent());
        ctx = ctx.parent;
      }
      if (parentPaths[0] === "") {
        parentPaths.splice(0, 1);
      }
      parentPath = parentPaths.join("/");
    }
    const currentPath = this.toPath();
    return parser.stringify(parentPath.length > 0 ? `${parentPath}/${currentPath}` : currentPath, this.queryParams, this.fragment);
  }
  toPath() {
    return this.children.map((x) => x.toUrlComponent()).join("+");
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `[${this.children.map(String).join(",")}]`;
  }
}
class NavigationStrategy {
  constructor(getComponent) {
    this.getComponent = getComponent;
  }
}
class TypedNavigationInstruction {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static create(instruction) {
    if (instruction instanceof TypedNavigationInstruction) {
      return instruction;
    }
    if (typeof instruction === "string")
      return new TypedNavigationInstruction(0, instruction);
    if (!isObjectOrFunction(instruction))
      expectType("function/class or object", "", instruction);
    if (instruction instanceof NavigationStrategy)
      return new TypedNavigationInstruction(5, instruction);
    if (typeof instruction === "function") {
      if (CustomElement.isType(instruction)) {
        const definition = CustomElement.getDefinition(instruction);
        return new TypedNavigationInstruction(2, definition);
      } else {
        return TypedNavigationInstruction.create(instruction());
      }
    }
    if (instruction instanceof Promise)
      return new TypedNavigationInstruction(3, instruction);
    if (isPartialViewportInstruction(instruction)) {
      const viewportInstruction = ViewportInstruction.create(instruction);
      return new TypedNavigationInstruction(1, viewportInstruction);
    }
    if (isCustomElementViewModel(instruction))
      return new TypedNavigationInstruction(4, instruction);
    if (instruction instanceof CustomElementDefinition)
      return new TypedNavigationInstruction(2, instruction);
    if (isPartialCustomElementDefinition(instruction)) {
      const definition = CustomElementDefinition.create(instruction);
      CustomElement.define(definition);
      return new TypedNavigationInstruction(2, definition);
    }
    throw new Error(getMessage(3400, tryStringify(instruction)));
  }
  equals(other) {
    switch (this.type) {
      case 5:
      case 2:
      case 4:
      case 3:
      case 0:
        return this.type === other.type && this.value === other.value;
      case 1:
        return this.type === other.type && this.value.equals(other.value);
    }
  }
  /** @internal */
  _clone() {
    return new TypedNavigationInstruction(this.type, this.value);
  }
  toUrlComponent() {
    switch (this.type) {
      case 2:
        return this.value.name;
      case 4:
      case 3:
      case 5:
        throw new Error(getMessage(3403, this.type));
      case 1:
        return this.value.toUrlComponent();
      case 0:
        return this.value;
    }
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    switch (this.type) {
      case 2:
        return `CEDef(name:'${this.value.name}')`;
      case 5:
        return `NS`;
      case 3:
        return `Promise`;
      case 4:
        return `VM(name:'${CustomElement.getDefinition(this.value.constructor).name}')`;
      case 1:
        return this.value.toString();
      case 0:
        return `'${this.value}'`;
    }
  }
}
class ComponentAgent {
  constructor(_instance, _controller, _routeNode, _ctx, _routerOptions) {
    this._instance = _instance;
    this._controller = _controller;
    this._routeNode = _routeNode;
    this._ctx = _ctx;
    this._routerOptions = _routerOptions;
    this._logger = _controller.container.get(ILogger).scopeTo(`ComponentAgent<${_ctx.routeConfigContext._friendlyPath}>`);
    trace(
      this._logger,
      3050
      /* Events.caCreated */
    );
    const lifecycleHooks = _controller.lifecycleHooks;
    this._canLoadHooks = (lifecycleHooks.canLoad ?? []).map((x) => x.instance);
    this._loadHooks = (lifecycleHooks.loading ?? []).map((x) => x.instance);
    this._canUnloadHooks = (lifecycleHooks.canUnload ?? []).map((x) => x.instance);
    this._unloadHooks = (lifecycleHooks.unloading ?? []).map((x) => x.instance);
    this._hasCanLoad = "canLoad" in _instance;
    this._hasLoad = "loading" in _instance;
    this._hasCanUnload = "canUnload" in _instance;
    this._hasUnload = "unloading" in _instance;
  }
  /** @internal */
  _activate(initiator, parent) {
    const controller = this._controller;
    const viewportController = this._ctx.vpa.hostController;
    switch (controller.mountTarget) {
      case MountTarget.host:
      case MountTarget.shadowRoot:
        viewportController.host.appendChild(controller.host);
        break;
      case MountTarget.location:
        viewportController.host.append(controller.location.$start, controller.location);
        break;
      case MountTarget.none:
        throw new Error("Invalid mount target for routed component");
    }
    if (initiator === null) {
      trace(
        this._logger,
        3051
        /* Events.caActivateSelf */
      );
      return this._controller.activate(this._controller, parent);
    }
    trace(
      this._logger,
      3052
      /* Events.caActivateInitiator */
    );
    void this._controller.activate(initiator, parent);
  }
  /** @internal */
  _deactivate(initiator, parent) {
    const controller = this._controller;
    controller.host?.remove();
    controller.location?.remove();
    controller.location?.$start?.remove();
    if (initiator === null) {
      trace(
        this._logger,
        3053
        /* Events.caDeactivateSelf */
      );
      return controller.deactivate(controller, parent);
    }
    trace(
      this._logger,
      3054
      /* Events.caDeactivateInitiator */
    );
    void controller.deactivate(initiator, parent);
  }
  /** @internal */
  _dispose() {
    trace(
      this._logger,
      3055
      /* Events.caDispose */
    );
    this._controller.dispose();
  }
  /** @internal */
  _canUnload(tr, next, b) {
    trace(this._logger, 3056, next, this._canUnloadHooks.length);
    b._push();
    let promise = Promise.resolve();
    for (const hook of this._canUnloadHooks) {
      b._push();
      promise = promise.then(() => new Promise((res) => {
        if (tr.guardsResult !== true) {
          b._pop();
          res();
          return;
        }
        tr._run(() => {
          return hook.canUnload(this._instance, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret === false) {
            tr.guardsResult = false;
          }
          b._pop();
          res();
        });
      }));
    }
    if (this._hasCanUnload) {
      b._push();
      promise = promise.then(() => {
        if (tr.guardsResult !== true) {
          b._pop();
          return;
        }
        tr._run(() => {
          return this._instance.canUnload(next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret === false) {
            tr.guardsResult = false;
          }
          b._pop();
        });
      });
    }
    b._pop();
  }
  /** @internal */
  _canLoad(tr, next, b) {
    trace(this._logger, 3057, next, this._canLoadHooks.length);
    const rootCtx = this._ctx.root;
    b._push();
    let promise = Promise.resolve();
    for (const hook of this._canLoadHooks) {
      b._push();
      promise = promise.then(() => new Promise((res) => {
        if (tr.guardsResult !== true) {
          b._pop();
          res();
          return;
        }
        tr._run(() => {
          return hook.canLoad(this._instance, next.params, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret != null && ret !== true) {
            tr.guardsResult = ret === false ? false : ViewportInstructionTree.create(ret, this._routerOptions, null, rootCtx);
          }
          b._pop();
          res();
        });
      }));
    }
    if (this._hasCanLoad) {
      b._push();
      promise = promise.then(() => {
        if (tr.guardsResult !== true) {
          b._pop();
          return;
        }
        tr._run(() => {
          return this._instance.canLoad(next.params, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret != null && ret !== true) {
            tr.guardsResult = ret === false ? false : ViewportInstructionTree.create(ret, this._routerOptions, null, rootCtx);
          }
          b._pop();
        });
      });
    }
    b._pop();
  }
  /** @internal */
  _unloading(tr, next, b) {
    trace(this._logger, 3058, next, this._unloadHooks.length);
    b._push();
    for (const hook of this._unloadHooks) {
      tr._run(() => {
        b._push();
        return hook.unloading(this._instance, next, this._routeNode);
      }, () => {
        b._pop();
      });
    }
    if (this._hasUnload) {
      tr._run(() => {
        b._push();
        return this._instance.unloading(next, this._routeNode);
      }, () => {
        b._pop();
      });
    }
    b._pop();
  }
  /** @internal */
  _loading(tr, next, b) {
    trace(this._logger, 3059, next, this._loadHooks.length);
    b._push();
    for (const hook of this._loadHooks) {
      tr._run(() => {
        b._push();
        return hook.loading(this._instance, next.params, next, this._routeNode);
      }, () => {
        b._pop();
      });
    }
    if (this._hasLoad) {
      tr._run(() => {
        b._push();
        return this._instance.loading(next.params, next, this._routeNode);
      }, () => {
        b._pop();
      });
    }
    b._pop();
  }
}
const IRouteContext = /* @__PURE__ */ DI.createInterface("IRouteContext");
const allowedEagerComponentTypes = Object.freeze(["string", "object", "function"]);
function isEagerInstruction(val) {
  if (val == null)
    return false;
  const params = val.params;
  const component = val.component;
  return typeof params === "object" && params !== null && component != null && allowedEagerComponentTypes.includes(typeof component) && !(component instanceof Promise) && !(component instanceof NavigationStrategy);
}
function createEagerInstructions(instructionOrInstructions) {
  if (!isArray(instructionOrInstructions))
    instructionOrInstructions = [instructionOrInstructions];
  const numInstr = instructionOrInstructions.length;
  for (let i = 0; i < numInstr; ++i) {
    const instr = core(instructionOrInstructions[i]);
    if (instr == null)
      throw new Error(getMessage(3404, instructionOrInstructions));
    instructionOrInstructions[i] = instr;
  }
  return instructionOrInstructions;
  function core(val) {
    let component;
    if (typeof val === "string" || typeof val === "function") {
      component = val;
      val = null;
    } else {
      component = val.component;
    }
    if (component == null || !allowedEagerComponentTypes.includes(typeof component) || component instanceof Promise || component instanceof NavigationStrategy)
      return null;
    return { ...val, component, params: val?.params ?? emptyObject };
  }
}
class RouteContext {
  get isRoot() {
    return this.parent === null;
  }
  get node() {
    const node = this._node;
    if (node === null)
      throw new Error(getMessage(3171, this));
    return node;
  }
  /** @internal */
  set node(value) {
    const prev = this._prevNode = this._node;
    if (prev !== value) {
      this._node = value;
      trace(this._logger, 3151, this._prevNode, value);
    }
  }
  /**
   * The viewport hosting the component associated with this RouteContext.
   * The root RouteContext has no ViewportAgent and will throw when attempting to access this property.
   */
  get vpa() {
    const vpa = this._vpa;
    if (vpa === null)
      throw new Error(getMessage(3172, this));
    return vpa;
  }
  constructor(viewportAgent, parent, parentContainer, _router, routeConfigContext, _locationMgr) {
    this.parent = parent;
    this._router = _router;
    this.routeConfigContext = routeConfigContext;
    this._locationMgr = _locationMgr;
    this._childViewportAgents = [];
    this._prevNode = null;
    this._node = null;
    this._vpa = viewportAgent;
    if (parent === null) {
      this.root = this;
    } else {
      this.root = parent.root;
    }
    this._logger = parentContainer.get(ILogger).scopeTo(`RouteContext<${this.routeConfigContext._friendlyPath}>`);
    trace(
      this._logger,
      3150
      /* Events.rcCreated */
    );
    this._router._subscribeNavigationStart(this);
    const container = this.container = parentContainer.createChild();
    this._platform = container.get(IPlatform);
    container.registerResolver(IController, this._hostControllerProvider = new InstanceProvider(), true);
    const ctxProvider = new InstanceProvider("IRouteContext", this);
    container.registerResolver(IRouteContext, ctxProvider);
    container.registerResolver(RouteContext, ctxProvider);
    if (_router.options.useNavigationModel) {
      container.get(IRouterEvents).subscribe("au:router:navigation-end", () => {
        routeConfigContext.navigationModel._setIsActive(_router, this);
      });
    }
  }
  /**
   * Create a new `RouteContext` and register it in the provided container.
   *
   * Uses the `RenderContext` of the registered `IAppRoot` as the root context.
   *
   * @param container - The container from which to resolve the `IAppRoot` and in which to register the `RouteContext`
   */
  static setRoot(container) {
    const logger = container.get(ILogger).scopeTo("RouteContext");
    if (!container.has(IAppRoot, true)) {
      logAndThrow(new Error(getMessage(
        3167
        /* Events.rcNoAppRoot */
      )), logger);
    }
    if (container.has(IRouteContext, true)) {
      logAndThrow(new Error(getMessage(
        3168
        /* Events.rcHasRootContext */
      )), logger);
    }
    const { controller } = container.get(IAppRoot);
    if (controller === void 0) {
      logAndThrow(new Error(getMessage(
        3169
        /* Events.rcNoRootCtrl */
      )), logger);
    }
    const router = container.get(IRouter);
    return onResolve(router.getRouteContext(null, controller.definition, controller.viewModel, controller.container, null, null, null), (routeContext) => {
      container.register(Registration.instance(IRouteContext, routeContext));
      routeContext.node = router.routeTree.root;
    });
  }
  static resolve(root, context) {
    const rootContainer = root.container;
    const logger = rootContainer.get(ILogger).scopeTo("RouteContext");
    if (context == null) {
      trace(logger, 3152, context);
      return root;
    }
    if (context instanceof RouteContext) {
      trace(logger, 3153, context);
      return context;
    }
    if (context instanceof rootContainer.get(IPlatform).Node) {
      trace(logger, 3154, context.nodeName);
      try {
        const controller = CustomElement.for(context, { searchParents: true });
        return controller.container.get(IRouteContext);
      } catch (err) {
        error(logger, 3155, context.nodeName, err);
        throw err;
      }
    }
    if (isCustomElementViewModel(context)) {
      const controller = context.$controller;
      trace(logger, 3156, controller.definition.name);
      return controller.container.get(IRouteContext);
    }
    if (isCustomElementController(context)) {
      const controller = context;
      trace(logger, 3157, controller.definition.name);
      return controller.container.get(IRouteContext);
    }
    logAndThrow(new Error(getMessage(3170, Object.prototype.toString.call(context))), logger);
  }
  dispose() {
    this.container.dispose();
    this._router._unsubscribeNavigationStart(this);
  }
  /** @internal */
  _resolveViewportAgent(req) {
    trace(this._logger, 3158, req);
    const agent = this._childViewportAgents.find((x) => {
      return x._handles(req);
    });
    if (agent === void 0)
      throw new Error(getMessage(3174, req, this._printTree()));
    return agent;
  }
  getAvailableViewportAgents() {
    return this._childViewportAgents.filter((x) => x._isAvailable());
  }
  getFallbackViewportAgent(name2) {
    return this._childViewportAgents.find((x) => x._isAvailable() && x.viewport.name === name2 && x.viewport.fallback !== "") ?? null;
  }
  /**
   * Create a component based on the provided viewportInstruction.
   *
   * @param hostController - The `ICustomElementController` whose component (typically `au-viewport`) will host this component.
   * @param routeNode - The routeNode that describes the component + state.
   *
   * @internal
   */
  _createComponentAgent(hostController, routeNode) {
    trace(this._logger, 3159, routeNode);
    this._hostControllerProvider.prepare(hostController);
    const container = this.container.createChild({ inheritParentResources: true });
    const platform = this._platform;
    const elDefn = routeNode.component;
    const host = platform.document.createElement(elDefn.name);
    registerHostNode(container, host, platform);
    const componentInstance = container.invoke(elDefn.Type);
    const task = this.routeConfigContext._childRoutesConfigured ? void 0 : onResolve(resolveRouteConfiguration(componentInstance, false, this.routeConfigContext.config, routeNode, null), (config) => this.routeConfigContext._processConfig(config));
    return onResolve(task, () => {
      const controller = Controller.$el(container, componentInstance, host, { projections: null }, elDefn);
      const componentAgent = new ComponentAgent(componentInstance, controller, routeNode, this, this._router.options);
      this._hostControllerProvider.dispose();
      return componentAgent;
    });
  }
  /**
   * Generates a path that is rooted to the application.
   */
  generateRootedPath(instructionOrInstructions) {
    return onResolve(this.createViewportInstructions(createEagerInstructions(instructionOrInstructions), null, true), (vit) => {
      const relativePath = vit.toUrl(true, this._router.options._urlParser);
      let parentPath = "";
      const parentSegments = [];
      let ctx = vit.options.context;
      while (!ctx.isRoot) {
        const seg = ctx.vpa?._currNode?.instruction?.toUrlComponent(false);
        if ((seg?.length ?? 0) !== 0)
          parentSegments.unshift(seg);
        ctx = ctx.parent;
      }
      parentPath = parentSegments.join("/");
      return parentPath.length === 0 ? relativePath : `${parentPath}/${relativePath}`;
    });
  }
  /**
   * Generates a path that is relative to the this context.
   */
  generateRelativePath(instructionOrInstructions) {
    return onResolve(this.createViewportInstructions(createEagerInstructions(instructionOrInstructions), null, true), (vit) => vit.toUrl(true, this._router.options._urlParser));
  }
  createViewportInstructions(instructionOrInstructions, options, traverseChildren) {
    if (instructionOrInstructions instanceof ViewportInstructionTree)
      return instructionOrInstructions;
    let context = options?.context ?? this;
    let contextChanged = false;
    if (!isArray(instructionOrInstructions)) {
      instructionOrInstructions = processStringInstruction.call(this, instructionOrInstructions);
    } else {
      const len = instructionOrInstructions.length;
      for (let i = 0; i < len; ++i) {
        instructionOrInstructions[i] = processStringInstruction.call(this, instructionOrInstructions[i]);
      }
    }
    const routerOptions = this._router.options;
    return ViewportInstructionTree.create(instructionOrInstructions, routerOptions, NavigationOptions.create(routerOptions, { ...options, context }), this.root, traverseChildren);
    function processStringInstruction(instr) {
      if (typeof instr === "string")
        instr = this._locationMgr.removeBaseHref(instr);
      const isVpInstr = isPartialViewportInstruction(instr);
      let $instruction = isVpInstr ? instr.component : instr;
      if (typeof $instruction === "string" && $instruction.startsWith("../") && context !== null) {
        while ($instruction.startsWith("../") && ((context?.parent ?? null) !== null || contextChanged)) {
          $instruction = $instruction.slice(3);
          if (!contextChanged)
            context = context.parent;
        }
        contextChanged = true;
      }
      if (isVpInstr) {
        instr.component = $instruction;
      } else {
        instr = $instruction;
      }
      return instr;
    }
  }
  /** @internal */
  _registerViewport(viewport2) {
    const agent = ViewportAgent.for(viewport2, this);
    if (this._childViewportAgents.includes(agent)) {
      trace(this._logger, 3161, agent);
      return agent;
    }
    trace(this._logger, 3160, agent);
    this._childViewportAgents.push(agent);
    return agent;
  }
  /** @internal */
  _unregisterViewport(viewport2) {
    const agent = ViewportAgent.for(viewport2, this);
    if (!this._childViewportAgents.includes(agent)) {
      trace(this._logger, 3163, agent);
      return;
    }
    trace(this._logger, 3162, agent);
    this._childViewportAgents.splice(this._childViewportAgents.indexOf(agent), 1);
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const vpAgents = this._childViewportAgents;
    const viewports = vpAgents.map(String).join(",");
    return `RC(path:'${this.routeConfigContext._friendlyPath}',viewports:[${viewports}])`;
  }
  /** @internal */
  _printTree() {
    const tree = [];
    const path = this.routeConfigContext.path;
    for (let i = 0; i < path.length; ++i) {
      tree.push(`${" ".repeat(i)}${path[i]}`);
    }
    return tree.join("\n");
  }
}
class RouteConfigContext {
  get isRoot() {
    return this.parent === null;
  }
  get depth() {
    return this.path.length - 1;
  }
  get navigationModel() {
    return this._navigationModel;
  }
  get allResolved() {
    return this._allResolved;
  }
  constructor(parent, component, config, parentContainer, _router) {
    this.parent = parent;
    this.component = component;
    this.config = config;
    this._router = _router;
    this._childRoutesConfigured = false;
    this.childRoutes = [];
    this._allResolved = null;
    if (parent === null) {
      this.root = this;
      this.path = [this];
      this._friendlyPath = component.name;
    } else {
      this.root = parent.root;
      this.path = [...parent.path, this];
      this._friendlyPath = `${parent._friendlyPath}/${component.name}`;
    }
    this._logger = parentContainer.get(ILogger).scopeTo(`RouteConfigContext<${this._friendlyPath}>`);
    trace(
      this._logger,
      3150
      /* Events.rcCreated */
    );
    this._moduleLoader = parentContainer.get(IModuleLoader);
    this.container = parentContainer.createChild();
    this._recognizer = new RouteRecognizer();
    if (_router.options.useNavigationModel) {
      this._navigationModel = new NavigationModel([]);
    } else {
      this._navigationModel = null;
    }
    this._processConfig(config);
  }
  /** @internal */
  _handleNavigationStart() {
    this.config._handleNavigationStart();
    for (const childRoute of this.childRoutes) {
      if (childRoute instanceof Promise)
        continue;
      childRoute._handleNavigationStart();
    }
  }
  /** @internal */
  _processConfig(config) {
    const allPromises = [];
    const childrenRoutes = config.routes ?? noRoutes;
    const len = childrenRoutes.length;
    if (len === 0) {
      const getRouteConfig = config.component.prototype?.getRouteConfig;
      this._childRoutesConfigured = getRouteConfig == null ? true : typeof getRouteConfig !== "function";
      return;
    }
    const navModel = this._navigationModel;
    const hasNavModel = navModel !== null;
    let i = 0;
    for (; i < len; i++) {
      const childRoute = childrenRoutes[i];
      if (childRoute instanceof Promise) {
        allPromises.push(this._addRoute(childRoute));
        continue;
      }
      const rdResolution = resolveRouteConfiguration(childRoute, true, config, null, this);
      if (rdResolution instanceof Promise) {
        if (!isPartialChildRouteConfig(childRoute) || childRoute.path == null)
          throw new Error(getMessage(
            3173
            /* Events.rcNoPathLazyImport */
          ));
        for (const path of ensureArrayOfStrings(childRoute.path)) {
          this._$addRoute(path, childRoute.caseSensitive ?? false, rdResolution);
        }
        const idx = this.childRoutes.length;
        const p = rdResolution.then((rdConfig) => {
          return this.childRoutes[idx] = rdConfig;
        });
        this.childRoutes.push(p);
        if (hasNavModel) {
          navModel._addRoute(p);
        }
        allPromises.push(p.then(noop));
        continue;
      }
      for (const path of rdResolution.path ?? emptyArray) {
        this._$addRoute(path, rdResolution.caseSensitive, rdResolution);
      }
      this.childRoutes.push(rdResolution);
      if (hasNavModel) {
        navModel._addRoute(rdResolution);
      }
    }
    this._childRoutesConfigured = true;
    if (allPromises.length > 0) {
      this._allResolved = Promise.all(allPromises).then(() => {
        this._allResolved = null;
      });
    }
  }
  _addRoute(routeable) {
    trace(this._logger, 3165, routeable);
    return onResolve(resolveRouteConfiguration(routeable, true, this.config, null, this), (rdConfig) => {
      for (const path of rdConfig.path ?? emptyArray) {
        this._$addRoute(path, rdConfig.caseSensitive, rdConfig);
      }
      this._navigationModel?._addRoute(rdConfig);
      this.childRoutes.push(rdConfig);
    });
  }
  /** @internal */
  _$addRoute(path, caseSensitive, handler) {
    this._recognizer.add({
      path,
      caseSensitive,
      handler
    }, true);
  }
  /** @internal */
  _resolveLazy(promise) {
    return this._moduleLoader.load(promise, (m3) => {
      const raw = m3.raw;
      if (typeof raw === "function") {
        const def2 = CustomElement.isType(raw) ? CustomElement.getDefinition(raw) : null;
        if (def2 != null)
          return def2;
      }
      let defaultExport = void 0;
      let firstNonDefaultExport = void 0;
      for (const item of m3.items) {
        const def2 = CustomElement.isType(item.value) ? item.definition : null;
        if (def2 != null) {
          if (item.key === "default") {
            defaultExport = def2;
          } else if (firstNonDefaultExport === void 0) {
            firstNonDefaultExport = def2;
          }
        }
      }
      if (defaultExport === void 0 && firstNonDefaultExport === void 0) {
        if (!isPartialCustomElementDefinition(raw))
          throw new Error(getMessage(3175, promise));
        const definition = CustomElementDefinition.create(raw);
        CustomElement.define(definition);
        return definition;
      }
      return firstNonDefaultExport ?? defaultExport;
    });
  }
  _generateViewportInstruction(instruction, traverseChildren) {
    if (!isEagerInstruction(instruction))
      return null;
    traverseChildren ??= false;
    const component = instruction.component;
    let paths;
    let throwError = false;
    if (component instanceof RouteConfig) {
      paths = component.path;
      throwError = true;
    } else if (typeof component === "string") {
      const $rdConfig = this.childRoutes.find((x) => x.id === component);
      if ($rdConfig === void 0)
        return null;
      paths = $rdConfig.path;
    } else if (component.type === 0) {
      const $rdConfig = this.childRoutes.find((x) => x.id === component.value);
      if ($rdConfig === void 0)
        return null;
      paths = $rdConfig.path;
    } else {
      const ced = resolveCustomElementDefinition(component, this)[1];
      paths = this.childRoutes.reduce((acc, x) => {
        if (x.component === ced.Type) {
          acc.push(...x.path);
        }
        return acc;
      }, []);
      throwError = true;
    }
    if (paths === void 0)
      return null;
    const params = instruction.params;
    const recognizer = this._recognizer;
    const numPaths = paths.length;
    const errors = [];
    let result = null;
    if (numPaths === 1) {
      const result2 = core(paths[0]);
      if (result2 === null) {
        if (throwError)
          throw new Error(getMessage(3166, instruction, errors));
        debug(this._logger, 3166, instruction, errors);
        return null;
      }
      return createPathGenerationResult.call(this, result2);
    }
    let maxScore = 0;
    for (let i = 0; i < numPaths; i++) {
      const res = core(paths[i]);
      if (res === null)
        continue;
      if (result === null) {
        result = res;
        maxScore = Object.keys(res.consumed).length;
      } else if (Object.keys(res.consumed).length > maxScore) {
        result = res;
      }
    }
    if (result === null) {
      if (throwError)
        throw new Error(getMessage(3166, instruction, errors));
      debug(this._logger, 3166, instruction, errors);
      return null;
    }
    return createPathGenerationResult.call(this, result);
    function core(path) {
      const endpoint = recognizer.getEndpoint(path);
      if (endpoint === null) {
        errors.push(`No endpoint found for the path: '${path}'.`);
        return null;
      }
      const consumed = /* @__PURE__ */ Object.create(null);
      for (const param of endpoint.params) {
        const key = param.name;
        let value = params[key];
        if (value == null || String(value).length === 0) {
          if (!param.isOptional) {
            errors.push(`No value for the required parameter '${key}' is provided for the path: '${path}'.`);
            return null;
          }
          value = "";
        } else {
          if (!param.satisfiesPattern(value)) {
            errors.push(`The value '${value}' for the parameter '${key}' does not satisfy the pattern '${param.pattern}'.`);
            return null;
          }
          consumed[key] = value;
        }
        const pattern = param.isStar ? `*${key}` : param.isOptional ? `:${key}?` : `:${key}`;
        path = path.replace(pattern, encodeURIComponent(value));
      }
      const consumedKeys = Object.keys(consumed);
      const query = Object.fromEntries(Object.entries(params).filter(([key]) => !consumedKeys.includes(key)));
      return { path: path.replace(/\/\//g, "/"), endpoint, consumed, query };
    }
    async function generateChildrenInstructions(parentConfig) {
      const children = instruction.children;
      const numChildren = children?.length ?? 0;
      if (numChildren === 0)
        return { instructions: emptyArray, query: emptyObject };
      const parentComponent = parentConfig.component;
      const parentDefn = CustomElement.isType(parentComponent) ? CustomElement.getDefinition(parentComponent) : resolveCustomElementDefinition(parentComponent, this)[1];
      return onResolve(onResolve(this._router.getRouteConfigContext(parentConfig, parentDefn, null, this.container, this.config, this), (x) => onResolve(x.allResolved, () => x)), ($routeConfigContext) => {
        const promises = new Array(numChildren);
        const instructions = new Array(numChildren);
        let query = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < numChildren; ++i) {
          const child = children[i];
          promises[i] = onResolve($routeConfigContext._generateViewportInstruction(isPartialViewportInstruction(child) ? { ...child, params: child.params ?? emptyObject } : { component: child, params: emptyObject }, traverseChildren), (eagerVi) => {
            if (eagerVi == null)
              throw new Error(getMessage(3166, child));
            instructions[i] = eagerVi.vi;
            query = mergeQueryParams(query, eagerVi.query);
          });
        }
        return onResolve(Promise.all(promises), () => ({ instructions, query }));
      });
    }
    function createPathGenerationResult(result2) {
      return onResolve(traverseChildren ? generateChildrenInstructions.call(this, result2.endpoint.route.handler) : { instructions: instruction.children, query: emptyObject }, ({ instructions: children, query: $query }) => {
        return {
          vi: ViewportInstruction.create({
            recognizedRoute: new $RecognizedRoute(new RecognizedRoute(result2.endpoint, result2.consumed), null),
            component: result2.path,
            children,
            viewport: instruction.viewport,
            open: instruction.open,
            close: instruction.close
          }),
          query: mergeQueryParams(result2.query, $query)
        };
      });
    }
  }
  recognize(path, searchAncestor = false) {
    trace(this._logger, 3164, path);
    let _current = this;
    let _continue = true;
    let result = null;
    while (_continue) {
      result = _current._recognizer.recognize(path);
      if (result === null) {
        if (!searchAncestor || _current.isRoot)
          return null;
        _current = _current.parent;
      } else {
        _continue = false;
      }
    }
    return new $RecognizedRoute(result, Reflect.has(result.params, RESIDUE) ? result.params[RESIDUE] ?? null : null);
  }
  dispose() {
    this.container.dispose();
  }
}
class $RecognizedRoute {
  constructor(route2, residue) {
    this.route = route2;
    this.residue = residue;
  }
  toString() {
    const route2 = this.route;
    const cr = route2.endpoint.route;
    return `RR(route:(endpoint:(route:(path:${cr.path},handler:${cr.handler})),params:${JSON.stringify(route2.params)}),residue:${this.residue})`;
  }
}
class NavigationModel {
  constructor(routes) {
    this.routes = routes;
    this._promise = void 0;
  }
  resolve() {
    return onResolve(this._promise, noop);
  }
  /** @internal */
  _setIsActive(router, context) {
    void onResolve(this._promise, () => {
      for (const route2 of this.routes) {
        route2._setIsActive(router, context);
      }
    });
  }
  /** @internal */
  _addRoute(route2) {
    const routes = this.routes;
    if (!(route2 instanceof Promise)) {
      if ((route2.nav ?? false) && route2.redirectTo === null) {
        routes.push(NavigationRoute._create(route2));
      }
      return;
    }
    const index = routes.length;
    routes.push(void 0);
    let promise = void 0;
    promise = this._promise = onResolve(this._promise, () => onResolve(route2, (rdConfig) => {
      if (rdConfig.nav && rdConfig.redirectTo === null) {
        routes[index] = NavigationRoute._create(rdConfig);
      } else {
        routes.splice(index, 1);
      }
      if (this._promise === promise) {
        this._promise = void 0;
      }
    }));
  }
}
class NavigationRoute {
  constructor(id2, path, title, data) {
    this.id = id2;
    this.path = path;
    this.title = title;
    this.data = data;
    this._trees = null;
  }
  /** @internal */
  static _create(rdConfig) {
    return new NavigationRoute(rdConfig.id, ensureArrayOfStrings(rdConfig.path ?? emptyArray), rdConfig.title, rdConfig.data);
  }
  get isActive() {
    return this._isActive;
  }
  /** @internal */
  _setIsActive(router, context) {
    let trees = this._trees;
    if (trees === null) {
      const routerOptions = router.options;
      trees = this._trees = this.path.map((p) => {
        const ep = context.routeConfigContext._recognizer.getEndpoint(p);
        if (ep === null)
          throw new Error(getMessage(3450, p));
        return new ViewportInstructionTree(NavigationOptions.create(routerOptions, { context }), false, [
          ViewportInstruction.create({
            recognizedRoute: new $RecognizedRoute(new RecognizedRoute(ep, emptyObject), null),
            component: p
          })
        ], emptyQuery, null);
      });
    }
    this._isActive = trees.some((vit) => router.routeTree.contains(vit, true));
  }
}
class ViewportCustomElement {
  constructor() {
    this.name = defaultViewportName;
    this.usedBy = "";
    this.default = "";
    this.fallback = "";
    this._agent = void 0;
    this._controller = void 0;
    this._ctx = resolve(IRouteContext);
    this._logger = resolve(ILogger).scopeTo(`au-viewport<${this._ctx.routeConfigContext._friendlyPath}>`);
  }
  /** @internal */
  _getFallback(viewportInstruction, routeNode, context) {
    const fallback = this.fallback;
    return typeof fallback === "function" && !CustomElement.isType(fallback) ? fallback(viewportInstruction, routeNode, context) : fallback;
  }
  hydrated(controller) {
    trace(
      this._logger,
      3e3
      /* Events.vpHydrated */
    );
    this._controller = controller;
    this._agent = this._ctx._registerViewport(this);
  }
  attaching(initiator, _parent) {
    trace(
      this._logger,
      3001
      /* Events.vpAttaching */
    );
    return this._agent._activateFromViewport(initiator, this._controller);
  }
  detaching(initiator, _parent) {
    trace(
      this._logger,
      3002
      /* Events.vpDetaching */
    );
    return this._agent._deactivateFromViewport(initiator, this._controller);
  }
  dispose() {
    trace(
      this._logger,
      3003
      /* Events.vpDispose */
    );
    this._ctx._unregisterViewport(this);
    this._agent._dispose();
    this._agent = void 0;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const propStrings = [];
    for (const prop of props) {
      const value = this[prop];
      switch (typeof value) {
        case "string":
          if (value !== "") {
            propStrings.push(`${prop}:'${value}'`);
          }
          break;
        default: {
          propStrings.push(`${prop}:${String(value)}`);
        }
      }
    }
    return `VP(ctx:'${this._ctx.routeConfigContext._friendlyPath}',${propStrings.join(",")})`;
  }
}
CustomElement.define({
  name: "au-viewport",
  bindables: ["name", "usedBy", "default", "fallback"]
}, ViewportCustomElement);
const props = [
  "name",
  "usedBy",
  "default",
  "fallback"
];
class LoadCustomAttribute {
  constructor() {
    this._el = resolve(INode);
    this._router = resolve(IRouter);
    this._ctx = resolve(IRouteContext);
    this._events = resolve(IRouterEvents);
    this._locationMgr = resolve(ILocationManager);
    this.attribute = "href";
    this.active = false;
    this._href = null;
    this._instructions = null;
    this._navigationEndListener = null;
    this.onClick = (e) => {
      if (this._instructions === null) {
        return;
      }
      if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey || e.button !== 0) {
        return;
      }
      e.preventDefault();
      void this._router.load(this._instructions, { context: this.context });
    };
    const el = this._el;
    this._isEnabled = !el.hasAttribute("external") && !el.hasAttribute("data-external");
    this._activeClass = this._router.options.activeClass;
  }
  binding() {
    if (this._isEnabled) {
      this._el.addEventListener("click", this.onClick);
    }
    this.valueChanged();
    this._navigationEndListener = this._events.subscribe("au:router:navigation-end", (_e2) => {
      const active = this.active = this._instructions !== null && this._router.isActive(this._instructions, this.context);
      const activeClass = this._activeClass;
      if (activeClass === null)
        return;
      this._el.classList.toggle(activeClass, active);
    });
  }
  attaching() {
    const ctx = this.context;
    const promise = ctx.routeConfigContext.allResolved;
    if (promise !== null) {
      return promise.then(() => {
        this.valueChanged();
      });
    }
  }
  unbinding() {
    if (this._isEnabled) {
      this._el.removeEventListener("click", this.onClick);
    }
    this._navigationEndListener.dispose();
  }
  valueChanged() {
    const router = this._router;
    const options = router.options;
    const component = this.route;
    let ctx = this.context;
    if (ctx === void 0) {
      ctx = this.context = this._ctx;
    } else if (ctx === null) {
      ctx = this.context = this._ctx.root;
    }
    if (component != null && ctx.routeConfigContext.allResolved === null) {
      const params = this.params;
      const instructions = this._instructions = router.createViewportInstructions(typeof params === "object" && params !== null ? { component, params } : component, { context: ctx });
      this._href = instructions.toUrl(false, options._urlParser);
    } else {
      this._instructions = null;
      this._href = null;
    }
    const controller = CustomElement.for(this._el, { optional: true });
    if (controller !== null) {
      controller.viewModel[this.attribute] = this._instructions;
    } else {
      if (this._href === null) {
        this._el.removeAttribute(this.attribute);
      } else {
        const value = options.useUrlFragmentHash ? this._href : this._locationMgr.addBaseHref(this._href);
        this._el.setAttribute(this.attribute, value);
      }
    }
  }
}
CustomAttribute.define({
  name: "load",
  bindables: {
    route: { mode: bmToView, primary: true, callback: "valueChanged" },
    params: { mode: bmToView, callback: "valueChanged" },
    attribute: { mode: bmToView },
    active: { mode: bmFromView },
    context: { mode: bmToView, callback: "valueChanged" }
  }
}, LoadCustomAttribute);
class HrefCustomAttribute {
  /** @internal */
  get _isExternal() {
    return this._el.hasAttribute("external") || this._el.hasAttribute("data-external");
  }
  constructor() {
    this._el = resolve(INode);
    this._router = resolve(IRouter);
    this._ctx = resolve(IRouteContext);
    this._isInitialized = false;
    if (this._router.options.useHref && // Ensure the element is an anchor
    this._el.nodeName === "A") {
      const windowName = resolve(IWindow).name;
      switch (this._el.getAttribute("target")) {
        case null:
        case windowName:
        case "_self":
          this._isEnabled = true;
          break;
        default:
          this._isEnabled = false;
          break;
      }
    } else {
      this._isEnabled = false;
    }
  }
  binding() {
    if (!this._isInitialized) {
      this._isInitialized = true;
      this._isEnabled = this._isEnabled && refs.get(this._el, CustomAttribute.getDefinition(LoadCustomAttribute).key) === null;
    }
    this.valueChanged(this.value);
    this._el.addEventListener("click", this);
  }
  unbinding() {
    this._el.removeEventListener("click", this);
  }
  valueChanged(newValue) {
    if (newValue == null) {
      this._el.removeAttribute("href");
    } else {
      if (this._router.options.useUrlFragmentHash && this._ctx.routeConfigContext.isRoot && !/^[.#]/.test(newValue) && !this._isExternal) {
        newValue = `#${newValue}`;
      }
      this._el.setAttribute("href", newValue);
    }
  }
  handleEvent(e) {
    this._onClick(e);
  }
  /** @internal */
  _onClick(e) {
    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey || e.button !== 0 || this._isExternal || !this._isEnabled) {
      return;
    }
    const href = this._el.getAttribute("href");
    if (href !== null) {
      e.preventDefault();
      void this._router.load(href, { context: this._ctx });
    }
  }
}
HrefCustomAttribute.$au = {
  type: "custom-attribute",
  name: "href",
  noMultiBindings: true,
  bindables: {
    value: { mode: bmToView }
  }
};
const RouterRegistration = IRouter;
const DefaultComponents = [
  RouterRegistration
];
const DefaultResources = [
  ViewportCustomElement,
  LoadCustomAttribute,
  HrefCustomAttribute
];
function configure(container, options) {
  let basePath = null;
  if (isObjectOrFunction(options)) {
    basePath = options.basePath ?? null;
  } else {
    options = {};
  }
  const routerOptions = RouterOptions.create(options);
  return container.register(Registration.cachedCallback(IBaseHref, (handler, _, __) => {
    const window2 = handler.get(IWindow);
    const url = new URL(window2.document.baseURI);
    url.pathname = normalizePath(basePath ?? url.pathname);
    return url;
  }), Registration.instance(IRouterOptions, routerOptions), Registration.instance(RouterOptions, routerOptions), AppTask.creating(IRouter, (_) => {
  }), AppTask.hydrated(IContainer, RouteContext.setRoot), AppTask.activated(IRouter, (router) => router.start(true)), AppTask.deactivated(IRouter, (router) => router.stop()), ...DefaultComponents, ...DefaultResources);
}
const RouterConfiguration = {
  register(container) {
    return configure(container);
  },
  /**
   * Make it possible to specify options to Router activation.
   * Parameter is either a config object that's passed to Router's activate
   * or a config function that's called instead of Router's activate.
   */
  customize(options) {
    return {
      register(container) {
        return configure(container, options);
      }
    };
  }
};
const name$1 = "search-area";
const template$1 = '<div class="static top-16 z-10 m-auto bg-black border-b border-gray-600 lg:sticky">\n    <au-slot></au-slot>\n</div>';
const dependencies$1 = [];
const bindables$1 = {};
let _e$1;
function register$1(container) {
  if (!_e$1) {
    _e$1 = CustomElement.define({ name: name$1, template: template$1, dependencies: dependencies$1, bindables: bindables$1 });
  }
  container.register(_e$1);
}
const __au2ViewDef$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindables: bindables$1,
  default: template$1,
  dependencies: dependencies$1,
  name: name$1,
  register: register$1,
  template: template$1
}, Symbol.toStringTag, { value: "Module" }));
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __knownSymbol$2 = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError$2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
var __decoratorStart$2 = (base) => [, , , __create$2(null)];
var __decoratorStrings$2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$2 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError$2("Function expected") : fn2;
var __decoratorContext$2 = (kind, name2, done, metadata, fns) => ({ kind: __decoratorStrings$2[kind], name: name2, metadata, addInitializer: (fn2) => done._ ? __typeError$2("Already initialized") : fns.push(__expectFn$2(fn2 || null)) });
var __decoratorMetadata$2 = (array, target) => __defNormalProp$2(target, __knownSymbol$2("metadata"), array[3]);
var __runInitializers$2 = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self);
  return value;
};
var __decorateElement$2 = (array, flags, name2, decorators, target, extra) => {
  var it, done, ctx, k = flags & 7, p = false;
  var j = 0;
  var extraInitializers = array[j] || (array[j] = []);
  var desc = k && (target = target.prototype, k < 5 && (k > 3 || !p) && __getOwnPropDesc$2(target, name2));
  __name$2(target, name2);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$2(k, name2, done = {}, array[3], extraInitializers);
    it = (0, decorators[i])(target, ctx), done._ = 1;
    __expectFn$2(it) && (target = it);
  }
  return __decoratorMetadata$2(array, target), desc && __defProp$2(target, name2, desc), p ? k ^ 4 ? extra : desc : target;
};
var _SearchArea_decorators, _init$2;
_SearchArea_decorators = [customElement(__au2ViewDef$1)];
class SearchArea {
}
_init$2 = __decoratorStart$2();
SearchArea = __decorateElement$2(_init$2, 0, "SearchArea", _SearchArea_decorators, SearchArea);
__runInitializers$2(_init$2, 1, SearchArea);
const Elements = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get SearchArea() {
    return SearchArea;
  }
}, Symbol.toStringTag, { value: "Module" }));
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __knownSymbol$1 = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError$1 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
var __decoratorStart$1 = (base) => [, , , __create$1(null)];
var __decoratorStrings$1 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$1 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError$1("Function expected") : fn2;
var __decoratorContext$1 = (kind, name2, done, metadata, fns) => ({ kind: __decoratorStrings$1[kind], name: name2, metadata, addInitializer: (fn2) => done._ ? __typeError$1("Already initialized") : fns.push(__expectFn$1(fn2 || null)) });
var __decoratorMetadata$1 = (array, target) => __defNormalProp$1(target, __knownSymbol$1("metadata"), array[3]);
var __runInitializers$1 = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self);
  return value;
};
var __decorateElement$1 = (array, flags, name2, decorators, target, extra) => {
  var it, done, ctx, k = flags & 7, p = false;
  var j = 0;
  var extraInitializers = array[j] || (array[j] = []);
  var desc = k && (target = target.prototype, k < 5 && (k > 3 || !p) && __getOwnPropDesc$1(target, name2));
  __name$1(target, name2);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$1(k, name2, done = {}, array[3], extraInitializers);
    it = (0, decorators[i])(target, ctx), done._ = 1;
    __expectFn$1(it) && (target = it);
  }
  return __decoratorMetadata$1(array, target), desc && __defProp$1(target, name2, desc), p ? k ^ 4 ? extra : desc : target;
};
var _RuneNameValueConverter_decorators, _init$1;
_RuneNameValueConverter_decorators = [valueConverter("runeName")];
class RuneNameValueConverter {
  toView(value) {
    if (!value) {
      return;
    }
    switch (value) {
      case "El Rune":
        return "El (1)";
      case "Eld Rune":
        return "Eld (2)";
      case "Tir Rune":
        return "Tir (3)";
      case "Nef Rune":
        return "Nef (4)";
      case "Eth Rune":
        return "Eth (5)";
      case "Ith Rune":
        return "Ith (6)";
      case "Tal Rune":
        return "Tal (7)";
      case "Ral Rune":
        return "Ral (8)";
      case "Ort Rune":
        return "Ort (9)";
      case "Thul Rune":
        return "Thul (10)";
      case "Amn Rune":
        return "Amn (11)";
      case "Sol Rune":
        return "Sol (12)";
      case "Shael Rune":
        return "Shael (13)";
      case "Dol Rune":
        return "Dol (14)";
      case "Hel Rune":
        return "Hel (15)";
      case "Io Rune":
        return "Io (16)";
      case "Lum Rune":
        return "Lum (17)";
      case "Ko Rune":
        return "Ko (18)";
      case "Fal Rune":
        return "Fal (19)";
      case "Lem Rune":
        return "Lem (20)";
      case "Pul Rune":
        return "Pul (21)";
      case "Um Rune":
        return "Um (22)";
      case "Mal Rune":
        return "Mal (23)";
      case "Ist Rune":
        return "Ist (24)";
      case "Gul Rune":
        return "Gul (25)";
      case "Vex Rune":
        return "Vex (26)";
      case "Ohm Rune":
        return "Ohm (27)";
      case "Lo Rune":
        return "Lo (28)";
      case "Sur Rune":
        return "Sur (29)";
      case "Ber Rune":
        return "Ber (30)";
      case "Jah Rune":
        return "Jah (31)";
      case "Cham Rune":
        return "Cham (32)";
      case "Zod Rune":
        return "Zod (33)";
    }
    return value;
  }
}
_init$1 = __decoratorStart$1();
RuneNameValueConverter = __decorateElement$1(_init$1, 0, "RuneNameValueConverter", _RuneNameValueConverter_decorators, RuneNameValueConverter);
__runInitializers$1(_init$1, 1, RuneNameValueConverter);
const Resources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get RuneNameValueConverter() {
    return RuneNameValueConverter;
  }
}, Symbol.toStringTag, { value: "Module" }));
function isBlankOrInvalid(v) {
  if (v === void 0 || v === null) return true;
  let s;
  if (typeof v === "string") s = v;
  else if (typeof v === "number" || typeof v === "boolean") s = String(v);
  else return true;
  s = s.trim();
  if (s.length === 0) return true;
  const lower = s.toLowerCase();
  return lower === "undefined" || lower === "null";
}
function stripBadParams(params) {
  let changed = false;
  const toDelete = [];
  params.forEach((value, key) => {
    if (isBlankOrInvalid(value)) {
      toDelete.push(key);
    }
  });
  if (toDelete.length) {
    for (const k of toDelete) params.delete(k);
    changed = true;
  }
  return changed;
}
function cleanCurrentUrl() {
  try {
    const url = new URL(window.location.href);
    const changed = stripBadParams(url.searchParams);
    if (changed) {
      window.history.replaceState({}, "", url.toString());
    }
  } catch {
  }
}
function syncParamsToUrl(params, push = true) {
  try {
    const url = new URL(window.location.href);
    const newParams = new URLSearchParams();
    for (const [key, val] of Object.entries(params)) {
      if (!isBlankOrInvalid(val)) {
        newParams.set(key, String(val));
      }
    }
    url.search = newParams.toString();
    if (push) {
      window.history.pushState({}, "", url.toString());
    } else {
      window.history.replaceState({}, "", url.toString());
    }
  } catch {
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/d2rr-testsite/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = allSettled(deps.map((dep) => {
      dep = assetsURL(dep);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$1 = new Event("vite:preloadError", { cancelable: true });
    e$1.payload = err$2;
    window.dispatchEvent(e$1);
    if (!e$1.defaultPrevented) throw err$2;
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const name = "app";
const template = `<nav class="bg-gray-800 fixed w-full z-20 top-0 left-0 shadow-xl border-b border-gray-600 h-16">
    <div class="w-full h-16 px-4 flex flex-nowrap items-center justify-between mx-auto">

        <a href="./" class="text-xl link-text truncate">
            D2R Reimagined
        </a>

        <div class="flex lg:order-2">
            <!-- Font selection dropdown -->
            <div class="flex items-center relative font-menu px-4">
                <button type="button"
                        class="text-2xl link-text inline-flex items-center cursor-pointer select-none"
                        data-help-text="Select a font for viewing the site."
                        data-tooltip-placement="bottom"
                        aria-label="Choose font"
                        aria-haspopup="true"
                        aria-expanded.bind="fontMenuOpen.toString()"
                        click.trigger="toggleFontMenu()"
                        keydown.trigger="event.key === 'Escape' && closeFontMenu()">
                    <span class="sr-only">Select Font</span>
                    <span class="mso">type_specimen</span>
                </button>
                <!-- Dropdown panel -->
                <div if.bind="fontMenuOpen"
                     class="fixed right-5 top-15.75 min-w-70 z-30 bg-gray-800 border border-gray-600 rounded-b-lg shadow-md overflow-hidden"
                     role="menu"
                     keydown.trigger="event.key === 'Escape' && closeFontMenu()">
                    <ul class="py-1">
                        <li repeat.for="font of fonts">
                            <button type="button"
                                    class="w-full text-left p-4 text-lg link-text flex items-center justify-between"
                                    role="menuitem"
                                    title.bind="'Preview ' + font.name"
                                    click.trigger="selectFont(font, $event)">
                                <span class.bind="font.class">\${font.name}</span>
                                <span if.bind="font.class === selectedFontClass"
                                      class="mso ml-2">check</span>
                            </button>
                        </li>
                    </ul>
                </div>
            </div>

            <button type="button"
                    class="flex items-center px-2 text-2xl link-text lg:hidden"
                    aria-controls="navbar-sticky" aria-expanded="false"
                    click.trigger="toggleMobileMenu($event.currentTarget)">
                <span class="sr-only">Open main menu</span>
                <span class="mso">menu</span>
            </button>

            <a href="https://discord.gg/9zZkYrSA8C" target="_blank"
               class="hidden items-center lg:flex text-purple-500 hover:text-purple-400">
                <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor"
                     viewBox="0 0 24 24">
                    <path d="M18.942 5.556a16.3 16.3 0 0 0-4.126-1.3 12.04 12.04 0 0 0-.529 1.1 15.175 15.175 0 0 0-4.573 0 11.586 11.586 0 0 0-.535-1.1 16.274 16.274 0 0 0-4.129 1.3 17.392 17.392 0 0 0-2.868 11.662 15.785 15.785 0 0 0 4.963 2.521c.41-.564.773-1.16 1.084-1.785a10.638 10.638 0 0 1-1.706-.83c.143-.106.283-.217.418-.331a11.664 11.664 0 0 0 10.118 0c.137.114.277.225.418.331-.544.328-1.116.606-1.71.832a12.58 12.58 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595 17.286 17.286 0 0 0-2.973-11.59ZM8.678 14.813a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.918 1.918 0 0 1 1.8 2.047 1.929 1.929 0 0 1-1.8 2.045Zm6.644 0a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.919 1.919 0 0 1 1.8 2.047 1.93 1.93 0 0 1-1.8 2.045Z"/>
                </svg>
            </a>
        </div>

        <div class="w-auto hidden fixed right-5 top-15.75 items-center justify-between lg:static lg:flex lg:w-auto lg:ms-0 lg:order-1"
             id="navbar-sticky">
            <ul class="flex flex-col gap-4 p-4 border border-gray-600 bg-gray-800 rounded-b-lg lg:flex-row lg:gap-6 lg:p-0 lg:border-0 lg:bg-transparent">
                <li>
                    <a href="./bases" class="block text-lg link-text" aria-current="page"
                       click.trigger="closeMobileMenu()">Bases</a>
                </li>
                <li>
                    <a href="./affixes" class="block text-lg link-text" aria-current="page"
                       click.trigger="closeMobileMenu()">Affixes</a>
                </li>
                <li>
                    <a href="./uniques" class="block text-lg link-text" aria-current="page"
                       click.trigger="closeMobileMenu()">Uniques</a>
                </li>
                <li>
                    <a href="./sets" class="block text-lg link-text" aria-current="page"
                       click.trigger="closeMobileMenu()">Sets</a>
                </li>
                <li>
                    <a href="./runewords" class="block text-lg link-text" aria-current="page"
                       click.trigger="closeMobileMenu()">Runewords</a>
                </li>
                <li>
                    <a href="./grail" class="block text-lg link-text" aria-current="page"
                       click.trigger="closeMobileMenu()">Grail</a>
                </li>
                <li>
                    <a href="./cube-recipes" class="block text-lg link-text truncate" aria-current="page"
                       click.trigger="closeMobileMenu()">Cube Recipes</a>
                </li>
                <li>
                    <a href="https://wiki.d2r-reimagined.com/" target="_blank"
                       class="flex text-lg link-text items-center" aria-current="page"
                       click.trigger="closeMobileMenu()">Wiki<span class="mso ml-1">open_in_new</span>
                    </a>
                </li>
            </ul>
        </div>

    </div>
</nav>

<!-- Nav Bar Spacer -->
<div class="h-16"></div>

<div class="w-full pb-12">
    <au-viewport default="Home"></au-viewport>
</div>

<!-- Floating Top Button visible after about 2 screens of height -->
<button type="button"
        class="min-w-10 min-h-10 m-auto flex items-center justify-center text-2xl type-text
        fixed bottom-2 right-2 z-50 ring-0 ring-offset-0 rounded-full shadow-md
         bg-gray-800 border border-gray-600 hover:bg-gray-700 hover:border-gray-400"
        aria-label="Back to top" click.trigger="scrollToTop()" if.bind="showBackToTop">
    <span class="mso" aria-hidden="true">arrow_upward</span>
    <span class="sr-only">Top</span>
</button>
`;
const dependencies = [];
const bindables = {};
let _e;
function register(container) {
  if (!_e) {
    _e = CustomElement.define({ name, template, dependencies, bindables });
  }
  container.register(_e);
}
const __au2ViewDef = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindables,
  default: template,
  dependencies,
  name,
  register,
  template
}, Symbol.toStringTag, { value: "Module" }));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError("Function expected") : fn2;
var __decoratorContext = (kind, name2, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name: name2, metadata, addInitializer: (fn2) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn2 || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self);
  return value;
};
var __decorateElement = (array, flags, name2, decorators, target, extra) => {
  var it, done, ctx, k = flags & 7, p = false;
  var j = 0;
  var extraInitializers = array[j] || (array[j] = []);
  var desc = k && (target = target.prototype, k < 5 && (k > 3 || !p) && __getOwnPropDesc(target, name2));
  __name(target, name2);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name2, done = {}, array[3], extraInitializers);
    it = (0, decorators[i])(target, ctx), done._ = 1;
    __expectFn(it) && (target = it);
  }
  return __decoratorMetadata(array, target), desc && __defProp(target, name2, desc), p ? k ^ 4 ? extra : desc : target;
};
var _App_decorators, _init;
_App_decorators = [customElement(__au2ViewDef), route({
  title: "D2R Reimagined",
  routes: [
    {
      path: "",
      component: __vitePreload(() => import("./home-Dn_85C5n.js"), true ? [] : void 0),
      title: "Home"
    },
    {
      path: "cube-recipes",
      component: __vitePreload(() => import("./cube-recipes-2S7hyrHr.js"), true ? __vite__mapDeps([0,1,2]) : void 0),
      title: "Cube Recipes"
    },
    {
      path: "uniques",
      component: __vitePreload(() => import("./uniques-BEcVqnBA.js"), true ? __vite__mapDeps([3,4,5,6,1,2,7]) : void 0),
      title: "Uniques"
    },
    {
      path: "sets",
      component: __vitePreload(() => import("./sets-DKIF3Nkp.js"), true ? __vite__mapDeps([8,4,5,6,1,2,9]) : void 0),
      title: "Sets"
    },
    {
      path: "runewords",
      component: __vitePreload(() => import("./runewords-WhMd1zXd.js"), true ? __vite__mapDeps([10,4,1,2,11]) : void 0),
      title: "Runewords"
    },
    {
      path: "grail",
      component: __vitePreload(() => import("./grail-DDDBTxvt.js"), true ? __vite__mapDeps([12,4,5,6,1,2,11,9,7]) : void 0),
      title: "Holy Grail"
    },
    {
      path: "bases",
      component: __vitePreload(() => import("./bases-BbXlLkHV.js"), true ? __vite__mapDeps([13,4,6,2]) : void 0),
      title: "Bases"
    },
    {
      path: "affixes",
      component: __vitePreload(() => import("./affixes-DIWt--ce.js"), true ? __vite__mapDeps([14,4,1,2]) : void 0),
      title: "Affixes"
    }
  ]
})];
class App {
  fonts = [
    { class: "font-classic", name: "Classic" },
    { class: "font-resurrected", name: "Resurrected" },
    { class: "font-neutral", name: "Neutral" }
  ];
  // UI state for back-to-top visibility
  showBackToTop = false;
  // UI state for font dropdown visibility
  fontMenuOpen = false;
  // Selected font (class) reflected to bindings for labels/tooltips
  selectedFontClass = "font-resurrected";
  // Internals for back-to-top monitoring
  _bt_lastScrollEl;
  _bt_bound = false;
  _bt_ticking = false;
  // Global document click handler to close popovers/menus when clicking outside
  _onDocClick;
  attached() {
    this.loadFont();
    this.bindBackToTopMonitoring();
    this.updateBackToTopVisibility();
    this._onDocClick = (ev) => {
      const target = ev.target;
      if (this.fontMenuOpen) {
        const menuHost = document.querySelector("nav .font-menu");
        const clickInsideMenu = !!(target && menuHost && menuHost.contains(target));
        if (!clickInsideMenu) {
          this.closeFontMenu();
        }
      }
      const panel = document.getElementById("navbar-sticky");
      const toggle = document.querySelector(
        'nav button[aria-controls="navbar-sticky"]'
      );
      if (panel && !panel.classList.contains("hidden")) {
        const clickInsidePanel = !!(target && panel.contains(target));
        const clickOnToggle = !!(target && toggle && toggle.contains(target));
        if (!clickInsidePanel && !clickOnToggle) {
          this.closeMobileMenu();
        }
      }
    };
    document.addEventListener("click", this._onDocClick, true);
  }
  handleFontSelected(font) {
    window.localStorage.setItem("font", font.class);
    this.loadFont();
  }
  detached() {
    if (this._onDocClick) {
      document.removeEventListener("click", this._onDocClick, true);
      this._onDocClick = void 0;
    }
  }
  /**
  * Handles font selection from the dropdown and closes the custom menu.
  */
  selectFont(font) {
    this.handleFontSelected(font);
    this.closeFontMenu();
    this.closeMobileMenu();
  }
  /**
  * Open/close helpers for the font dropdown
  */
  closeFontMenu() {
    this.fontMenuOpen = false;
  }
  toggleFontMenu() {
    this.fontMenuOpen = !this.fontMenuOpen;
  }
  /**
  * Toggle the mobile navigation panel visibility and sync aria-expanded on the button.
  */
  toggleMobileMenu(btn) {
    const panel = document.getElementById("navbar-sticky");
    if (!panel) return;
    panel.classList.toggle("hidden");
    const expanded = !panel.classList.contains("hidden");
    const button = btn instanceof HTMLElement ? btn : document.querySelector('nav button[aria-controls="navbar-sticky"]');
    if (button) {
      button.setAttribute("aria-expanded", expanded.toString());
    }
  }
  /**
  * Closes the mobile navigation panel by adding the 'hidden' class back to the container.
  */
  closeMobileMenu() {
    const panel = document.getElementById("navbar-sticky");
    if (panel && !panel.classList.contains("hidden")) {
      panel.classList.add("hidden");
    }
    const toggle = document.querySelector(
      'nav button[aria-controls="navbar-sticky"]'
    );
    if (toggle) {
      toggle.setAttribute("aria-expanded", "false");
    }
  }
  loadFont() {
    const selectedFont = window.localStorage.getItem("font") || "font-resurrected";
    this.selectedFontClass = selectedFont;
    {
      const allClasses = this.fonts.map((font) => font.class);
      document.body.classList.remove(...allClasses);
      document.body.classList.add(selectedFont);
    }
  }
  /**
  * Find the active scroll container used by the current route. Some pages
  * scroll the window; others place content inside a scrollable container.
  */
  getScrollContainer() {
    const viewportEl = document.querySelector("au-viewport");
    const isScrollable = (el) => {
      if (!el || !(el instanceof HTMLElement)) return false;
      const cs = getComputedStyle(el);
      const oy = cs.overflowY;
      if (oy !== "auto" && oy !== "scroll") return false;
      return el.scrollHeight - 1 > el.clientHeight;
    };
    let node = viewportEl ? viewportEl.parentElement : null;
    while (node && node !== document.body) {
      if (node instanceof HTMLElement && isScrollable(node)) return node;
      node = node.parentElement;
    }
    return document;
  }
  hasNativeSmoothScroll() {
    const style = document.documentElement.style;
    return "scrollBehavior" in style;
  }
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }
  animateWindowToTop(duration = 400) {
    const start2 = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    if (start2 <= 0) return;
    const startTs = performance.now();
    const step = (ts) => {
      const p = Math.min(1, (ts - startTs) / duration);
      const eased = this.easeOutCubic(p);
      const y3 = Math.round(start2 * (1 - eased));
      window.scrollTo(0, y3);
      if (p < 1) requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }
  animateElementToTop(el, duration = 400) {
    const start2 = el.scrollTop || 0;
    if (start2 <= 0) return;
    const startTs = performance.now();
    const step = (ts) => {
      const p = Math.min(1, (ts - startTs) / duration);
      const eased = this.easeOutCubic(p);
      el.scrollTop = Math.round(start2 * (1 - eased));
      if (p < 1) requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }
  /**
  * Scroll back to the top of the page, regardless of which element is the
  * actual scroll root. Uses smooth scrolling when available.
  */
  scrollToTop() {
    const scroller = this.getScrollContainer();
    const reduceMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const duration = reduceMotion ? 0 : 400;
    if (this.hasNativeSmoothScroll() && duration > 0) {
      try {
        window.scrollTo({ top: 0, behavior: "smooth" });
      } catch {
        window.scrollTo(0, 0);
      }
    } else if (duration > 0) {
      this.animateWindowToTop(duration);
    } else {
      window.scrollTo(0, 0);
    }
    if (scroller && scroller instanceof HTMLElement) {
      if (duration > 0) {
        this.animateElementToTop(scroller, duration);
      } else {
        scroller.scrollTop = 0;
      }
    }
    if (duration > 0) {
      window.setTimeout(() => this.updateBackToTopVisibility(), duration + 100);
    } else {
      this.updateBackToTopVisibility();
    }
  }
  // ---- Back-to-top show/hide monitoring ----
  getWindowScrollTop() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  }
  updateBackToTopVisibility() {
    const el = this.getScrollContainer();
    const elTop = el && el instanceof HTMLElement ? el.scrollTop : 0;
    const scrollTop = Math.max(this.getWindowScrollTop(), elTop || 0);
    const viewportH = el && el instanceof HTMLElement ? el.clientHeight : window.innerHeight;
    const threshold = Math.max(viewportH * 2.5, 800);
    this.showBackToTop = scrollTop > threshold;
    this._bt_ticking = false;
  }
  onAnyScroll = () => {
    if (!this._bt_ticking) {
      this._bt_ticking = true;
      requestAnimationFrame(() => this.updateBackToTopVisibility());
    }
  };
  bindBackToTopMonitoring() {
    if (this._bt_bound) return;
    this._bt_bound = true;
    window.addEventListener("scroll", this.onAnyScroll, { passive: true });
    window.addEventListener("resize", this.onAnyScroll);
    const el = this.getScrollContainer();
    if (el && el instanceof HTMLElement) {
      this._bt_lastScrollEl = el;
      el.addEventListener("scroll", this.onAnyScroll, { passive: true });
    }
    const viewportEl = document.querySelector("au-viewport");
    const observeTarget = viewportEl ? viewportEl.parentElement : document.body;
    if (observeTarget) {
      const mo = new MutationObserver(() => {
        const current = this.getScrollContainer();
        const currentEl = current && current instanceof HTMLElement ? current : void 0;
        if (currentEl !== this._bt_lastScrollEl) {
          if (this._bt_lastScrollEl)
            this._bt_lastScrollEl.removeEventListener(
              "scroll",
              this.onAnyScroll
            );
          if (currentEl)
            currentEl.addEventListener("scroll", this.onAnyScroll, {
              passive: true
            });
          this._bt_lastScrollEl = currentEl;
        }
        this.onAnyScroll();
      });
      mo.observe(observeTarget, {
        attributes: true,
        childList: true,
        subtree: true
      });
    }
  }
}
_init = __decoratorStart();
App = __decorateElement(_init, 0, "App", _App_decorators, App);
__runInitializers(_init, 1, App);
var Events = (
  /** @class */
  (function() {
    function Events2(eventType, eventFunctions) {
      if (eventFunctions === void 0) {
        eventFunctions = [];
      }
      this._eventType = eventType;
      this._eventFunctions = eventFunctions;
    }
    Events2.prototype.init = function() {
      var _this = this;
      this._eventFunctions.forEach(function(eventFunction) {
        if (typeof window !== "undefined") {
          window.addEventListener(_this._eventType, eventFunction);
        }
      });
    };
    return Events2;
  })()
);
var Instances = (
  /** @class */
  (function() {
    function Instances2() {
      this._instances = {
        Accordion: {},
        Carousel: {},
        Collapse: {},
        Dial: {},
        Dismiss: {},
        Drawer: {},
        Dropdown: {},
        Modal: {},
        Popover: {},
        Tabs: {},
        Tooltip: {},
        InputCounter: {},
        CopyClipboard: {},
        Datepicker: {}
      };
    }
    Instances2.prototype.addInstance = function(component, instance, id2, override) {
      if (override === void 0) {
        override = false;
      }
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      if (this._instances[component][id2] && !override) {
        console.warn("Flowbite: Instance with ID ".concat(id2, " already exists."));
        return;
      }
      if (override && this._instances[component][id2]) {
        this._instances[component][id2].destroyAndRemoveInstance();
      }
      this._instances[component][id2 ? id2 : this._generateRandomId()] = instance;
    };
    Instances2.prototype.getAllInstances = function() {
      return this._instances;
    };
    Instances2.prototype.getInstances = function(component) {
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      return this._instances[component];
    };
    Instances2.prototype.getInstance = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      if (!this._instances[component][id2]) {
        console.warn("Flowbite: Instance with ID ".concat(id2, " does not exist."));
        return;
      }
      return this._instances[component][id2];
    };
    Instances2.prototype.destroyAndRemoveInstance = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      this.destroyInstanceObject(component, id2);
      this.removeInstance(component, id2);
    };
    Instances2.prototype.removeInstance = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      delete this._instances[component][id2];
    };
    Instances2.prototype.destroyInstanceObject = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      this._instances[component][id2].destroy();
    };
    Instances2.prototype.instanceExists = function(component, id2) {
      if (!this._instances[component]) {
        return false;
      }
      if (!this._instances[component][id2]) {
        return false;
      }
      return true;
    };
    Instances2.prototype._generateRandomId = function() {
      return Math.random().toString(36).substr(2, 9);
    };
    Instances2.prototype._componentAndInstanceCheck = function(component, id2) {
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      if (!this._instances[component][id2]) {
        console.warn("Flowbite: Instance with ID ".concat(id2, " does not exist."));
        return false;
      }
      return true;
    };
    return Instances2;
  })()
);
var instances = new Instances();
if (typeof window !== "undefined") {
  window.FlowbiteInstances = instances;
}
var __assign$d = function() {
  __assign$d = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$d.apply(this, arguments);
};
var Default$d = {
  alwaysOpen: false,
  activeClasses: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white",
  inactiveClasses: "text-gray-500 dark:text-gray-400",
  onOpen: function() {
  },
  onClose: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$d = {
  id: null,
  override: true
};
var Accordion = (
  /** @class */
  (function() {
    function Accordion2(accordionEl, items, options, instanceOptions) {
      if (accordionEl === void 0) {
        accordionEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$d;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$d;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : accordionEl.id;
      this._accordionEl = accordionEl;
      this._items = items;
      this._options = __assign$d(__assign$d({}, Default$d), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Accordion", this, this._instanceId, instanceOptions.override);
    }
    Accordion2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        this._items.forEach(function(item) {
          if (item.active) {
            _this.open(item.id);
          }
          var clickHandler = function() {
            _this.toggle(item.id);
          };
          item.triggerEl.addEventListener("click", clickHandler);
          item.clickHandler = clickHandler;
        });
        this._initialized = true;
      }
    };
    Accordion2.prototype.destroy = function() {
      if (this._items.length && this._initialized) {
        this._items.forEach(function(item) {
          item.triggerEl.removeEventListener("click", item.clickHandler);
          delete item.clickHandler;
        });
        this._initialized = false;
      }
    };
    Accordion2.prototype.removeInstance = function() {
      instances.removeInstance("Accordion", this._instanceId);
    };
    Accordion2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Accordion2.prototype.getItem = function(id2) {
      return this._items.filter(function(item) {
        return item.id === id2;
      })[0];
    };
    Accordion2.prototype.open = function(id2) {
      var _a2, _b2;
      var _this = this;
      var item = this.getItem(id2);
      if (!this._options.alwaysOpen) {
        this._items.map(function(i) {
          var _a3, _b3;
          if (i !== item) {
            (_a3 = i.triggerEl.classList).remove.apply(_a3, _this._options.activeClasses.split(" "));
            (_b3 = i.triggerEl.classList).add.apply(_b3, _this._options.inactiveClasses.split(" "));
            i.targetEl.classList.add("hidden");
            i.triggerEl.setAttribute("aria-expanded", "false");
            i.active = false;
            if (i.iconEl) {
              i.iconEl.classList.add("rotate-180");
            }
          }
        });
      }
      (_a2 = item.triggerEl.classList).add.apply(_a2, this._options.activeClasses.split(" "));
      (_b2 = item.triggerEl.classList).remove.apply(_b2, this._options.inactiveClasses.split(" "));
      item.triggerEl.setAttribute("aria-expanded", "true");
      item.targetEl.classList.remove("hidden");
      item.active = true;
      if (item.iconEl) {
        item.iconEl.classList.remove("rotate-180");
      }
      this._options.onOpen(this, item);
    };
    Accordion2.prototype.toggle = function(id2) {
      var item = this.getItem(id2);
      if (item.active) {
        this.close(id2);
      } else {
        this.open(id2);
      }
      this._options.onToggle(this, item);
    };
    Accordion2.prototype.close = function(id2) {
      var _a2, _b2;
      var item = this.getItem(id2);
      (_a2 = item.triggerEl.classList).remove.apply(_a2, this._options.activeClasses.split(" "));
      (_b2 = item.triggerEl.classList).add.apply(_b2, this._options.inactiveClasses.split(" "));
      item.targetEl.classList.add("hidden");
      item.triggerEl.setAttribute("aria-expanded", "false");
      item.active = false;
      if (item.iconEl) {
        item.iconEl.classList.add("rotate-180");
      }
      this._options.onClose(this, item);
    };
    Accordion2.prototype.updateOnOpen = function(callback) {
      this._options.onOpen = callback;
    };
    Accordion2.prototype.updateOnClose = function(callback) {
      this._options.onClose = callback;
    };
    Accordion2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Accordion2;
  })()
);
function initAccordions() {
  document.querySelectorAll("[data-accordion]").forEach(function($accordionEl) {
    var alwaysOpen = $accordionEl.getAttribute("data-accordion");
    var activeClasses = $accordionEl.getAttribute("data-active-classes");
    var inactiveClasses = $accordionEl.getAttribute("data-inactive-classes");
    var items = [];
    $accordionEl.querySelectorAll("[data-accordion-target]").forEach(function($triggerEl) {
      if ($triggerEl.closest("[data-accordion]") === $accordionEl) {
        var item = {
          id: $triggerEl.getAttribute("data-accordion-target"),
          triggerEl: $triggerEl,
          targetEl: document.querySelector($triggerEl.getAttribute("data-accordion-target")),
          iconEl: $triggerEl.querySelector("[data-accordion-icon]"),
          active: $triggerEl.getAttribute("aria-expanded") === "true" ? true : false
        };
        items.push(item);
      }
    });
    new Accordion($accordionEl, items, {
      alwaysOpen: alwaysOpen === "open" ? true : false,
      activeClasses: activeClasses ? activeClasses : Default$d.activeClasses,
      inactiveClasses: inactiveClasses ? inactiveClasses : Default$d.inactiveClasses
    });
  });
}
if (typeof window !== "undefined") {
  window.Accordion = Accordion;
  window.initAccordions = initAccordions;
}
var __assign$c = function() {
  __assign$c = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$c.apply(this, arguments);
};
var Default$c = {
  onCollapse: function() {
  },
  onExpand: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$c = {
  id: null,
  override: true
};
var Collapse = (
  /** @class */
  (function() {
    function Collapse2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$c;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$c;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$c(__assign$c({}, Default$c), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Collapse", this, this._instanceId, instanceOptions.override);
    }
    Collapse2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        if (this._triggerEl.hasAttribute("aria-expanded")) {
          this._visible = this._triggerEl.getAttribute("aria-expanded") === "true";
        } else {
          this._visible = !this._targetEl.classList.contains("hidden");
        }
        this._clickHandler = function() {
          _this.toggle();
        };
        this._triggerEl.addEventListener("click", this._clickHandler);
        this._initialized = true;
      }
    };
    Collapse2.prototype.destroy = function() {
      if (this._triggerEl && this._initialized) {
        this._triggerEl.removeEventListener("click", this._clickHandler);
        this._initialized = false;
      }
    };
    Collapse2.prototype.removeInstance = function() {
      instances.removeInstance("Collapse", this._instanceId);
    };
    Collapse2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Collapse2.prototype.collapse = function() {
      this._targetEl.classList.add("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "false");
      }
      this._visible = false;
      this._options.onCollapse(this);
    };
    Collapse2.prototype.expand = function() {
      this._targetEl.classList.remove("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "true");
      }
      this._visible = true;
      this._options.onExpand(this);
    };
    Collapse2.prototype.toggle = function() {
      if (this._visible) {
        this.collapse();
      } else {
        this.expand();
      }
      this._options.onToggle(this);
    };
    Collapse2.prototype.updateOnCollapse = function(callback) {
      this._options.onCollapse = callback;
    };
    Collapse2.prototype.updateOnExpand = function(callback) {
      this._options.onExpand = callback;
    };
    Collapse2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Collapse2;
  })()
);
function initCollapses() {
  document.querySelectorAll("[data-collapse-toggle]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-collapse-toggle");
    var $targetEl = document.getElementById(targetId);
    if ($targetEl) {
      if (!instances.instanceExists("Collapse", $targetEl.getAttribute("id"))) {
        new Collapse($targetEl, $triggerEl);
      } else {
        new Collapse($targetEl, $triggerEl, {}, {
          id: $targetEl.getAttribute("id") + "_" + instances._generateRandomId()
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-collapse-toggle attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Collapse = Collapse;
  window.initCollapses = initCollapses;
}
var __assign$b = function() {
  __assign$b = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$b.apply(this, arguments);
};
var Default$b = {
  defaultPosition: 0,
  indicators: {
    items: [],
    activeClasses: "bg-white dark:bg-gray-800",
    inactiveClasses: "bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800"
  },
  interval: 3e3,
  onNext: function() {
  },
  onPrev: function() {
  },
  onChange: function() {
  }
};
var DefaultInstanceOptions$b = {
  id: null,
  override: true
};
var Carousel = (
  /** @class */
  (function() {
    function Carousel2(carouselEl, items, options, instanceOptions) {
      if (carouselEl === void 0) {
        carouselEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$b;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$b;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : carouselEl.id;
      this._carouselEl = carouselEl;
      this._items = items;
      this._options = __assign$b(__assign$b(__assign$b({}, Default$b), options), { indicators: __assign$b(__assign$b({}, Default$b.indicators), options.indicators) });
      this._activeItem = this.getItem(this._options.defaultPosition);
      this._indicators = this._options.indicators.items;
      this._intervalDuration = this._options.interval;
      this._intervalInstance = null;
      this._initialized = false;
      this.init();
      instances.addInstance("Carousel", this, this._instanceId, instanceOptions.override);
    }
    Carousel2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        this._items.map(function(item) {
          item.el.classList.add("absolute", "inset-0", "transition-transform", "transform");
        });
        if (this.getActiveItem()) {
          this.slideTo(this.getActiveItem().position);
        } else {
          this.slideTo(0);
        }
        this._indicators.map(function(indicator, position) {
          indicator.el.addEventListener("click", function() {
            _this.slideTo(position);
          });
        });
        this._initialized = true;
      }
    };
    Carousel2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
      }
    };
    Carousel2.prototype.removeInstance = function() {
      instances.removeInstance("Carousel", this._instanceId);
    };
    Carousel2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Carousel2.prototype.getItem = function(position) {
      return this._items[position];
    };
    Carousel2.prototype.slideTo = function(position) {
      var nextItem = this._items[position];
      var rotationItems = {
        left: nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
        middle: nextItem,
        right: nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
      };
      this._rotate(rotationItems);
      this._setActiveItem(nextItem);
      if (this._intervalInstance) {
        this.pause();
        this.cycle();
      }
      this._options.onChange(this);
    };
    Carousel2.prototype.next = function() {
      var activeItem = this.getActiveItem();
      var nextItem = null;
      if (activeItem.position === this._items.length - 1) {
        nextItem = this._items[0];
      } else {
        nextItem = this._items[activeItem.position + 1];
      }
      this.slideTo(nextItem.position);
      this._options.onNext(this);
    };
    Carousel2.prototype.prev = function() {
      var activeItem = this.getActiveItem();
      var prevItem = null;
      if (activeItem.position === 0) {
        prevItem = this._items[this._items.length - 1];
      } else {
        prevItem = this._items[activeItem.position - 1];
      }
      this.slideTo(prevItem.position);
      this._options.onPrev(this);
    };
    Carousel2.prototype._rotate = function(rotationItems) {
      this._items.map(function(item) {
        item.el.classList.add("hidden");
      });
      if (this._items.length === 1) {
        rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
        rotationItems.middle.el.classList.add("translate-x-0", "z-20");
        return;
      }
      rotationItems.left.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-20");
      rotationItems.left.el.classList.add("-translate-x-full", "z-10");
      rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
      rotationItems.middle.el.classList.add("translate-x-0", "z-30");
      rotationItems.right.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-30");
      rotationItems.right.el.classList.add("translate-x-full", "z-20");
    };
    Carousel2.prototype.cycle = function() {
      var _this = this;
      if (typeof window !== "undefined") {
        this._intervalInstance = window.setInterval(function() {
          _this.next();
        }, this._intervalDuration);
      }
    };
    Carousel2.prototype.pause = function() {
      clearInterval(this._intervalInstance);
    };
    Carousel2.prototype.getActiveItem = function() {
      return this._activeItem;
    };
    Carousel2.prototype._setActiveItem = function(item) {
      var _a2, _b2;
      var _this = this;
      this._activeItem = item;
      var position = item.position;
      if (this._indicators.length) {
        this._indicators.map(function(indicator) {
          var _a3, _b3;
          indicator.el.setAttribute("aria-current", "false");
          (_a3 = indicator.el.classList).remove.apply(_a3, _this._options.indicators.activeClasses.split(" "));
          (_b3 = indicator.el.classList).add.apply(_b3, _this._options.indicators.inactiveClasses.split(" "));
        });
        (_a2 = this._indicators[position].el.classList).add.apply(_a2, this._options.indicators.activeClasses.split(" "));
        (_b2 = this._indicators[position].el.classList).remove.apply(_b2, this._options.indicators.inactiveClasses.split(" "));
        this._indicators[position].el.setAttribute("aria-current", "true");
      }
    };
    Carousel2.prototype.updateOnNext = function(callback) {
      this._options.onNext = callback;
    };
    Carousel2.prototype.updateOnPrev = function(callback) {
      this._options.onPrev = callback;
    };
    Carousel2.prototype.updateOnChange = function(callback) {
      this._options.onChange = callback;
    };
    return Carousel2;
  })()
);
function initCarousels() {
  document.querySelectorAll("[data-carousel]").forEach(function($carouselEl) {
    var interval = $carouselEl.getAttribute("data-carousel-interval");
    var slide = $carouselEl.getAttribute("data-carousel") === "slide" ? true : false;
    var items = [];
    var defaultPosition = 0;
    if ($carouselEl.querySelectorAll("[data-carousel-item]").length) {
      Array.from($carouselEl.querySelectorAll("[data-carousel-item]")).map(function($carouselItemEl, position) {
        items.push({
          position,
          el: $carouselItemEl
        });
        if ($carouselItemEl.getAttribute("data-carousel-item") === "active") {
          defaultPosition = position;
        }
      });
    }
    var indicators = [];
    if ($carouselEl.querySelectorAll("[data-carousel-slide-to]").length) {
      Array.from($carouselEl.querySelectorAll("[data-carousel-slide-to]")).map(function($indicatorEl) {
        indicators.push({
          position: parseInt($indicatorEl.getAttribute("data-carousel-slide-to")),
          el: $indicatorEl
        });
      });
    }
    var carousel = new Carousel($carouselEl, items, {
      defaultPosition,
      indicators: {
        items: indicators
      },
      interval: interval ? interval : Default$b.interval
    });
    if (slide) {
      carousel.cycle();
    }
    var carouselNextEl = $carouselEl.querySelector("[data-carousel-next]");
    var carouselPrevEl = $carouselEl.querySelector("[data-carousel-prev]");
    if (carouselNextEl) {
      carouselNextEl.addEventListener("click", function() {
        carousel.next();
      });
    }
    if (carouselPrevEl) {
      carouselPrevEl.addEventListener("click", function() {
        carousel.prev();
      });
    }
  });
}
if (typeof window !== "undefined") {
  window.Carousel = Carousel;
  window.initCarousels = initCarousels;
}
var __assign$a = function() {
  __assign$a = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$a.apply(this, arguments);
};
var Default$a = {
  transition: "transition-opacity",
  duration: 300,
  timing: "ease-out",
  onHide: function() {
  }
};
var DefaultInstanceOptions$a = {
  id: null,
  override: true
};
var Dismiss = (
  /** @class */
  (function() {
    function Dismiss2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$a;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$a;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$a(__assign$a({}, Default$a), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Dismiss", this, this._instanceId, instanceOptions.override);
    }
    Dismiss2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._clickHandler = function() {
          _this.hide();
        };
        this._triggerEl.addEventListener("click", this._clickHandler);
        this._initialized = true;
      }
    };
    Dismiss2.prototype.destroy = function() {
      if (this._triggerEl && this._initialized) {
        this._triggerEl.removeEventListener("click", this._clickHandler);
        this._initialized = false;
      }
    };
    Dismiss2.prototype.removeInstance = function() {
      instances.removeInstance("Dismiss", this._instanceId);
    };
    Dismiss2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dismiss2.prototype.hide = function() {
      var _this = this;
      this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, "opacity-0");
      setTimeout(function() {
        _this._targetEl.classList.add("hidden");
      }, this._options.duration);
      this._options.onHide(this, this._targetEl);
    };
    Dismiss2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    return Dismiss2;
  })()
);
function initDismisses() {
  document.querySelectorAll("[data-dismiss-target]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-dismiss-target");
    var $dismissEl = document.querySelector(targetId);
    if ($dismissEl) {
      new Dismiss($dismissEl, $triggerEl);
    } else {
      console.error('The dismiss element with id "'.concat(targetId, '" does not exist. Please check the data-dismiss-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dismiss = Dismiss;
  window.initDismisses = initDismisses;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y3,
    right: x + width,
    bottom: y3 + height,
    left: x,
    x,
    y: y3
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y3 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y: y3
  }) : {
    x,
    y: y3
  };
  x = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y: y3
  }, getWindow(popper2)) : {
    x,
    y: y3
  };
  x = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y3 + "px)" : "translate3d(" + x + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y: y3
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y: y3
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary2, rootBoundary, strategy) {
  var mainClippingParents = boundary2 === "clippingParents" ? getClippingParents(element) : [].concat(boundary2);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary2 = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary2, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary2 = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary: boundary2,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary2 = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary: boundary2,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary: boundary2,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary2 = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary2,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen2 = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen2 + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var __assign$9 = function() {
  __assign$9 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$9.apply(this, arguments);
};
var __spreadArray$2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$9 = {
  placement: "bottom",
  triggerType: "click",
  offsetSkidding: 0,
  offsetDistance: 10,
  delay: 300,
  ignoreClickOutsideClass: false,
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$9 = {
  id: null,
  override: true
};
var Dropdown = (
  /** @class */
  (function() {
    function Dropdown2(targetElement, triggerElement, options, instanceOptions) {
      if (targetElement === void 0) {
        targetElement = null;
      }
      if (triggerElement === void 0) {
        triggerElement = null;
      }
      if (options === void 0) {
        options = Default$9;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$9;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetElement.id;
      this._targetEl = targetElement;
      this._triggerEl = triggerElement;
      this._options = __assign$9(__assign$9({}, Default$9), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Dropdown", this, this._instanceId, instanceOptions.override);
    }
    Dropdown2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._popperInstance = this._createPopperInstance();
        this._setupEventListeners();
        this._initialized = true;
      }
    };
    Dropdown2.prototype.destroy = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      if (this._options.triggerType === "click") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._clickHandler);
        });
      }
      if (this._options.triggerType === "hover") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);
          _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);
          _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);
        });
      }
      this._popperInstance.destroy();
      this._initialized = false;
    };
    Dropdown2.prototype.removeInstance = function() {
      instances.removeInstance("Dropdown", this._instanceId);
    };
    Dropdown2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dropdown2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._clickHandler = function() {
        _this.toggle();
      };
      if (this._options.triggerType === "click") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._clickHandler);
        });
      }
      this._hoverShowTriggerElHandler = function(ev) {
        if (ev.type === "click") {
          _this.toggle();
        } else {
          setTimeout(function() {
            _this.show();
          }, _this._options.delay);
        }
      };
      this._hoverShowTargetElHandler = function() {
        _this.show();
      };
      this._hoverHideHandler = function() {
        setTimeout(function() {
          if (!_this._targetEl.matches(":hover")) {
            _this.hide();
          }
        }, _this._options.delay);
      };
      if (this._options.triggerType === "hover") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);
          _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);
          _this._targetEl.addEventListener(ev, _this._hoverHideHandler);
        });
      }
    };
    Dropdown2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [
                this._options.offsetSkidding,
                this._options.offsetDistance
              ]
            }
          }
        ]
      });
    };
    Dropdown2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Dropdown2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Dropdown2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;
      var isIgnored = false;
      if (ignoreClickOutsideClass) {
        var ignoredClickOutsideEls = document.querySelectorAll(".".concat(ignoreClickOutsideClass));
        ignoredClickOutsideEls.forEach(function(el) {
          if (el.contains(clickedEl)) {
            isIgnored = true;
            return;
          }
        });
      }
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && !isIgnored && this.isVisible()) {
        this.hide();
      }
    };
    Dropdown2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "click"],
            hideEvents: ["mouseleave"]
          };
        case "click":
          return {
            showEvents: ["click"],
            hideEvents: []
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["click"],
            hideEvents: []
          };
      }
    };
    Dropdown2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
      this._options.onToggle(this);
    };
    Dropdown2.prototype.isVisible = function() {
      return this._visible;
    };
    Dropdown2.prototype.show = function() {
      this._targetEl.classList.remove("hidden");
      this._targetEl.classList.add("block");
      this._targetEl.removeAttribute("aria-hidden");
      this._popperInstance.setOptions(function(options) {
        return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Dropdown2.prototype.hide = function() {
      this._targetEl.classList.remove("block");
      this._targetEl.classList.add("hidden");
      this._targetEl.setAttribute("aria-hidden", "true");
      this._popperInstance.setOptions(function(options) {
        return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._visible = false;
      this._removeClickOutsideListener();
      this._options.onHide(this);
    };
    Dropdown2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Dropdown2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Dropdown2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Dropdown2;
  })()
);
function initDropdowns() {
  document.querySelectorAll("[data-dropdown-toggle]").forEach(function($triggerEl) {
    var dropdownId = $triggerEl.getAttribute("data-dropdown-toggle");
    var $dropdownEl = document.getElementById(dropdownId);
    if ($dropdownEl) {
      var placement = $triggerEl.getAttribute("data-dropdown-placement");
      var offsetSkidding = $triggerEl.getAttribute("data-dropdown-offset-skidding");
      var offsetDistance = $triggerEl.getAttribute("data-dropdown-offset-distance");
      var triggerType = $triggerEl.getAttribute("data-dropdown-trigger");
      var delay = $triggerEl.getAttribute("data-dropdown-delay");
      var ignoreClickOutsideClass = $triggerEl.getAttribute("data-dropdown-ignore-click-outside-class");
      new Dropdown($dropdownEl, $triggerEl, {
        placement: placement ? placement : Default$9.placement,
        triggerType: triggerType ? triggerType : Default$9.triggerType,
        offsetSkidding: offsetSkidding ? parseInt(offsetSkidding) : Default$9.offsetSkidding,
        offsetDistance: offsetDistance ? parseInt(offsetDistance) : Default$9.offsetDistance,
        delay: delay ? parseInt(delay) : Default$9.delay,
        ignoreClickOutsideClass: ignoreClickOutsideClass ? ignoreClickOutsideClass : Default$9.ignoreClickOutsideClass
      });
    } else {
      console.error('The dropdown element with id "'.concat(dropdownId, '" does not exist. Please check the data-dropdown-toggle attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dropdown = Dropdown;
  window.initDropdowns = initDropdowns;
}
var __assign$8 = function() {
  __assign$8 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$8.apply(this, arguments);
};
var Default$8 = {
  placement: "center",
  backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40",
  backdrop: "dynamic",
  closable: true,
  onHide: function() {
  },
  onShow: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$8 = {
  id: null,
  override: true
};
var Modal = (
  /** @class */
  (function() {
    function Modal2(targetEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$8;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$8;
      }
      this._eventListenerInstances = [];
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._options = __assign$8(__assign$8({}, Default$8), options);
      this._isHidden = true;
      this._backdropEl = null;
      this._initialized = false;
      this.init();
      instances.addInstance("Modal", this, this._instanceId, instanceOptions.override);
    }
    Modal2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._getPlacementClasses().map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._initialized = true;
      }
    };
    Modal2.prototype.destroy = function() {
      if (this._initialized) {
        this.removeAllEventListenerInstances();
        this._destroyBackdropEl();
        this._initialized = false;
      }
    };
    Modal2.prototype.removeInstance = function() {
      instances.removeInstance("Modal", this._instanceId);
    };
    Modal2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Modal2.prototype._createBackdrop = function() {
      var _a2;
      if (this._isHidden) {
        var backdropEl = document.createElement("div");
        (_a2 = backdropEl.classList).add.apply(_a2, this._options.backdropClasses.split(" "));
        document.querySelector("body").append(backdropEl);
        this._backdropEl = backdropEl;
      }
    };
    Modal2.prototype._destroyBackdropEl = function() {
      if (!this._isHidden && this._backdropEl) {
        this._backdropEl.remove();
        this._backdropEl = null;
      }
    };
    Modal2.prototype._setupModalCloseEventListeners = function() {
      var _this = this;
      if (this._options.backdrop === "dynamic") {
        this._clickOutsideEventListener = function(ev) {
          _this._handleOutsideClick(ev.target);
        };
        this._targetEl.addEventListener("click", this._clickOutsideEventListener, true);
      }
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Modal2.prototype._removeModalCloseEventListeners = function() {
      if (this._options.backdrop === "dynamic") {
        this._targetEl.removeEventListener("click", this._clickOutsideEventListener, true);
      }
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Modal2.prototype._handleOutsideClick = function(target) {
      if (target === this._targetEl || target === this._backdropEl && this.isVisible()) {
        this.hide();
      }
    };
    Modal2.prototype._getPlacementClasses = function() {
      switch (this._options.placement) {
        // top
        case "top-left":
          return ["justify-start", "items-start"];
        case "top-center":
          return ["justify-center", "items-start"];
        case "top-right":
          return ["justify-end", "items-start"];
        // center
        case "center-left":
          return ["justify-start", "items-center"];
        case "center":
          return ["justify-center", "items-center"];
        case "center-right":
          return ["justify-end", "items-center"];
        // bottom
        case "bottom-left":
          return ["justify-start", "items-end"];
        case "bottom-center":
          return ["justify-center", "items-end"];
        case "bottom-right":
          return ["justify-end", "items-end"];
        default:
          return ["justify-center", "items-center"];
      }
    };
    Modal2.prototype.toggle = function() {
      if (this._isHidden) {
        this.show();
      } else {
        this.hide();
      }
      this._options.onToggle(this);
    };
    Modal2.prototype.show = function() {
      if (this.isHidden) {
        this._targetEl.classList.add("flex");
        this._targetEl.classList.remove("hidden");
        this._targetEl.setAttribute("aria-modal", "true");
        this._targetEl.setAttribute("role", "dialog");
        this._targetEl.removeAttribute("aria-hidden");
        this._createBackdrop();
        this._isHidden = false;
        if (this._options.closable) {
          this._setupModalCloseEventListeners();
        }
        document.body.classList.add("overflow-hidden");
        this._options.onShow(this);
      }
    };
    Modal2.prototype.hide = function() {
      if (this.isVisible) {
        this._targetEl.classList.add("hidden");
        this._targetEl.classList.remove("flex");
        this._targetEl.setAttribute("aria-hidden", "true");
        this._targetEl.removeAttribute("aria-modal");
        this._targetEl.removeAttribute("role");
        this._destroyBackdropEl();
        this._isHidden = true;
        document.body.classList.remove("overflow-hidden");
        if (this._options.closable) {
          this._removeModalCloseEventListeners();
        }
        this._options.onHide(this);
      }
    };
    Modal2.prototype.isVisible = function() {
      return !this._isHidden;
    };
    Modal2.prototype.isHidden = function() {
      return this._isHidden;
    };
    Modal2.prototype.addEventListenerInstance = function(element, type, handler) {
      this._eventListenerInstances.push({
        element,
        type,
        handler
      });
    };
    Modal2.prototype.removeAllEventListenerInstances = function() {
      this._eventListenerInstances.map(function(eventListenerInstance) {
        eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
      });
      this._eventListenerInstances = [];
    };
    Modal2.prototype.getAllEventListenerInstances = function() {
      return this._eventListenerInstances;
    };
    Modal2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Modal2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Modal2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Modal2;
  })()
);
function initModals() {
  document.querySelectorAll("[data-modal-target]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-target");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var placement = $modalEl.getAttribute("data-modal-placement");
      var backdrop = $modalEl.getAttribute("data-modal-backdrop");
      new Modal($modalEl, {
        placement: placement ? placement : Default$8.placement,
        backdrop: backdrop ? backdrop : Default$8.backdrop
      });
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
    }
  });
  document.querySelectorAll("[data-modal-toggle]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-toggle");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_1 = instances.getInstance("Modal", modalId);
      if (modal_1) {
        var toggleModal = function() {
          modal_1.toggle();
        };
        $triggerEl.addEventListener("click", toggleModal);
        modal_1.addEventListenerInstance($triggerEl, "click", toggleModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
    }
  });
  document.querySelectorAll("[data-modal-show]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-show");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_2 = instances.getInstance("Modal", modalId);
      if (modal_2) {
        var showModal = function() {
          modal_2.show();
        };
        $triggerEl.addEventListener("click", showModal);
        modal_2.addEventListenerInstance($triggerEl, "click", showModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
    }
  });
  document.querySelectorAll("[data-modal-hide]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-hide");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_3 = instances.getInstance("Modal", modalId);
      if (modal_3) {
        var hideModal = function() {
          modal_3.hide();
        };
        $triggerEl.addEventListener("click", hideModal);
        modal_3.addEventListenerInstance($triggerEl, "click", hideModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Modal = Modal;
  window.initModals = initModals;
}
var __assign$7 = function() {
  __assign$7 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$7.apply(this, arguments);
};
var Default$7 = {
  placement: "left",
  bodyScrolling: false,
  backdrop: true,
  edge: false,
  edgeOffset: "bottom-[60px]",
  backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$7 = {
  id: null,
  override: true
};
var Drawer = (
  /** @class */
  (function() {
    function Drawer2(targetEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$7;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$7;
      }
      this._eventListenerInstances = [];
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._options = __assign$7(__assign$7({}, Default$7), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Drawer", this, this._instanceId, instanceOptions.override);
    }
    Drawer2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._targetEl.setAttribute("aria-hidden", "true");
        this._targetEl.classList.add("transition-transform");
        this._getPlacementClasses(this._options.placement).base.map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._handleEscapeKey = function(event) {
          if (event.key === "Escape") {
            if (_this.isVisible()) {
              _this.hide();
            }
          }
        };
        document.addEventListener("keydown", this._handleEscapeKey);
        this._initialized = true;
      }
    };
    Drawer2.prototype.destroy = function() {
      if (this._initialized) {
        this.removeAllEventListenerInstances();
        this._destroyBackdropEl();
        document.removeEventListener("keydown", this._handleEscapeKey);
        this._initialized = false;
      }
    };
    Drawer2.prototype.removeInstance = function() {
      instances.removeInstance("Drawer", this._instanceId);
    };
    Drawer2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Drawer2.prototype.hide = function() {
      var _this = this;
      if (this._options.edge) {
        this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
        this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
          _this._targetEl.classList.add(c);
        });
      } else {
        this._getPlacementClasses(this._options.placement).active.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
        this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
          _this._targetEl.classList.add(c);
        });
      }
      this._targetEl.setAttribute("aria-hidden", "true");
      this._targetEl.removeAttribute("aria-modal");
      this._targetEl.removeAttribute("role");
      if (!this._options.bodyScrolling) {
        document.body.classList.remove("overflow-hidden");
      }
      if (this._options.backdrop) {
        this._destroyBackdropEl();
      }
      this._visible = false;
      this._options.onHide(this);
    };
    Drawer2.prototype.show = function() {
      var _this = this;
      if (this._options.edge) {
        this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
      } else {
        this._getPlacementClasses(this._options.placement).active.map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
      }
      this._targetEl.setAttribute("aria-modal", "true");
      this._targetEl.setAttribute("role", "dialog");
      this._targetEl.removeAttribute("aria-hidden");
      if (!this._options.bodyScrolling) {
        document.body.classList.add("overflow-hidden");
      }
      if (this._options.backdrop) {
        this._createBackdrop();
      }
      this._visible = true;
      this._options.onShow(this);
    };
    Drawer2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
    };
    Drawer2.prototype._createBackdrop = function() {
      var _a2;
      var _this = this;
      if (!this._visible) {
        var backdropEl = document.createElement("div");
        backdropEl.setAttribute("drawer-backdrop", "");
        (_a2 = backdropEl.classList).add.apply(_a2, this._options.backdropClasses.split(" "));
        document.querySelector("body").append(backdropEl);
        backdropEl.addEventListener("click", function() {
          _this.hide();
        });
      }
    };
    Drawer2.prototype._destroyBackdropEl = function() {
      if (this._visible && document.querySelector("[drawer-backdrop]") !== null) {
        document.querySelector("[drawer-backdrop]").remove();
      }
    };
    Drawer2.prototype._getPlacementClasses = function(placement) {
      switch (placement) {
        case "top":
          return {
            base: ["top-0", "left-0", "right-0"],
            active: ["transform-none"],
            inactive: ["-translate-y-full"]
          };
        case "right":
          return {
            base: ["right-0", "top-0"],
            active: ["transform-none"],
            inactive: ["translate-x-full"]
          };
        case "bottom":
          return {
            base: ["bottom-0", "left-0", "right-0"],
            active: ["transform-none"],
            inactive: ["translate-y-full"]
          };
        case "left":
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["-translate-x-full"]
          };
        case "bottom-edge":
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["translate-y-full", this._options.edgeOffset]
          };
        default:
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["-translate-x-full"]
          };
      }
    };
    Drawer2.prototype.isHidden = function() {
      return !this._visible;
    };
    Drawer2.prototype.isVisible = function() {
      return this._visible;
    };
    Drawer2.prototype.addEventListenerInstance = function(element, type, handler) {
      this._eventListenerInstances.push({
        element,
        type,
        handler
      });
    };
    Drawer2.prototype.removeAllEventListenerInstances = function() {
      this._eventListenerInstances.map(function(eventListenerInstance) {
        eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
      });
      this._eventListenerInstances = [];
    };
    Drawer2.prototype.getAllEventListenerInstances = function() {
      return this._eventListenerInstances;
    };
    Drawer2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Drawer2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Drawer2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Drawer2;
  })()
);
function initDrawers() {
  document.querySelectorAll("[data-drawer-target]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-target");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var placement = $triggerEl.getAttribute("data-drawer-placement");
      var bodyScrolling = $triggerEl.getAttribute("data-drawer-body-scrolling");
      var backdrop = $triggerEl.getAttribute("data-drawer-backdrop");
      var edge = $triggerEl.getAttribute("data-drawer-edge");
      var edgeOffset = $triggerEl.getAttribute("data-drawer-edge-offset");
      new Drawer($drawerEl, {
        placement: placement ? placement : Default$7.placement,
        bodyScrolling: bodyScrolling ? bodyScrolling === "true" ? true : false : Default$7.bodyScrolling,
        backdrop: backdrop ? backdrop === "true" ? true : false : Default$7.backdrop,
        edge: edge ? edge === "true" ? true : false : Default$7.edge,
        edgeOffset: edgeOffset ? edgeOffset : Default$7.edgeOffset
      });
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
  document.querySelectorAll("[data-drawer-toggle]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-toggle");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_1 = instances.getInstance("Drawer", drawerId);
      if (drawer_1) {
        var toggleDrawer = function() {
          drawer_1.toggle();
        };
        $triggerEl.addEventListener("click", toggleDrawer);
        drawer_1.addEventListenerInstance($triggerEl, "click", toggleDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
  document.querySelectorAll("[data-drawer-dismiss], [data-drawer-hide]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-dismiss") ? $triggerEl.getAttribute("data-drawer-dismiss") : $triggerEl.getAttribute("data-drawer-hide");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_2 = instances.getInstance("Drawer", drawerId);
      if (drawer_2) {
        var hideDrawer = function() {
          drawer_2.hide();
        };
        $triggerEl.addEventListener("click", hideDrawer);
        drawer_2.addEventListenerInstance($triggerEl, "click", hideDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
    }
  });
  document.querySelectorAll("[data-drawer-show]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-show");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_3 = instances.getInstance("Drawer", drawerId);
      if (drawer_3) {
        var showDrawer = function() {
          drawer_3.show();
        };
        $triggerEl.addEventListener("click", showDrawer);
        drawer_3.addEventListenerInstance($triggerEl, "click", showDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Drawer = Drawer;
  window.initDrawers = initDrawers;
}
var __assign$6 = function() {
  __assign$6 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$6.apply(this, arguments);
};
var Default$6 = {
  defaultTabId: null,
  activeClasses: "text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500",
  inactiveClasses: "dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300",
  onShow: function() {
  }
};
var DefaultInstanceOptions$6 = {
  id: null,
  override: true
};
var Tabs = (
  /** @class */
  (function() {
    function Tabs2(tabsEl, items, options, instanceOptions) {
      if (tabsEl === void 0) {
        tabsEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$6;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$6;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;
      this._tabsEl = tabsEl;
      this._items = items;
      this._activeTab = options ? this.getTab(options.defaultTabId) : null;
      this._options = __assign$6(__assign$6({}, Default$6), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Tabs", this, this._instanceId, instanceOptions.override);
    }
    Tabs2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        if (!this._activeTab) {
          this.setActiveTab(this._items[0]);
        }
        this.show(this._activeTab.id, true);
        this._items.map(function(tab) {
          tab.triggerEl.addEventListener("click", function(event) {
            event.preventDefault();
            _this.show(tab.id);
          });
        });
      }
    };
    Tabs2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
      }
    };
    Tabs2.prototype.removeInstance = function() {
      this.destroy();
      instances.removeInstance("Tabs", this._instanceId);
    };
    Tabs2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Tabs2.prototype.getActiveTab = function() {
      return this._activeTab;
    };
    Tabs2.prototype.setActiveTab = function(tab) {
      this._activeTab = tab;
    };
    Tabs2.prototype.getTab = function(id2) {
      return this._items.filter(function(t) {
        return t.id === id2;
      })[0];
    };
    Tabs2.prototype.show = function(id2, forceShow) {
      var _a2, _b2;
      var _this = this;
      if (forceShow === void 0) {
        forceShow = false;
      }
      var tab = this.getTab(id2);
      if (tab === this._activeTab && !forceShow) {
        return;
      }
      this._items.map(function(t) {
        var _a3, _b3;
        if (t !== tab) {
          (_a3 = t.triggerEl.classList).remove.apply(_a3, _this._options.activeClasses.split(" "));
          (_b3 = t.triggerEl.classList).add.apply(_b3, _this._options.inactiveClasses.split(" "));
          t.targetEl.classList.add("hidden");
          t.triggerEl.setAttribute("aria-selected", "false");
        }
      });
      (_a2 = tab.triggerEl.classList).add.apply(_a2, this._options.activeClasses.split(" "));
      (_b2 = tab.triggerEl.classList).remove.apply(_b2, this._options.inactiveClasses.split(" "));
      tab.triggerEl.setAttribute("aria-selected", "true");
      tab.targetEl.classList.remove("hidden");
      this.setActiveTab(tab);
      this._options.onShow(this, tab);
    };
    Tabs2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    return Tabs2;
  })()
);
function initTabs() {
  document.querySelectorAll("[data-tabs-toggle]").forEach(function($parentEl) {
    var tabItems = [];
    var activeClasses = $parentEl.getAttribute("data-tabs-active-classes");
    var inactiveClasses = $parentEl.getAttribute("data-tabs-inactive-classes");
    var defaultTabId = null;
    $parentEl.querySelectorAll('[role="tab"]').forEach(function($triggerEl) {
      var isActive = $triggerEl.getAttribute("aria-selected") === "true";
      var tab = {
        id: $triggerEl.getAttribute("data-tabs-target"),
        triggerEl: $triggerEl,
        targetEl: document.querySelector($triggerEl.getAttribute("data-tabs-target"))
      };
      tabItems.push(tab);
      if (isActive) {
        defaultTabId = tab.id;
      }
    });
    new Tabs($parentEl, tabItems, {
      defaultTabId,
      activeClasses: activeClasses ? activeClasses : Default$6.activeClasses,
      inactiveClasses: inactiveClasses ? inactiveClasses : Default$6.inactiveClasses
    });
  });
}
if (typeof window !== "undefined") {
  window.Tabs = Tabs;
  window.initTabs = initTabs;
}
var __assign$5 = function() {
  __assign$5 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$5.apply(this, arguments);
};
var __spreadArray$1 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$5 = {
  placement: "top",
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$5 = {
  id: null,
  override: true
};
var Tooltip = (
  /** @class */
  (function() {
    function Tooltip2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$5;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$5;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$5(__assign$5({}, Default$5), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Tooltip", this, this._instanceId, instanceOptions.override);
    }
    Tooltip2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._setupEventListeners();
        this._popperInstance = this._createPopperInstance();
        this._initialized = true;
      }
    };
    Tooltip2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hideHandler);
        });
        this._removeKeydownListener();
        this._removeClickOutsideListener();
        if (this._popperInstance) {
          this._popperInstance.destroy();
        }
        this._initialized = false;
      }
    };
    Tooltip2.prototype.removeInstance = function() {
      instances.removeInstance("Tooltip", this._instanceId);
    };
    Tooltip2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Tooltip2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._showHandler = function() {
        _this.show();
      };
      this._hideHandler = function() {
        _this.hide();
      };
      triggerEvents.showEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._showHandler);
      });
      triggerEvents.hideEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._hideHandler);
      });
    };
    Tooltip2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 8]
            }
          }
        ]
      });
    };
    Tooltip2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Tooltip2.prototype._setupKeydownListener = function() {
      var _this = this;
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Tooltip2.prototype._removeKeydownListener = function() {
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Tooltip2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Tooltip2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Tooltip2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
        this.hide();
      }
    };
    Tooltip2.prototype.isVisible = function() {
      return this._visible;
    };
    Tooltip2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
    };
    Tooltip2.prototype.show = function() {
      this._targetEl.classList.remove("opacity-0", "invisible");
      this._targetEl.classList.add("opacity-100", "visible");
      this._popperInstance.setOptions(function(options) {
        return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._setupKeydownListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Tooltip2.prototype.hide = function() {
      this._targetEl.classList.remove("opacity-100", "visible");
      this._targetEl.classList.add("opacity-0", "invisible");
      this._popperInstance.setOptions(function(options) {
        return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._removeClickOutsideListener();
      this._removeKeydownListener();
      this._visible = false;
      this._options.onHide(this);
    };
    Tooltip2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Tooltip2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Tooltip2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Tooltip2;
  })()
);
function initTooltips() {
  document.querySelectorAll("[data-tooltip-target]").forEach(function($triggerEl) {
    var tooltipId = $triggerEl.getAttribute("data-tooltip-target");
    var $tooltipEl = document.getElementById(tooltipId);
    if ($tooltipEl) {
      var triggerType = $triggerEl.getAttribute("data-tooltip-trigger");
      var placement = $triggerEl.getAttribute("data-tooltip-placement");
      new Tooltip($tooltipEl, $triggerEl, {
        placement: placement ? placement : Default$5.placement,
        triggerType: triggerType ? triggerType : Default$5.triggerType
      });
    } else {
      console.error('The tooltip element with id "'.concat(tooltipId, '" does not exist. Please check the data-tooltip-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Tooltip = Tooltip;
  window.initTooltips = initTooltips;
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$4.apply(this, arguments);
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$4 = {
  placement: "top",
  offset: 10,
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$4 = {
  id: null,
  override: true
};
var Popover = (
  /** @class */
  (function() {
    function Popover2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$4;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$4;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$4(__assign$4({}, Default$4), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Popover", this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);
    }
    Popover2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._setupEventListeners();
        this._popperInstance = this._createPopperInstance();
        this._initialized = true;
      }
    };
    Popover2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showHandler);
          _this._targetEl.removeEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hideHandler);
          _this._targetEl.removeEventListener(ev, _this._hideHandler);
        });
        this._removeKeydownListener();
        this._removeClickOutsideListener();
        if (this._popperInstance) {
          this._popperInstance.destroy();
        }
        this._initialized = false;
      }
    };
    Popover2.prototype.removeInstance = function() {
      instances.removeInstance("Popover", this._instanceId);
    };
    Popover2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Popover2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._showHandler = function() {
        _this.show();
      };
      this._hideHandler = function() {
        setTimeout(function() {
          if (!_this._targetEl.matches(":hover")) {
            _this.hide();
          }
        }, 100);
      };
      triggerEvents.showEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._showHandler);
        _this._targetEl.addEventListener(ev, _this._showHandler);
      });
      triggerEvents.hideEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._hideHandler);
        _this._targetEl.addEventListener(ev, _this._hideHandler);
      });
    };
    Popover2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, this._options.offset]
            }
          }
        ]
      });
    };
    Popover2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Popover2.prototype._setupKeydownListener = function() {
      var _this = this;
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Popover2.prototype._removeKeydownListener = function() {
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Popover2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Popover2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Popover2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
        this.hide();
      }
    };
    Popover2.prototype.isVisible = function() {
      return this._visible;
    };
    Popover2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
      this._options.onToggle(this);
    };
    Popover2.prototype.show = function() {
      this._targetEl.classList.remove("opacity-0", "invisible");
      this._targetEl.classList.add("opacity-100", "visible");
      this._popperInstance.setOptions(function(options) {
        return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._setupKeydownListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Popover2.prototype.hide = function() {
      this._targetEl.classList.remove("opacity-100", "visible");
      this._targetEl.classList.add("opacity-0", "invisible");
      this._popperInstance.setOptions(function(options) {
        return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._removeClickOutsideListener();
      this._removeKeydownListener();
      this._visible = false;
      this._options.onHide(this);
    };
    Popover2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Popover2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Popover2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Popover2;
  })()
);
function initPopovers() {
  document.querySelectorAll("[data-popover-target]").forEach(function($triggerEl) {
    var popoverID = $triggerEl.getAttribute("data-popover-target");
    var $popoverEl = document.getElementById(popoverID);
    if ($popoverEl) {
      var triggerType = $triggerEl.getAttribute("data-popover-trigger");
      var placement = $triggerEl.getAttribute("data-popover-placement");
      var offset2 = $triggerEl.getAttribute("data-popover-offset");
      new Popover($popoverEl, $triggerEl, {
        placement: placement ? placement : Default$4.placement,
        offset: offset2 ? parseInt(offset2) : Default$4.offset,
        triggerType: triggerType ? triggerType : Default$4.triggerType
      });
    } else {
      console.error('The popover element with id "'.concat(popoverID, '" does not exist. Please check the data-popover-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Popover = Popover;
  window.initPopovers = initPopovers;
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
var Default$3 = {
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$3 = {
  id: null,
  override: true
};
var Dial = (
  /** @class */
  (function() {
    function Dial2(parentEl, triggerEl, targetEl, options, instanceOptions) {
      if (parentEl === void 0) {
        parentEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$3;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$3;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._parentEl = parentEl;
      this._triggerEl = triggerEl;
      this._targetEl = targetEl;
      this._options = __assign$3(__assign$3({}, Default$3), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Dial", this, this._instanceId, instanceOptions.override);
    }
    Dial2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
        this._showEventHandler = function() {
          _this.show();
        };
        triggerEventTypes.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._showEventHandler);
          _this._targetEl.addEventListener(ev, _this._showEventHandler);
        });
        this._hideEventHandler = function() {
          if (!_this._parentEl.matches(":hover")) {
            _this.hide();
          }
        };
        triggerEventTypes.hideEvents.forEach(function(ev) {
          _this._parentEl.addEventListener(ev, _this._hideEventHandler);
        });
        this._initialized = true;
      }
    };
    Dial2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
        triggerEventTypes.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showEventHandler);
          _this._targetEl.removeEventListener(ev, _this._showEventHandler);
        });
        triggerEventTypes.hideEvents.forEach(function(ev) {
          _this._parentEl.removeEventListener(ev, _this._hideEventHandler);
        });
        this._initialized = false;
      }
    };
    Dial2.prototype.removeInstance = function() {
      instances.removeInstance("Dial", this._instanceId);
    };
    Dial2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dial2.prototype.hide = function() {
      this._targetEl.classList.add("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "false");
      }
      this._visible = false;
      this._options.onHide(this);
    };
    Dial2.prototype.show = function() {
      this._targetEl.classList.remove("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "true");
      }
      this._visible = true;
      this._options.onShow(this);
    };
    Dial2.prototype.toggle = function() {
      if (this._visible) {
        this.hide();
      } else {
        this.show();
      }
    };
    Dial2.prototype.isHidden = function() {
      return !this._visible;
    };
    Dial2.prototype.isVisible = function() {
      return this._visible;
    };
    Dial2.prototype._getTriggerEventTypes = function(triggerType) {
      switch (triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Dial2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Dial2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Dial2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Dial2;
  })()
);
function initDials() {
  document.querySelectorAll("[data-dial-init]").forEach(function($parentEl) {
    var $triggerEl = $parentEl.querySelector("[data-dial-toggle]");
    if ($triggerEl) {
      var dialId = $triggerEl.getAttribute("data-dial-toggle");
      var $dialEl = document.getElementById(dialId);
      if ($dialEl) {
        var triggerType = $triggerEl.getAttribute("data-dial-trigger");
        new Dial($parentEl, $triggerEl, $dialEl, {
          triggerType: triggerType ? triggerType : Default$3.triggerType
        });
      } else {
        console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
      }
    } else {
      console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dial = Dial;
  window.initDials = initDials;
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
var Default$2 = {
  minValue: null,
  maxValue: null,
  onIncrement: function() {
  },
  onDecrement: function() {
  }
};
var DefaultInstanceOptions$2 = {
  id: null,
  override: true
};
var InputCounter = (
  /** @class */
  (function() {
    function InputCounter2(targetEl, incrementEl, decrementEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (incrementEl === void 0) {
        incrementEl = null;
      }
      if (decrementEl === void 0) {
        decrementEl = null;
      }
      if (options === void 0) {
        options = Default$2;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$2;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._incrementEl = incrementEl;
      this._decrementEl = decrementEl;
      this._options = __assign$2(__assign$2({}, Default$2), options);
      this._initialized = false;
      this.init();
      instances.addInstance("InputCounter", this, this._instanceId, instanceOptions.override);
    }
    InputCounter2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._inputHandler = function(event) {
          {
            var target = event.target;
            if (!/^\d*$/.test(target.value)) {
              target.value = target.value.replace(/[^\d]/g, "");
            }
            if (_this._options.maxValue !== null && parseInt(target.value) > _this._options.maxValue) {
              target.value = _this._options.maxValue.toString();
            }
            if (_this._options.minValue !== null && parseInt(target.value) < _this._options.minValue) {
              target.value = _this._options.minValue.toString();
            }
          }
        };
        this._incrementClickHandler = function() {
          _this.increment();
        };
        this._decrementClickHandler = function() {
          _this.decrement();
        };
        this._targetEl.addEventListener("input", this._inputHandler);
        if (this._incrementEl) {
          this._incrementEl.addEventListener("click", this._incrementClickHandler);
        }
        if (this._decrementEl) {
          this._decrementEl.addEventListener("click", this._decrementClickHandler);
        }
        this._initialized = true;
      }
    };
    InputCounter2.prototype.destroy = function() {
      if (this._targetEl && this._initialized) {
        this._targetEl.removeEventListener("input", this._inputHandler);
        if (this._incrementEl) {
          this._incrementEl.removeEventListener("click", this._incrementClickHandler);
        }
        if (this._decrementEl) {
          this._decrementEl.removeEventListener("click", this._decrementClickHandler);
        }
        this._initialized = false;
      }
    };
    InputCounter2.prototype.removeInstance = function() {
      instances.removeInstance("InputCounter", this._instanceId);
    };
    InputCounter2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    InputCounter2.prototype.getCurrentValue = function() {
      return parseInt(this._targetEl.value) || 0;
    };
    InputCounter2.prototype.increment = function() {
      if (this._options.maxValue !== null && this.getCurrentValue() >= this._options.maxValue) {
        return;
      }
      this._targetEl.value = (this.getCurrentValue() + 1).toString();
      this._options.onIncrement(this);
    };
    InputCounter2.prototype.decrement = function() {
      if (this._options.minValue !== null && this.getCurrentValue() <= this._options.minValue) {
        return;
      }
      this._targetEl.value = (this.getCurrentValue() - 1).toString();
      this._options.onDecrement(this);
    };
    InputCounter2.prototype.updateOnIncrement = function(callback) {
      this._options.onIncrement = callback;
    };
    InputCounter2.prototype.updateOnDecrement = function(callback) {
      this._options.onDecrement = callback;
    };
    return InputCounter2;
  })()
);
function initInputCounters() {
  document.querySelectorAll("[data-input-counter]").forEach(function($targetEl) {
    var targetId = $targetEl.id;
    var $incrementEl = document.querySelector('[data-input-counter-increment="' + targetId + '"]');
    var $decrementEl = document.querySelector('[data-input-counter-decrement="' + targetId + '"]');
    var minValue = $targetEl.getAttribute("data-input-counter-min");
    var maxValue = $targetEl.getAttribute("data-input-counter-max");
    if ($targetEl) {
      if (!instances.instanceExists("InputCounter", $targetEl.getAttribute("id"))) {
        new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {
          minValue: minValue ? parseInt(minValue) : null,
          maxValue: maxValue ? parseInt(maxValue) : null
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-input-counter attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.InputCounter = InputCounter;
  window.initInputCounters = initInputCounters;
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var Default$1 = {
  htmlEntities: false,
  contentType: "input",
  onCopy: function() {
  }
};
var DefaultInstanceOptions$1 = {
  id: null,
  override: true
};
var CopyClipboard = (
  /** @class */
  (function() {
    function CopyClipboard2(triggerEl, targetEl, options, instanceOptions) {
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$1;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$1;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._triggerEl = triggerEl;
      this._targetEl = targetEl;
      this._options = __assign$1(__assign$1({}, Default$1), options);
      this._initialized = false;
      this.init();
      instances.addInstance("CopyClipboard", this, this._instanceId, instanceOptions.override);
    }
    CopyClipboard2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && this._triggerEl && !this._initialized) {
        this._triggerElClickHandler = function() {
          _this.copy();
        };
        if (this._triggerEl) {
          this._triggerEl.addEventListener("click", this._triggerElClickHandler);
        }
        this._initialized = true;
      }
    };
    CopyClipboard2.prototype.destroy = function() {
      if (this._triggerEl && this._targetEl && this._initialized) {
        if (this._triggerEl) {
          this._triggerEl.removeEventListener("click", this._triggerElClickHandler);
        }
        this._initialized = false;
      }
    };
    CopyClipboard2.prototype.removeInstance = function() {
      instances.removeInstance("CopyClipboard", this._instanceId);
    };
    CopyClipboard2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    CopyClipboard2.prototype.getTargetValue = function() {
      if (this._options.contentType === "input") {
        return this._targetEl.value;
      }
      if (this._options.contentType === "innerHTML") {
        return this._targetEl.innerHTML;
      }
      if (this._options.contentType === "textContent") {
        return this._targetEl.textContent.replace(/\s+/g, " ").trim();
      }
    };
    CopyClipboard2.prototype.copy = function() {
      var textToCopy = this.getTargetValue();
      if (this._options.htmlEntities) {
        textToCopy = this.decodeHTML(textToCopy);
      }
      var tempTextArea = document.createElement("textarea");
      tempTextArea.value = textToCopy;
      document.body.appendChild(tempTextArea);
      tempTextArea.select();
      document.execCommand("copy");
      document.body.removeChild(tempTextArea);
      this._options.onCopy(this);
      return textToCopy;
    };
    CopyClipboard2.prototype.decodeHTML = function(html) {
      var textarea = document.createElement("textarea");
      textarea.innerHTML = html;
      return textarea.textContent;
    };
    CopyClipboard2.prototype.updateOnCopyCallback = function(callback) {
      this._options.onCopy = callback;
    };
    return CopyClipboard2;
  })()
);
function initCopyClipboards() {
  document.querySelectorAll("[data-copy-to-clipboard-target]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-copy-to-clipboard-target");
    var $targetEl = document.getElementById(targetId);
    var contentType = $triggerEl.getAttribute("data-copy-to-clipboard-content-type");
    var htmlEntities = $triggerEl.getAttribute("data-copy-to-clipboard-html-entities");
    if ($targetEl) {
      if (!instances.instanceExists("CopyClipboard", $targetEl.getAttribute("id"))) {
        new CopyClipboard($triggerEl, $targetEl, {
          htmlEntities: htmlEntities && htmlEntities === "true" ? true : Default$1.htmlEntities,
          contentType: contentType ? contentType : Default$1.contentType
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-copy-to-clipboard-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.CopyClipboard = CopyClipboard;
  window.initClipboards = initCopyClipboards;
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
  return t;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function hasProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function lastItemOf(arr) {
  return arr[arr.length - 1];
}
function pushUnique(arr) {
  for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    items[_key - 1] = arguments[_key];
  }
  items.forEach(function(item) {
    if (arr.includes(item)) {
      return;
    }
    arr.push(item);
  });
  return arr;
}
function stringToArray(str, separator) {
  return str ? str.split(separator) : [];
}
function isInRange(testVal, min2, max2) {
  var minOK = min2 === void 0 || testVal >= min2;
  var maxOK = max2 === void 0 || testVal <= max2;
  return minOK && maxOK;
}
function limitToRange(val, min2, max2) {
  if (val < min2) {
    return min2;
  }
  if (val > max2) {
    return max2;
  }
  return val;
}
function createTagRepeat(tagName, repeat) {
  var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var html = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
  var openTagSrc = Object.keys(attributes).reduce(function(src, attr) {
    var val = attributes[attr];
    if (typeof val === "function") {
      val = val(index);
    }
    return "".concat(src, " ").concat(attr, '="').concat(val, '"');
  }, tagName);
  html += "<".concat(openTagSrc, "></").concat(tagName, ">");
  var next = index + 1;
  return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
}
function optimizeTemplateHTML(html) {
  return html.replace(/>\s+/g, ">").replace(/\s+</, "<");
}
function stripTime(timeValue) {
  return new Date(timeValue).setHours(0, 0, 0, 0);
}
function today() {
  return (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
}
function dateValue() {
  switch (arguments.length) {
    case 0:
      return today();
    case 1:
      return stripTime(arguments.length <= 0 ? void 0 : arguments[0]);
  }
  var newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear.apply(newDate, arguments);
  return newDate.setHours(0, 0, 0, 0);
}
function addDays(date, amount) {
  var newDate = new Date(date);
  return newDate.setDate(newDate.getDate() + amount);
}
function addWeeks(date, amount) {
  return addDays(date, amount * 7);
}
function addMonths(date, amount) {
  var newDate = new Date(date);
  var monthsToSet = newDate.getMonth() + amount;
  var expectedMonth = monthsToSet % 12;
  if (expectedMonth < 0) {
    expectedMonth += 12;
  }
  var time = newDate.setMonth(monthsToSet);
  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
}
function addYears(date, amount) {
  var newDate = new Date(date);
  var expectedMonth = newDate.getMonth();
  var time = newDate.setFullYear(newDate.getFullYear() + amount);
  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
}
function dayDiff(day, from) {
  return (day - from + 7) % 7;
}
function dayOfTheWeekOf(baseDate, dayOfWeek) {
  var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var baseDay = new Date(baseDate).getDay();
  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
}
function getWeek(date) {
  var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
  var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
  return Math.round((thuOfTheWeek - firstThu) / 6048e5) + 1;
}
function startOfYearPeriod(date, years) {
  var year = new Date(date).getFullYear();
  return Math.floor(year / years) * years;
}
var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
var reNonDateParts = /[\s!-/:-@[-`{-~]+/;
var knownFormats = {};
var parseFns = {
  y: function y(date, year) {
    return new Date(date).setFullYear(parseInt(year, 10));
  },
  m: function m(date, month, locale) {
    var newDate = new Date(date);
    var monthIndex = parseInt(month, 10) - 1;
    if (isNaN(monthIndex)) {
      if (!month) {
        return NaN;
      }
      var monthName = month.toLowerCase();
      var compareNames = function compareNames2(name2) {
        return name2.toLowerCase().startsWith(monthName);
      };
      monthIndex = locale.monthsShort.findIndex(compareNames);
      if (monthIndex < 0) {
        monthIndex = locale.months.findIndex(compareNames);
      }
      if (monthIndex < 0) {
        return NaN;
      }
    }
    newDate.setMonth(monthIndex);
    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
  },
  d: function d(date, day) {
    return new Date(date).setDate(parseInt(day, 10));
  }
};
var formatFns = {
  d: function d2(date) {
    return date.getDate();
  },
  dd: function dd(date) {
    return padZero(date.getDate(), 2);
  },
  D: function D(date, locale) {
    return locale.daysShort[date.getDay()];
  },
  DD: function DD(date, locale) {
    return locale.days[date.getDay()];
  },
  m: function m2(date) {
    return date.getMonth() + 1;
  },
  mm: function mm(date) {
    return padZero(date.getMonth() + 1, 2);
  },
  M: function M(date, locale) {
    return locale.monthsShort[date.getMonth()];
  },
  MM: function MM(date, locale) {
    return locale.months[date.getMonth()];
  },
  y: function y2(date) {
    return date.getFullYear();
  },
  yy: function yy(date) {
    return padZero(date.getFullYear(), 2).slice(-2);
  },
  yyyy: function yyyy(date) {
    return padZero(date.getFullYear(), 4);
  }
};
function normalizeMonth(monthIndex) {
  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
}
function padZero(num, length) {
  return num.toString().padStart(length, "0");
}
function parseFormatString(format2) {
  if (typeof format2 !== "string") {
    throw new Error("Invalid date format.");
  }
  if (format2 in knownFormats) {
    return knownFormats[format2];
  }
  var separators = format2.split(reFormatTokens);
  var parts = format2.match(new RegExp(reFormatTokens, "g"));
  if (separators.length === 0 || !parts) {
    throw new Error("Invalid date format.");
  }
  var partFormatters = parts.map(function(token) {
    return formatFns[token];
  });
  var partParserKeys = Object.keys(parseFns).reduce(function(keys, key) {
    var token = parts.find(function(part) {
      return part[0] !== "D" && part[0].toLowerCase() === key;
    });
    if (token) {
      keys.push(key);
    }
    return keys;
  }, []);
  return knownFormats[format2] = {
    parser: function parser(dateStr, locale) {
      var dateParts = dateStr.split(reNonDateParts).reduce(function(dtParts, part, index) {
        if (part.length > 0 && parts[index]) {
          var token = parts[index][0];
          if (token === "M") {
            dtParts.m = part;
          } else if (token !== "D") {
            dtParts[token] = part;
          }
        }
        return dtParts;
      }, {});
      return partParserKeys.reduce(function(origDate, key) {
        var newDate = parseFns[key](origDate, dateParts[key], locale);
        return isNaN(newDate) ? origDate : newDate;
      }, today());
    },
    formatter: function formatter(date, locale) {
      var dateStr = partFormatters.reduce(function(str, fn2, index) {
        return str += "".concat(separators[index]).concat(fn2(date, locale));
      }, "");
      return dateStr += lastItemOf(separators);
    }
  };
}
function parseDate(dateStr, format2, locale) {
  if (dateStr instanceof Date || typeof dateStr === "number") {
    var date = stripTime(dateStr);
    return isNaN(date) ? void 0 : date;
  }
  if (!dateStr) {
    return void 0;
  }
  if (dateStr === "today") {
    return today();
  }
  if (format2 && format2.toValue) {
    var _date = format2.toValue(dateStr, format2, locale);
    return isNaN(_date) ? void 0 : stripTime(_date);
  }
  return parseFormatString(format2).parser(dateStr, locale);
}
function formatDate(date, format2, locale) {
  if (isNaN(date) || !date && date !== 0) {
    return "";
  }
  var dateObj = typeof date === "number" ? new Date(date) : date;
  if (format2.toDisplay) {
    return format2.toDisplay(dateObj, format2, locale);
  }
  return parseFormatString(format2).formatter(dateObj, locale);
}
var listenerRegistry = /* @__PURE__ */ new WeakMap();
var _EventTarget$prototyp = EventTarget.prototype, addEventListener = _EventTarget$prototyp.addEventListener, removeEventListener = _EventTarget$prototyp.removeEventListener;
function registerListeners(keyObj, listeners) {
  var registered = listenerRegistry.get(keyObj);
  if (!registered) {
    registered = [];
    listenerRegistry.set(keyObj, registered);
  }
  listeners.forEach(function(listener) {
    addEventListener.call.apply(addEventListener, _toConsumableArray(listener));
    registered.push(listener);
  });
}
function unregisterListeners(keyObj) {
  var listeners = listenerRegistry.get(keyObj);
  if (!listeners) {
    return;
  }
  listeners.forEach(function(listener) {
    removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));
  });
  listenerRegistry["delete"](keyObj);
}
if (!Event.prototype.composedPath) {
  var getComposedPath = function getComposedPath2(node) {
    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    path.push(node);
    var parent;
    if (node.parentNode) {
      parent = node.parentNode;
    } else if (node.host) {
      parent = node.host;
    } else if (node.defaultView) {
      parent = node.defaultView;
    }
    return parent ? getComposedPath2(parent, path) : path;
  };
  Event.prototype.composedPath = function() {
    return getComposedPath(this.target);
  };
}
function findFromPath(path, criteria, currentTarget) {
  var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var el = path[index];
  if (criteria(el)) {
    return el;
  } else if (el === currentTarget || !el.parentElement) {
    return;
  }
  return findFromPath(path, criteria, currentTarget, index + 1);
}
function findElementInEventPath(ev, selector) {
  var criteria = typeof selector === "function" ? selector : function(el) {
    return el.matches(selector);
  };
  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
}
var locales = {
  en: {
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    today: "Today",
    clear: "Clear",
    titleFormat: "MM y"
  }
};
var defaultOptions = {
  autohide: false,
  beforeShowDay: null,
  beforeShowDecade: null,
  beforeShowMonth: null,
  beforeShowYear: null,
  calendarWeeks: false,
  clearBtn: false,
  dateDelimiter: ",",
  datesDisabled: [],
  daysOfWeekDisabled: [],
  daysOfWeekHighlighted: [],
  defaultViewDate: void 0,
  // placeholder, defaults to today() by the program
  disableTouchKeyboard: false,
  format: "mm/dd/yyyy",
  language: "en",
  maxDate: null,
  maxNumberOfDates: 1,
  maxView: 3,
  minDate: null,
  nextArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9"/></svg>',
  orientation: "auto",
  pickLevel: 0,
  prevArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5H1m0 0 4 4M1 5l4-4"/></svg>',
  showDaysOfWeek: true,
  showOnClick: true,
  showOnFocus: true,
  startView: 0,
  title: "",
  todayBtn: false,
  todayBtnMode: 0,
  todayHighlight: false,
  updateOnBlur: true,
  weekStart: 0
};
var range = null;
function parseHTML(html) {
  if (range == null) {
    range = document.createRange();
  }
  return range.createContextualFragment(html);
}
function hideElement(el) {
  if (el.style.display === "none") {
    return;
  }
  if (el.style.display) {
    el.dataset.styleDisplay = el.style.display;
  }
  el.style.display = "none";
}
function showElement(el) {
  if (el.style.display !== "none") {
    return;
  }
  if (el.dataset.styleDisplay) {
    el.style.display = el.dataset.styleDisplay;
    delete el.dataset.styleDisplay;
  } else {
    el.style.display = "";
  }
}
function emptyChildNodes(el) {
  if (el.firstChild) {
    el.removeChild(el.firstChild);
    emptyChildNodes(el);
  }
}
function replaceChildNodes(el, newChildNodes) {
  emptyChildNodes(el);
  if (newChildNodes instanceof DocumentFragment) {
    el.appendChild(newChildNodes);
  } else if (typeof newChildNodes === "string") {
    el.appendChild(parseHTML(newChildNodes));
  } else if (typeof newChildNodes.forEach === "function") {
    newChildNodes.forEach(function(node) {
      el.appendChild(node);
    });
  }
}
var defaultLang = defaultOptions.language, defaultFormat = defaultOptions.format, defaultWeekStart = defaultOptions.weekStart;
function sanitizeDOW(dow, day) {
  return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
}
function calcEndOfWeek(startOfWeek) {
  return (startOfWeek + 6) % 7;
}
function validateDate(value, format2, locale, origValue) {
  var date = parseDate(value, format2, locale);
  return date !== void 0 ? date : origValue;
}
function validateViewId(value, origValue) {
  var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
  var viewId = parseInt(value, 10);
  return viewId >= 0 && viewId <= max2 ? viewId : origValue;
}
function processOptions(options, datepicker) {
  var inOpts = Object.assign({}, options);
  var config = {};
  var locales2 = datepicker.constructor.locales;
  var _ref = datepicker.config || {}, format2 = _ref.format, language = _ref.language, locale = _ref.locale, maxDate = _ref.maxDate, maxView = _ref.maxView, minDate = _ref.minDate, pickLevel = _ref.pickLevel, startView = _ref.startView, weekStart = _ref.weekStart;
  if (inOpts.language) {
    var lang;
    if (inOpts.language !== language) {
      if (locales2[inOpts.language]) {
        lang = inOpts.language;
      } else {
        lang = inOpts.language.split("-")[0];
        if (locales2[lang] === void 0) {
          lang = false;
        }
      }
    }
    delete inOpts.language;
    if (lang) {
      language = config.language = lang;
      var origLocale = locale || locales2[defaultLang];
      locale = Object.assign({
        format: defaultFormat,
        weekStart: defaultWeekStart
      }, locales2[defaultLang]);
      if (language !== defaultLang) {
        Object.assign(locale, locales2[language]);
      }
      config.locale = locale;
      if (format2 === origLocale.format) {
        format2 = config.format = locale.format;
      }
      if (weekStart === origLocale.weekStart) {
        weekStart = config.weekStart = locale.weekStart;
        config.weekEnd = calcEndOfWeek(locale.weekStart);
      }
    }
  }
  if (inOpts.format) {
    var hasToDisplay = typeof inOpts.format.toDisplay === "function";
    var hasToValue = typeof inOpts.format.toValue === "function";
    var validFormatString = reFormatTokens.test(inOpts.format);
    if (hasToDisplay && hasToValue || validFormatString) {
      format2 = config.format = inOpts.format;
    }
    delete inOpts.format;
  }
  var minDt = minDate;
  var maxDt = maxDate;
  if (inOpts.minDate !== void 0) {
    minDt = inOpts.minDate === null ? dateValue(0, 0, 1) : validateDate(inOpts.minDate, format2, locale, minDt);
    delete inOpts.minDate;
  }
  if (inOpts.maxDate !== void 0) {
    maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format2, locale, maxDt);
    delete inOpts.maxDate;
  }
  if (maxDt < minDt) {
    minDate = config.minDate = maxDt;
    maxDate = config.maxDate = minDt;
  } else {
    if (minDate !== minDt) {
      minDate = config.minDate = minDt;
    }
    if (maxDate !== maxDt) {
      maxDate = config.maxDate = maxDt;
    }
  }
  if (inOpts.datesDisabled) {
    config.datesDisabled = inOpts.datesDisabled.reduce(function(dates, dt) {
      var date = parseDate(dt, format2, locale);
      return date !== void 0 ? pushUnique(dates, date) : dates;
    }, []);
    delete inOpts.datesDisabled;
  }
  if (inOpts.defaultViewDate !== void 0) {
    var viewDate = parseDate(inOpts.defaultViewDate, format2, locale);
    if (viewDate !== void 0) {
      config.defaultViewDate = viewDate;
    }
    delete inOpts.defaultViewDate;
  }
  if (inOpts.weekStart !== void 0) {
    var wkStart = Number(inOpts.weekStart) % 7;
    if (!isNaN(wkStart)) {
      weekStart = config.weekStart = wkStart;
      config.weekEnd = calcEndOfWeek(wkStart);
    }
    delete inOpts.weekStart;
  }
  if (inOpts.daysOfWeekDisabled) {
    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekDisabled;
  }
  if (inOpts.daysOfWeekHighlighted) {
    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekHighlighted;
  }
  if (inOpts.maxNumberOfDates !== void 0) {
    var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
    if (maxNumberOfDates >= 0) {
      config.maxNumberOfDates = maxNumberOfDates;
      config.multidate = maxNumberOfDates !== 1;
    }
    delete inOpts.maxNumberOfDates;
  }
  if (inOpts.dateDelimiter) {
    config.dateDelimiter = String(inOpts.dateDelimiter);
    delete inOpts.dateDelimiter;
  }
  var newPickLevel = pickLevel;
  if (inOpts.pickLevel !== void 0) {
    newPickLevel = validateViewId(inOpts.pickLevel, 2);
    delete inOpts.pickLevel;
  }
  if (newPickLevel !== pickLevel) {
    pickLevel = config.pickLevel = newPickLevel;
  }
  var newMaxView = maxView;
  if (inOpts.maxView !== void 0) {
    newMaxView = validateViewId(inOpts.maxView, maxView);
    delete inOpts.maxView;
  }
  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
  if (newMaxView !== maxView) {
    maxView = config.maxView = newMaxView;
  }
  var newStartView = startView;
  if (inOpts.startView !== void 0) {
    newStartView = validateViewId(inOpts.startView, newStartView);
    delete inOpts.startView;
  }
  if (newStartView < pickLevel) {
    newStartView = pickLevel;
  } else if (newStartView > maxView) {
    newStartView = maxView;
  }
  if (newStartView !== startView) {
    config.startView = newStartView;
  }
  if (inOpts.prevArrow) {
    var prevArrow = parseHTML(inOpts.prevArrow);
    if (prevArrow.childNodes.length > 0) {
      config.prevArrow = prevArrow.childNodes;
    }
    delete inOpts.prevArrow;
  }
  if (inOpts.nextArrow) {
    var nextArrow = parseHTML(inOpts.nextArrow);
    if (nextArrow.childNodes.length > 0) {
      config.nextArrow = nextArrow.childNodes;
    }
    delete inOpts.nextArrow;
  }
  if (inOpts.disableTouchKeyboard !== void 0) {
    config.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
    delete inOpts.disableTouchKeyboard;
  }
  if (inOpts.orientation) {
    var orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
    config.orientation = {
      x: orientation.find(function(x) {
        return x === "left" || x === "right";
      }) || "auto",
      y: orientation.find(function(y3) {
        return y3 === "top" || y3 === "bottom";
      }) || "auto"
    };
    delete inOpts.orientation;
  }
  if (inOpts.todayBtnMode !== void 0) {
    switch (inOpts.todayBtnMode) {
      case 0:
      case 1:
        config.todayBtnMode = inOpts.todayBtnMode;
    }
    delete inOpts.todayBtnMode;
  }
  Object.keys(inOpts).forEach(function(key) {
    if (inOpts[key] !== void 0 && hasProperty(defaultOptions, key)) {
      config[key] = inOpts[key];
    }
  });
  return config;
}
var pickerTemplate = optimizeTemplateHTML('<div class="datepicker hidden">\n  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">\n    <div class="datepicker-header">\n      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>\n      <div class="datepicker-controls flex justify-between mb-2">\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>\n        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main p-1"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2">\n        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n      </div>\n    </div>\n  </div>\n</div>');
var daysTemplate = optimizeTemplateHTML('<div class="days">\n  <div class="days-of-week grid grid-cols-7 mb-1">'.concat(createTagRepeat("span", 7, {
  "class": "dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
}), '</div>\n  <div class="datepicker-grid w-64 grid grid-cols-7">').concat(createTagRepeat("span", 42, {
  "class": "block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"
}), "</div>\n</div>"));
var calendarWeeksTemplate = optimizeTemplateHTML('<div class="calendar-weeks">\n  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>\n  <div class="weeks">'.concat(createTagRepeat("span", 6, {
  "class": "week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
}), "</div>\n</div>"));
var View = /* @__PURE__ */ (function() {
  function View2(picker, config) {
    _classCallCheck(this, View2);
    Object.assign(this, config, {
      picker,
      element: parseHTML('<div class="datepicker-view flex"></div>').firstChild,
      selected: []
    });
    this.init(this.picker.datepicker.config);
  }
  return _createClass(View2, [{
    key: "init",
    value: function init(options) {
      if (options.pickLevel !== void 0) {
        this.isMinView = this.id === options.pickLevel;
      }
      this.setOptions(options);
      this.updateFocus();
      this.updateSelection();
    }
    // Execute beforeShow() callback and apply the result to the element
    // args:
    // - current - current value on the iteration on view rendering
    // - timeValue - time value of the date to pass to beforeShow()
  }, {
    key: "performBeforeHook",
    value: function performBeforeHook(el, current, timeValue) {
      var result = this.beforeShow(new Date(timeValue));
      switch (_typeof(result)) {
        case "boolean":
          result = {
            enabled: result
          };
          break;
        case "string":
          result = {
            classes: result
          };
      }
      if (result) {
        if (result.enabled === false) {
          el.classList.add("disabled");
          pushUnique(this.disabled, current);
        }
        if (result.classes) {
          var _el$classList;
          var extraClasses = result.classes.split(/\s+/);
          (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));
          if (extraClasses.includes("disabled")) {
            pushUnique(this.disabled, current);
          }
        }
        if (result.content) {
          replaceChildNodes(el, result.content);
        }
      }
    }
  }]);
})();
var DaysView = /* @__PURE__ */ (function(_View) {
  function DaysView2(picker) {
    _classCallCheck(this, DaysView2);
    return _callSuper(this, DaysView2, [picker, {
      id: 0,
      name: "days",
      cellClass: "day"
    }]);
  }
  _inherits(DaysView2, _View);
  return _createClass(DaysView2, [{
    key: "init",
    value: function init(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        var inner = parseHTML(daysTemplate).firstChild;
        this.dow = inner.firstChild;
        this.grid = inner.lastChild;
        this.element.appendChild(inner);
      }
      _get(_getPrototypeOf(DaysView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this = this;
      var updateDOW;
      if (hasProperty(options, "minDate")) {
        this.minDate = options.minDate;
      }
      if (hasProperty(options, "maxDate")) {
        this.maxDate = options.maxDate;
      }
      if (options.datesDisabled) {
        this.datesDisabled = options.datesDisabled;
      }
      if (options.daysOfWeekDisabled) {
        this.daysOfWeekDisabled = options.daysOfWeekDisabled;
        updateDOW = true;
      }
      if (options.daysOfWeekHighlighted) {
        this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
      }
      if (options.todayHighlight !== void 0) {
        this.todayHighlight = options.todayHighlight;
      }
      if (options.weekStart !== void 0) {
        this.weekStart = options.weekStart;
        this.weekEnd = options.weekEnd;
        updateDOW = true;
      }
      if (options.locale) {
        var locale = this.locale = options.locale;
        this.dayNames = locale.daysMin;
        this.switchLabelFormat = locale.titleFormat;
        updateDOW = true;
      }
      if (options.beforeShowDay !== void 0) {
        this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
      }
      if (options.calendarWeeks !== void 0) {
        if (options.calendarWeeks && !this.calendarWeeks) {
          var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;
          this.calendarWeeks = {
            element: weeksElem,
            dow: weeksElem.firstChild,
            weeks: weeksElem.lastChild
          };
          this.element.insertBefore(weeksElem, this.element.firstChild);
        } else if (this.calendarWeeks && !options.calendarWeeks) {
          this.element.removeChild(this.calendarWeeks.element);
          this.calendarWeeks = null;
        }
      }
      if (options.showDaysOfWeek !== void 0) {
        if (options.showDaysOfWeek) {
          showElement(this.dow);
          if (this.calendarWeeks) {
            showElement(this.calendarWeeks.dow);
          }
        } else {
          hideElement(this.dow);
          if (this.calendarWeeks) {
            hideElement(this.calendarWeeks.dow);
          }
        }
      }
      if (updateDOW) {
        Array.from(this.dow.children).forEach(function(el, index) {
          var dow = (_this.weekStart + index) % 7;
          el.textContent = _this.dayNames[dow];
          el.className = _this.daysOfWeekDisabled.includes(dow) ? "dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed" : "dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400";
        });
      }
    }
    // Apply update on the focused date to view's settings
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      var viewYear = viewDate.getFullYear();
      var viewMonth = viewDate.getMonth();
      var firstOfMonth = dateValue(viewYear, viewMonth, 1);
      var start2 = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
      this.first = firstOfMonth;
      this.last = dateValue(viewYear, viewMonth + 1, 0);
      this.start = start2;
      this.focused = this.picker.viewDate;
    }
    // Apply update on the selected dates to view's settings
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates;
      if (rangepicker) {
        this.range = rangepicker.dates;
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      this.today = this.todayHighlight ? today() : void 0;
      this.disabled = _toConsumableArray(this.datesDisabled);
      var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);
      this.picker.setViewSwitchLabel(switchLabel);
      this.picker.setPrevBtnDisabled(this.first <= this.minDate);
      this.picker.setNextBtnDisabled(this.last >= this.maxDate);
      if (this.calendarWeeks) {
        var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);
        Array.from(this.calendarWeeks.weeks.children).forEach(function(el, index) {
          el.textContent = getWeek(addWeeks(startOfWeek, index));
        });
      }
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var current = addDays(_this2.start, index);
        var date = new Date(current);
        var day = date.getDay();
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
        el.dataset.date = current;
        el.textContent = date.getDate();
        if (current < _this2.first) {
          classList.add("prev", "text-gray-500", "dark:text-white");
        } else if (current > _this2.last) {
          classList.add("next", "text-gray-500", "dark:text-white");
        }
        if (_this2.today === current) {
          classList.add("today", "bg-gray-100", "dark:bg-gray-600");
        }
        if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {
          classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
          classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
        }
        if (_this2.daysOfWeekDisabled.includes(day)) {
          classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
          classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
          pushUnique(_this2.disabled, current);
        }
        if (_this2.daysOfWeekHighlighted.includes(day)) {
          classList.add("highlighted");
        }
        if (_this2.range) {
          var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range", "bg-gray-200", "dark:bg-gray-600");
            classList.remove("rounded-lg", "rounded-l-lg", "rounded-r-lg");
          }
          if (current === rangeStart) {
            classList.add("range-start", "bg-gray-100", "dark:bg-gray-600", "rounded-l-lg");
            classList.remove("rounded-lg", "rounded-r-lg");
          }
          if (current === rangeEnd) {
            classList.add("range-end", "bg-gray-100", "dark:bg-gray-600", "rounded-r-lg");
            classList.remove("rounded-lg", "rounded-l-lg");
          }
        }
        if (_this2.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "text-gray-500", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "dark:bg-gray-600", "bg-gray-100", "bg-gray-200");
        }
        if (current === _this2.focused) {
          classList.add("focused");
        }
        if (_this2.beforeShow) {
          _this2.performBeforeHook(el, current, current);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;
      var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white", "focused");
        el.classList.add("text-gray-900", "rounded-lg", "dark:text-white");
      });
      Array.from(this.grid.children).forEach(function(el) {
        var current = Number(el.dataset.date);
        var classList = el.classList;
        classList.remove("bg-gray-200", "dark:bg-gray-600", "rounded-l-lg", "rounded-r-lg");
        if (current > rangeStart && current < rangeEnd) {
          classList.add("range", "bg-gray-200", "dark:bg-gray-600");
          classList.remove("rounded-lg");
        }
        if (current === rangeStart) {
          classList.add("range-start", "bg-gray-200", "dark:bg-gray-600", "rounded-l-lg");
          classList.remove("rounded-lg");
        }
        if (current === rangeEnd) {
          classList.add("range-end", "bg-gray-200", "dark:bg-gray-600", "rounded-r-lg");
          classList.remove("rounded-lg");
        }
        if (_this3.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "bg-gray-100", "bg-gray-200", "dark:bg-gray-600");
        }
        if (current === _this3.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      var index = Math.round((this.focused - this.start) / 864e5);
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[index].classList.add("focused");
    }
  }]);
})(View);
function computeMonthRange(range2, thisYear) {
  if (!range2 || !range2[0] || !range2[1]) {
    return;
  }
  var _range = _slicedToArray(range2, 2), _range$ = _slicedToArray(_range[0], 2), startY = _range$[0], startM = _range$[1], _range$2 = _slicedToArray(_range[1], 2), endY = _range$2[0], endM = _range$2[1];
  if (startY > thisYear || endY < thisYear) {
    return;
  }
  return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];
}
var MonthsView = /* @__PURE__ */ (function(_View) {
  function MonthsView2(picker) {
    _classCallCheck(this, MonthsView2);
    return _callSuper(this, MonthsView2, [picker, {
      id: 1,
      name: "months",
      cellClass: "month"
    }]);
  }
  _inherits(MonthsView2, _View);
  return _createClass(MonthsView2, [{
    key: "init",
    value: function init(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        this.grid = this.element;
        this.element.classList.add("months", "datepicker-grid", "w-64", "grid", "grid-cols-4");
        this.grid.appendChild(parseHTML(createTagRepeat("span", 12, {
          "data-month": function dataMonth(ix) {
            return ix;
          }
        })));
      }
      _get(_getPrototypeOf(MonthsView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options.locale) {
        this.monthNames = options.locale.monthsShort;
      }
      if (hasProperty(options, "minDate")) {
        if (options.minDate === void 0) {
          this.minYear = this.minMonth = this.minDate = void 0;
        } else {
          var minDateObj = new Date(options.minDate);
          this.minYear = minDateObj.getFullYear();
          this.minMonth = minDateObj.getMonth();
          this.minDate = minDateObj.setDate(1);
        }
      }
      if (hasProperty(options, "maxDate")) {
        if (options.maxDate === void 0) {
          this.maxYear = this.maxMonth = this.maxDate = void 0;
        } else {
          var maxDateObj = new Date(options.maxDate);
          this.maxYear = maxDateObj.getFullYear();
          this.maxMonth = maxDateObj.getMonth();
          this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
        }
      }
      if (options.beforeShowMonth !== void 0) {
        this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
      }
    }
    // Update view's settings to reflect the viewDate set on the picker
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      this.year = viewDate.getFullYear();
      this.focused = viewDate.getMonth();
    }
    // Update view's settings to reflect the selected dates
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates.reduce(function(selected, timeValue) {
        var date = new Date(timeValue);
        var year = date.getFullYear();
        var month = date.getMonth();
        if (selected[year] === void 0) {
          selected[year] = [month];
        } else {
          pushUnique(selected[year], month);
        }
        return selected;
      }, {});
      if (rangepicker && rangepicker.dates) {
        this.range = rangepicker.dates.map(function(timeValue) {
          var date = new Date(timeValue);
          return isNaN(date) ? void 0 : [date.getFullYear(), date.getMonth()];
        });
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render() {
      var _this = this;
      this.disabled = [];
      this.picker.setViewSwitchLabel(this.year);
      this.picker.setPrevBtnDisabled(this.year <= this.minYear);
      this.picker.setNextBtnDisabled(this.year >= this.maxYear);
      var selected = this.selected[this.year] || [];
      var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
      var isMinYear = this.year === this.minYear;
      var isMaxYear = this.year === this.maxYear;
      var range2 = computeMonthRange(this.range, this.year);
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var date = dateValue(_this.year, index, 1);
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this.cellClass);
        if (_this.isMinView) {
          el.dataset.date = date;
        }
        el.textContent = _this.monthNames[index];
        if (yrOutOfRange || isMinYear && index < _this.minMonth || isMaxYear && index > _this.maxMonth) {
          classList.add("disabled");
        }
        if (range2) {
          var _range2 = _slicedToArray(range2, 2), rangeStart = _range2[0], rangeEnd = _range2[1];
          if (index > rangeStart && index < rangeEnd) {
            classList.add("range");
          }
          if (index === rangeStart) {
            classList.add("range-start");
          }
          if (index === rangeEnd) {
            classList.add("range-end");
          }
        }
        if (selected.includes(index)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (index === _this.focused) {
          classList.add("focused");
        }
        if (_this.beforeShow) {
          _this.performBeforeHook(el, index, date);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this2 = this;
      var selected = this.selected[this.year] || [];
      var _ref = computeMonthRange(this.range, this.year) || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "dark:bg-blue-600", "dark:!bg-primary-700", "dark:text-white", "text-white", "focused");
        el.classList.add("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
      });
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        if (index > rangeStart && index < rangeEnd) {
          classList.add("range");
        }
        if (index === rangeStart) {
          classList.add("range-start");
        }
        if (index === rangeEnd) {
          classList.add("range-end");
        }
        if (selected.includes(index)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (index === _this2.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[this.focused].classList.add("focused");
    }
  }]);
})(View);
function toTitleCase(word) {
  return _toConsumableArray(word).reduce(function(str, ch, ix) {
    return str += ix ? ch : ch.toUpperCase();
  }, "");
}
var YearsView = /* @__PURE__ */ (function(_View) {
  function YearsView2(picker, config) {
    _classCallCheck(this, YearsView2);
    return _callSuper(this, YearsView2, [picker, config]);
  }
  _inherits(YearsView2, _View);
  return _createClass(YearsView2, [{
    key: "init",
    value: function init(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        this.navStep = this.step * 10;
        this.beforeShowOption = "beforeShow".concat(toTitleCase(this.cellClass));
        this.grid = this.element;
        this.element.classList.add(this.name, "datepicker-grid", "w-64", "grid", "grid-cols-4");
        this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
      }
      _get(_getPrototypeOf(YearsView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (hasProperty(options, "minDate")) {
        if (options.minDate === void 0) {
          this.minYear = this.minDate = void 0;
        } else {
          this.minYear = startOfYearPeriod(options.minDate, this.step);
          this.minDate = dateValue(this.minYear, 0, 1);
        }
      }
      if (hasProperty(options, "maxDate")) {
        if (options.maxDate === void 0) {
          this.maxYear = this.maxDate = void 0;
        } else {
          this.maxYear = startOfYearPeriod(options.maxDate, this.step);
          this.maxDate = dateValue(this.maxYear, 11, 31);
        }
      }
      if (options[this.beforeShowOption] !== void 0) {
        var beforeShow = options[this.beforeShowOption];
        this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
      }
    }
    // Update view's settings to reflect the viewDate set on the picker
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      var first = startOfYearPeriod(viewDate, this.navStep);
      var last = first + 9 * this.step;
      this.first = first;
      this.last = last;
      this.start = first - this.step;
      this.focused = startOfYearPeriod(viewDate, this.step);
    }
    // Update view's settings to reflect the selected dates
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this = this;
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates.reduce(function(years, timeValue) {
        return pushUnique(years, startOfYearPeriod(timeValue, _this.step));
      }, []);
      if (rangepicker && rangepicker.dates) {
        this.range = rangepicker.dates.map(function(timeValue) {
          if (timeValue !== void 0) {
            return startOfYearPeriod(timeValue, _this.step);
          }
        });
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      this.disabled = [];
      this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last));
      this.picker.setPrevBtnDisabled(this.first <= this.minYear);
      this.picker.setNextBtnDisabled(this.last >= this.maxYear);
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var current = _this2.start + index * _this2.step;
        var date = dateValue(current, 0, 1);
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
        if (_this2.isMinView) {
          el.dataset.date = date;
        }
        el.textContent = el.dataset.year = current;
        if (index === 0) {
          classList.add("prev");
        } else if (index === 11) {
          classList.add("next");
        }
        if (current < _this2.minYear || current > _this2.maxYear) {
          classList.add("disabled");
        }
        if (_this2.range) {
          var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range");
          }
          if (current === rangeStart) {
            classList.add("range-start");
          }
          if (current === rangeEnd) {
            classList.add("range-end");
          }
        }
        if (_this2.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (current === _this2.focused) {
          classList.add("focused");
        }
        if (_this2.beforeShow) {
          _this2.performBeforeHook(el, current, date);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;
      var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark!bg-primary-600", "dark:text-white", "focused");
      });
      Array.from(this.grid.children).forEach(function(el) {
        var current = Number(el.textContent);
        var classList = el.classList;
        if (current > rangeStart && current < rangeEnd) {
          classList.add("range");
        }
        if (current === rangeStart) {
          classList.add("range-start");
        }
        if (current === rangeEnd) {
          classList.add("range-end");
        }
        if (_this3.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (current === _this3.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      var index = Math.round((this.focused - this.start) / this.step);
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[index].classList.add("focused");
    }
  }]);
})(View);
function triggerDatepickerEvent(datepicker, type) {
  var detail = {
    date: datepicker.getDate(),
    viewDate: new Date(datepicker.picker.viewDate),
    viewId: datepicker.picker.currentView.id,
    datepicker
  };
  datepicker.element.dispatchEvent(new CustomEvent(type, {
    detail
  }));
}
function goToPrevOrNext(datepicker, direction) {
  var _datepicker$config = datepicker.config, minDate = _datepicker$config.minDate, maxDate = _datepicker$config.maxDate;
  var _datepicker$picker = datepicker.picker, currentView = _datepicker$picker.currentView, viewDate = _datepicker$picker.viewDate;
  var newViewDate;
  switch (currentView.id) {
    case 0:
      newViewDate = addMonths(viewDate, direction);
      break;
    case 1:
      newViewDate = addYears(viewDate, direction);
      break;
    default:
      newViewDate = addYears(viewDate, direction * currentView.navStep);
  }
  newViewDate = limitToRange(newViewDate, minDate, maxDate);
  datepicker.picker.changeFocus(newViewDate).render();
}
function switchView(datepicker) {
  var viewId = datepicker.picker.currentView.id;
  if (viewId === datepicker.config.maxView) {
    return;
  }
  datepicker.picker.changeView(viewId + 1).render();
}
function unfocus(datepicker) {
  if (datepicker.config.updateOnBlur) {
    datepicker.update({
      autohide: true
    });
  } else {
    datepicker.refresh("input");
    datepicker.hide();
  }
}
function goToSelectedMonthOrYear(datepicker, selection) {
  var picker = datepicker.picker;
  var viewDate = new Date(picker.viewDate);
  var viewId = picker.currentView.id;
  var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
  picker.changeFocus(newDate).changeView(viewId - 1).render();
}
function onClickTodayBtn(datepicker) {
  var picker = datepicker.picker;
  var currentDate = today();
  if (datepicker.config.todayBtnMode === 1) {
    if (datepicker.config.autohide) {
      datepicker.setDate(currentDate);
      return;
    }
    datepicker.setDate(currentDate, {
      render: false
    });
    picker.update();
  }
  if (picker.viewDate !== currentDate) {
    picker.changeFocus(currentDate);
  }
  picker.changeView(0).render();
}
function onClickClearBtn(datepicker) {
  datepicker.setDate({
    clear: true
  });
}
function onClickViewSwitch(datepicker) {
  switchView(datepicker);
}
function onClickPrevBtn(datepicker) {
  goToPrevOrNext(datepicker, -1);
}
function onClickNextBtn(datepicker) {
  goToPrevOrNext(datepicker, 1);
}
function onClickView(datepicker, ev) {
  var target = findElementInEventPath(ev, ".datepicker-cell");
  if (!target || target.classList.contains("disabled")) {
    return;
  }
  var _datepicker$picker$cu = datepicker.picker.currentView, id2 = _datepicker$picker$cu.id, isMinView = _datepicker$picker$cu.isMinView;
  if (isMinView) {
    datepicker.setDate(Number(target.dataset.date));
  } else if (id2 === 1) {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
  } else {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
  }
}
function onClickPicker(datepicker) {
  if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
    datepicker.inputField.focus();
  }
}
function processPickerOptions(picker, options) {
  if (options.title !== void 0) {
    if (options.title) {
      picker.controls.title.textContent = options.title;
      showElement(picker.controls.title);
    } else {
      picker.controls.title.textContent = "";
      hideElement(picker.controls.title);
    }
  }
  if (options.prevArrow) {
    var prevBtn = picker.controls.prevBtn;
    emptyChildNodes(prevBtn);
    options.prevArrow.forEach(function(node) {
      prevBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.nextArrow) {
    var nextBtn = picker.controls.nextBtn;
    emptyChildNodes(nextBtn);
    options.nextArrow.forEach(function(node) {
      nextBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.locale) {
    picker.controls.todayBtn.textContent = options.locale.today;
    picker.controls.clearBtn.textContent = options.locale.clear;
  }
  if (options.todayBtn !== void 0) {
    if (options.todayBtn) {
      showElement(picker.controls.todayBtn);
    } else {
      hideElement(picker.controls.todayBtn);
    }
  }
  if (hasProperty(options, "minDate") || hasProperty(options, "maxDate")) {
    var _picker$datepicker$co = picker.datepicker.config, minDate = _picker$datepicker$co.minDate, maxDate = _picker$datepicker$co.maxDate;
    picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);
  }
  if (options.clearBtn !== void 0) {
    if (options.clearBtn) {
      showElement(picker.controls.clearBtn);
    } else {
      hideElement(picker.controls.clearBtn);
    }
  }
}
function computeResetViewDate(datepicker) {
  var dates = datepicker.dates, config = datepicker.config;
  var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;
  return limitToRange(viewDate, config.minDate, config.maxDate);
}
function setViewDate(picker, newDate) {
  var oldViewDate = new Date(picker.viewDate);
  var newViewDate = new Date(newDate);
  var _picker$currentView = picker.currentView, id2 = _picker$currentView.id, year = _picker$currentView.year, first = _picker$currentView.first, last = _picker$currentView.last;
  var viewYear = newViewDate.getFullYear();
  picker.viewDate = newDate;
  if (viewYear !== oldViewDate.getFullYear()) {
    triggerDatepickerEvent(picker.datepicker, "changeYear");
  }
  if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
    triggerDatepickerEvent(picker.datepicker, "changeMonth");
  }
  switch (id2) {
    case 0:
      return newDate < first || newDate > last;
    case 1:
      return viewYear !== year;
    default:
      return viewYear < first || viewYear > last;
  }
}
function getTextDirection(el) {
  return window.getComputedStyle(el).direction;
}
var Picker = /* @__PURE__ */ (function() {
  function Picker2(datepicker) {
    _classCallCheck(this, Picker2);
    this.datepicker = datepicker;
    var template2 = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
    var element = this.element = parseHTML(template2).firstChild;
    var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3), header = _element$firstChild$c[0], main2 = _element$firstChild$c[1], footer = _element$firstChild$c[2];
    var title = header.firstElementChild;
    var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3), prevBtn = _header$lastElementCh[0], viewSwitch = _header$lastElementCh[1], nextBtn = _header$lastElementCh[2];
    var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2), todayBtn = _footer$firstChild$ch[0], clearBtn = _footer$firstChild$ch[1];
    var controls = {
      title,
      prevBtn,
      viewSwitch,
      nextBtn,
      todayBtn,
      clearBtn
    };
    this.main = main2;
    this.controls = controls;
    var elementClass = datepicker.inline ? "inline" : "dropdown";
    element.classList.add("datepicker-".concat(elementClass));
    elementClass === "dropdown" ? element.classList.add("dropdown", "absolute", "top-0", "left-0", "z-50", "pt-2") : null;
    processPickerOptions(this, datepicker.config);
    this.viewDate = computeResetViewDate(datepicker);
    registerListeners(datepicker, [[element, "click", onClickPicker.bind(null, datepicker), {
      capture: true
    }], [main2, "click", onClickView.bind(null, datepicker)], [controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, "click", onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, "click", onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, "click", onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, "click", onClickClearBtn.bind(null, datepicker)]]);
    this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {
      id: 2,
      name: "years",
      cellClass: "year",
      step: 1
    }), new YearsView(this, {
      id: 3,
      name: "decades",
      cellClass: "decade",
      step: 10
    })];
    this.currentView = this.views[datepicker.config.startView];
    this.currentView.render();
    this.main.appendChild(this.currentView.element);
    datepicker.config.container.appendChild(this.element);
  }
  return _createClass(Picker2, [{
    key: "setOptions",
    value: function setOptions(options) {
      processPickerOptions(this, options);
      this.views.forEach(function(view) {
        view.init(options, false);
      });
      this.currentView.render();
    }
  }, {
    key: "detach",
    value: function detach() {
      this.datepicker.config.container.removeChild(this.element);
    }
  }, {
    key: "show",
    value: function show() {
      if (this.active) {
        return;
      }
      this.element.classList.add("active", "block");
      this.element.classList.remove("hidden");
      this.active = true;
      var datepicker = this.datepicker;
      if (!datepicker.inline) {
        var inputDirection = getTextDirection(datepicker.inputField);
        if (inputDirection !== getTextDirection(datepicker.config.container)) {
          this.element.dir = inputDirection;
        } else if (this.element.dir) {
          this.element.removeAttribute("dir");
        }
        this.place();
        if (datepicker.config.disableTouchKeyboard) {
          datepicker.inputField.blur();
        }
      }
      triggerDatepickerEvent(datepicker, "show");
    }
  }, {
    key: "hide",
    value: function hide2() {
      if (!this.active) {
        return;
      }
      this.datepicker.exitEditMode();
      this.element.classList.remove("active", "block");
      this.element.classList.add("active", "block", "hidden");
      this.active = false;
      triggerDatepickerEvent(this.datepicker, "hide");
    }
  }, {
    key: "place",
    value: function place() {
      var _this$element = this.element, classList = _this$element.classList, style = _this$element.style;
      var _this$datepicker = this.datepicker, config = _this$datepicker.config, inputField = _this$datepicker.inputField;
      var container = config.container;
      var _this$element$getBoun = this.element.getBoundingClientRect(), calendarWidth = _this$element$getBoun.width, calendarHeight = _this$element$getBoun.height;
      var _container$getBoundin = container.getBoundingClientRect(), containerLeft = _container$getBoundin.left, containerTop = _container$getBoundin.top, containerWidth = _container$getBoundin.width;
      var _inputField$getBoundi = inputField.getBoundingClientRect(), inputLeft = _inputField$getBoundi.left, inputTop = _inputField$getBoundi.top, inputWidth = _inputField$getBoundi.width, inputHeight = _inputField$getBoundi.height;
      var _config$orientation = config.orientation, orientX = _config$orientation.x, orientY = _config$orientation.y;
      var scrollTop;
      var left2;
      var top2;
      if (container === document.body) {
        scrollTop = window.scrollY;
        left2 = inputLeft + window.scrollX;
        top2 = inputTop + scrollTop;
      } else {
        scrollTop = container.scrollTop;
        left2 = inputLeft - containerLeft;
        top2 = inputTop - containerTop + scrollTop;
      }
      if (orientX === "auto") {
        if (left2 < 0) {
          orientX = "left";
          left2 = 10;
        } else if (left2 + calendarWidth > containerWidth) {
          orientX = "right";
        } else {
          orientX = getTextDirection(inputField) === "rtl" ? "right" : "left";
        }
      }
      if (orientX === "right") {
        left2 -= calendarWidth - inputWidth;
      }
      if (orientY === "auto") {
        orientY = top2 - calendarHeight < scrollTop ? "bottom" : "top";
      }
      if (orientY === "top") {
        top2 -= calendarHeight;
      } else {
        top2 += inputHeight;
      }
      classList.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left");
      classList.add("datepicker-orient-".concat(orientY), "datepicker-orient-".concat(orientX));
      style.top = top2 ? "".concat(top2, "px") : top2;
      style.left = left2 ? "".concat(left2, "px") : left2;
    }
  }, {
    key: "setViewSwitchLabel",
    value: function setViewSwitchLabel(labelText) {
      this.controls.viewSwitch.textContent = labelText;
    }
  }, {
    key: "setPrevBtnDisabled",
    value: function setPrevBtnDisabled(disabled) {
      this.controls.prevBtn.disabled = disabled;
    }
  }, {
    key: "setNextBtnDisabled",
    value: function setNextBtnDisabled(disabled) {
      this.controls.nextBtn.disabled = disabled;
    }
  }, {
    key: "changeView",
    value: function changeView(viewId) {
      var oldView = this.currentView;
      var newView = this.views[viewId];
      if (newView.id !== oldView.id) {
        this.currentView = newView;
        this._renderMethod = "render";
        triggerDatepickerEvent(this.datepicker, "changeView");
        this.main.replaceChild(newView.element, oldView.element);
      }
      return this;
    }
    // Change the focused date (view date)
  }, {
    key: "changeFocus",
    value: function changeFocus(newViewDate) {
      this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
      this.views.forEach(function(view) {
        view.updateFocus();
      });
      return this;
    }
    // Apply the change of the selected dates
  }, {
    key: "update",
    value: function update() {
      var newViewDate = computeResetViewDate(this.datepicker);
      this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
      this.views.forEach(function(view) {
        view.updateFocus();
        view.updateSelection();
      });
      return this;
    }
    // Refresh the picker UI
  }, {
    key: "render",
    value: function render() {
      var quickRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var renderMethod = quickRender && this._renderMethod || "render";
      delete this._renderMethod;
      this.currentView[renderMethod]();
    }
  }]);
})();
function findNextAvailableOne(date, addFn, increase, testFn, min2, max2) {
  if (!isInRange(date, min2, max2)) {
    return;
  }
  if (testFn(date)) {
    var newDate = addFn(date, increase);
    return findNextAvailableOne(newDate, addFn, increase, testFn, min2, max2);
  }
  return date;
}
function moveByArrowKey(datepicker, ev, direction, vertical) {
  var picker = datepicker.picker;
  var currentView = picker.currentView;
  var step = currentView.step || 1;
  var viewDate = picker.viewDate;
  var addFn;
  var testFn;
  switch (currentView.id) {
    case 0:
      if (vertical) {
        viewDate = addDays(viewDate, direction * 7);
      } else if (ev.ctrlKey || ev.metaKey) {
        viewDate = addYears(viewDate, direction);
      } else {
        viewDate = addDays(viewDate, direction);
      }
      addFn = addDays;
      testFn = function testFn2(date) {
        return currentView.disabled.includes(date);
      };
      break;
    case 1:
      viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
      addFn = addMonths;
      testFn = function testFn2(date) {
        var dt = new Date(date);
        var year = currentView.year, disabled = currentView.disabled;
        return dt.getFullYear() === year && disabled.includes(dt.getMonth());
      };
      break;
    default:
      viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
      addFn = addYears;
      testFn = function testFn2(date) {
        return currentView.disabled.includes(startOfYearPeriod(date, step));
      };
  }
  viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);
  if (viewDate !== void 0) {
    picker.changeFocus(viewDate).render();
  }
}
function onKeydown(datepicker, ev) {
  if (ev.key === "Tab") {
    unfocus(datepicker);
    return;
  }
  var picker = datepicker.picker;
  var _picker$currentView = picker.currentView, id2 = _picker$currentView.id, isMinView = _picker$currentView.isMinView;
  if (!picker.active) {
    switch (ev.key) {
      case "ArrowDown":
      case "Escape":
        picker.show();
        break;
      case "Enter":
        datepicker.update();
        break;
      default:
        return;
    }
  } else if (datepicker.editMode) {
    switch (ev.key) {
      case "Escape":
        picker.hide();
        break;
      case "Enter":
        datepicker.exitEditMode({
          update: true,
          autohide: datepicker.config.autohide
        });
        break;
      default:
        return;
    }
  } else {
    switch (ev.key) {
      case "Escape":
        picker.hide();
        break;
      case "ArrowLeft":
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, -1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, false);
        }
        break;
      case "ArrowRight":
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, 1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, 1, false);
        }
        break;
      case "ArrowUp":
        if (ev.ctrlKey || ev.metaKey) {
          switchView(datepicker);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, true);
        }
        break;
      case "ArrowDown":
        if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
          return;
        }
        moveByArrowKey(datepicker, ev, 1, true);
        break;
      case "Enter":
        if (isMinView) {
          datepicker.setDate(picker.viewDate);
        } else {
          picker.changeView(id2 - 1).render();
        }
        break;
      case "Backspace":
      case "Delete":
        datepicker.enterEditMode();
        return;
      default:
        if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
        }
        return;
    }
  }
  ev.preventDefault();
  ev.stopPropagation();
}
function onFocus(datepicker) {
  if (datepicker.config.showOnFocus && !datepicker._showing) {
    datepicker.show();
  }
}
function onMousedown(datepicker, ev) {
  var el = ev.target;
  if (datepicker.picker.active || datepicker.config.showOnClick) {
    el._active = el === document.activeElement;
    el._clicking = setTimeout(function() {
      delete el._active;
      delete el._clicking;
    }, 2e3);
  }
}
function onClickInput(datepicker, ev) {
  var el = ev.target;
  if (!el._clicking) {
    return;
  }
  clearTimeout(el._clicking);
  delete el._clicking;
  if (el._active) {
    datepicker.enterEditMode();
  }
  delete el._active;
  if (datepicker.config.showOnClick) {
    datepicker.show();
  }
}
function onPaste(datepicker, ev) {
  if (ev.clipboardData.types.includes("text/plain")) {
    datepicker.enterEditMode();
  }
}
function onClickOutside(datepicker, ev) {
  var element = datepicker.element;
  if (element !== document.activeElement) {
    return;
  }
  var pickerElem = datepicker.picker.element;
  if (findElementInEventPath(ev, function(el) {
    return el === element || el === pickerElem;
  })) {
    return;
  }
  unfocus(datepicker);
}
function stringifyDates(dates, config) {
  return dates.map(function(dt) {
    return formatDate(dt, config.format, config.locale);
  }).join(config.dateDelimiter);
}
function processInputDates(datepicker, inputDates) {
  var clear = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var config = datepicker.config, origDates = datepicker.dates, rangepicker = datepicker.rangepicker;
  if (inputDates.length === 0) {
    return clear ? [] : void 0;
  }
  var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
  var newDates = inputDates.reduce(function(dates, dt) {
    var date = parseDate(dt, config.format, config.locale);
    if (date === void 0) {
      return dates;
    }
    if (config.pickLevel > 0) {
      var _dt = new Date(date);
      if (config.pickLevel === 1) {
        date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);
      } else {
        date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);
      }
    }
    if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {
      dates.push(date);
    }
    return dates;
  }, []);
  if (newDates.length === 0) {
    return;
  }
  if (config.multidate && !clear) {
    newDates = newDates.reduce(function(dates, date) {
      if (!origDates.includes(date)) {
        dates.push(date);
      }
      return dates;
    }, origDates.filter(function(date) {
      return !newDates.includes(date);
    }));
  }
  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;
}
function refreshUI(datepicker) {
  var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  var quickRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var config = datepicker.config, picker = datepicker.picker, inputField = datepicker.inputField;
  if (mode & 2) {
    var newView = picker.active ? config.pickLevel : config.startView;
    picker.update().changeView(newView).render(quickRender);
  }
  if (mode & 1 && inputField) {
    inputField.value = stringifyDates(datepicker.dates, config);
  }
}
function _setDate(datepicker, inputDates, options) {
  var clear = options.clear, render = options.render, autohide = options.autohide;
  if (render === void 0) {
    render = true;
  }
  if (!render) {
    autohide = false;
  } else if (autohide === void 0) {
    autohide = datepicker.config.autohide;
  }
  var newDates = processInputDates(datepicker, inputDates, clear);
  if (!newDates) {
    return;
  }
  if (newDates.toString() !== datepicker.dates.toString()) {
    datepicker.dates = newDates;
    refreshUI(datepicker, render ? 3 : 1);
    triggerDatepickerEvent(datepicker, "changeDate");
  } else {
    refreshUI(datepicker, 1);
  }
  if (autohide) {
    datepicker.hide();
  }
}
var Datepicker$1 = /* @__PURE__ */ (function() {
  function Datepicker2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var rangepicker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    _classCallCheck(this, Datepicker2);
    element.datepicker = this;
    this.element = element;
    var config = this.config = Object.assign({
      buttonClass: options.buttonClass && String(options.buttonClass) || "button",
      container: document.body,
      defaultViewDate: today(),
      maxDate: void 0,
      minDate: void 0
    }, processOptions(defaultOptions, this));
    this._options = options;
    Object.assign(config, processOptions(options, this));
    var inline = this.inline = element.tagName !== "INPUT";
    var inputField;
    var initialDates;
    if (inline) {
      config.container = element;
      initialDates = stringToArray(element.dataset.date, config.dateDelimiter);
      delete element.dataset.date;
    } else {
      var container = options.container ? document.querySelector(options.container) : null;
      if (container) {
        config.container = container;
      }
      inputField = this.inputField = element;
      inputField.classList.add("datepicker-input");
      initialDates = stringToArray(inputField.value, config.dateDelimiter);
    }
    if (rangepicker) {
      var index = rangepicker.inputs.indexOf(inputField);
      var datepickers = rangepicker.datepickers;
      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
        throw Error("Invalid rangepicker object.");
      }
      datepickers[index] = this;
      Object.defineProperty(this, "rangepicker", {
        get: function get() {
          return rangepicker;
        }
      });
    }
    this.dates = [];
    var inputDateValues = processInputDates(this, initialDates);
    if (inputDateValues && inputDateValues.length > 0) {
      this.dates = inputDateValues;
    }
    if (inputField) {
      inputField.value = stringifyDates(this.dates, config);
    }
    var picker = this.picker = new Picker(this);
    if (inline) {
      this.show();
    } else {
      var onMousedownDocument = onClickOutside.bind(null, this);
      var listeners = [[inputField, "keydown", onKeydown.bind(null, this)], [inputField, "focus", onFocus.bind(null, this)], [inputField, "mousedown", onMousedown.bind(null, this)], [inputField, "click", onClickInput.bind(null, this)], [inputField, "paste", onPaste.bind(null, this)], [document, "mousedown", onMousedownDocument], [document, "touchstart", onMousedownDocument], [window, "resize", picker.place.bind(picker)]];
      registerListeners(this, listeners);
    }
  }
  return _createClass(Datepicker2, [{
    key: "active",
    get: (
      /**
       * @type {Boolean} - Whether the picker element is shown. `true` whne shown
       */
      function get() {
        return !!(this.picker && this.picker.active);
      }
    )
    /**
     * @type {HTMLDivElement} - DOM object of picker element
     */
  }, {
    key: "pickerElement",
    get: function get() {
      return this.picker ? this.picker.element : void 0;
    }
    /**
     * Set new values to the config options
     * @param {Object} options - config options to update
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var picker = this.picker;
      var newOptions = processOptions(options, this);
      Object.assign(this._options, options);
      Object.assign(this.config, newOptions);
      picker.setOptions(newOptions);
      refreshUI(this, 3);
    }
    /**
     * Show the picker element
     */
  }, {
    key: "show",
    value: function show() {
      if (this.inputField) {
        if (this.inputField.disabled) {
          return;
        }
        if (this.inputField !== document.activeElement) {
          this._showing = true;
          this.inputField.focus();
          delete this._showing;
        }
      }
      this.picker.show();
    }
    /**
     * Hide the picker element
     * Not available on inline picker
     */
  }, {
    key: "hide",
    value: function hide2() {
      if (this.inline) {
        return;
      }
      this.picker.hide();
      this.picker.update().changeView(this.config.startView).render();
    }
    /**
     * Destroy the Datepicker instance
     * @return {Detepicker} - the instance destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.hide();
      unregisterListeners(this);
      this.picker.detach();
      if (!this.inline) {
        this.inputField.classList.remove("datepicker-input");
      }
      delete this.element.datepicker;
      return this;
    }
    /**
     * Get the selected date(s)
     *
     * The method returns a Date object of selected date by default, and returns
     * an array of selected dates in multidate mode. If format string is passed,
     * it returns date string(s) formatted in given format.
     *
     * @param  {String} [format] - Format string to stringify the date(s)
     * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
     * selected, empty array in multidate mode and untitled in sigledate mode
     */
  }, {
    key: "getDate",
    value: function getDate() {
      var _this = this;
      var format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var callback = format2 ? function(date) {
        return formatDate(date, format2, _this.config.locale);
      } : function(date) {
        return new Date(date);
      };
      if (this.config.multidate) {
        return this.dates.map(callback);
      }
      if (this.dates.length > 0) {
        return callback(this.dates[0]);
      }
    }
    /**
     * Set selected date(s)
     *
     * In multidate mode, you can pass multiple dates as a series of arguments
     * or an array. (Since each date is parsed individually, the type of the
     * dates doesn't have to be the same.)
     * The given dates are used to toggle the select status of each date. The
     * number of selected dates is kept from exceeding the length set to
     * maxNumberOfDates.
     *
     * With clear: true option, the method can be used to clear the selection
     * and to replace the selection instead of toggling in multidate mode.
     * If the option is passed with no date arguments or an empty dates array,
     * it works as "clear" (clear the selection then set nothing), and if the
     * option is passed with new dates to select, it works as "replace" (clear
     * the selection then set the given dates)
     *
     * When render: false option is used, the method omits re-rendering the
     * picker element. In this case, you need to call refresh() method later in
     * order for the picker element to reflect the changes. The input field is
     * refreshed always regardless of this option.
     *
     * When invalid (unparsable, repeated, disabled or out-of-range) dates are
     * passed, the method ignores them and applies only valid ones. In the case
     * that all the given dates are invalid, which is distinguished from passing
     * no dates, the method considers it as an error and leaves the selection
     * untouched.
     *
     * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
     * objects, time values or mix of those for new selection
     * @param {Object} [options] - function options
     * - clear: {boolean} - Whether to clear the existing selection
     *     defualt: false
     * - render: {boolean} - Whether to re-render the picker element
     *     default: true
     * - autohide: {boolean} - Whether to hide the picker element after re-render
     *     Ignored when used with render: false
     *     default: config.autohide
     */
  }, {
    key: "setDate",
    value: function setDate() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var dates = [].concat(args);
      var opts = {};
      var lastArg = lastItemOf(args);
      if (_typeof(lastArg) === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {
        Object.assign(opts, dates.pop());
      }
      var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
      _setDate(this, inputDates, opts);
    }
    /**
     * Update the selected date(s) with input field's value
     * Not available on inline picker
     *
     * The input field will be refreshed with properly formatted date string.
     *
     * @param  {Object} [options] - function options
     * - autohide: {boolean} - whether to hide the picker element after refresh
     *     default: false
     */
  }, {
    key: "update",
    value: function update() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      if (this.inline) {
        return;
      }
      var opts = {
        clear: true,
        autohide: !!(options && options.autohide)
      };
      var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
      _setDate(this, inputDates, opts);
    }
    /**
     * Refresh the picker element and the associated input field
     * @param {String} [target] - target item when refreshing one item only
     * 'picker' or 'input'
     * @param {Boolean} [forceRender] - whether to re-render the picker element
     * regardless of its state instead of optimized refresh
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (target && typeof target !== "string") {
        forceRender = target;
        target = void 0;
      }
      var mode;
      if (target === "picker") {
        mode = 2;
      } else if (target === "input") {
        mode = 1;
      } else {
        mode = 3;
      }
      refreshUI(this, mode, !forceRender);
    }
    /**
     * Enter edit mode
     * Not available on inline picker or when the picker element is hidden
     */
  }, {
    key: "enterEditMode",
    value: function enterEditMode() {
      if (this.inline || !this.picker.active || this.editMode) {
        return;
      }
      this.editMode = true;
      this.inputField.classList.add("in-edit", "border-blue-700", "!border-primary-700");
    }
    /**
     * Exit from edit mode
     * Not available on inline picker
     * @param  {Object} [options] - function options
     * - update: {boolean} - whether to call update() after exiting
     *     If false, input field is revert to the existing selection
     *     default: false
     */
  }, {
    key: "exitEditMode",
    value: function exitEditMode() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      if (this.inline || !this.editMode) {
        return;
      }
      var opts = Object.assign({
        update: false
      }, options);
      delete this.editMode;
      this.inputField.classList.remove("in-edit", "border-blue-700", "!border-primary-700");
      if (opts.update) {
        this.update(opts);
      }
    }
  }], [{
    key: "formatDate",
    value: function formatDate$1(date, format2, lang) {
      return formatDate(date, format2, lang && locales[lang] || locales.en);
    }
    /**
     * Parse date string
     * @param  {String|Date|Number} dateStr - date string, Date object or time
     * value to parse
     * @param  {String|Object} format - format string or object that contains
     * toValue() custom parser, whose signature is
     * - args:
     *   - dateStr: {String|Date|Number} - the dateStr passed to the method
     *   - format: {Object} - the format object passed to the method
     *   - locale: {Object} - locale for the language specified by `lang`
     * - return:
     *     {Date|Number} parsed date or its time value
     * @param  {String} [lang=en] - language code for the locale to use
     * @return {Number} time value of parsed date
     */
  }, {
    key: "parseDate",
    value: function parseDate$1(dateStr, format2, lang) {
      return parseDate(dateStr, format2, lang && locales[lang] || locales.en);
    }
    /**
     * @type {Object} - Installed locales in `[languageCode]: localeObject` format
     * en`:_English (US)_ is pre-installed.
     */
  }, {
    key: "locales",
    get: function get() {
      return locales;
    }
  }]);
})();
function filterOptions(options) {
  var newOpts = Object.assign({}, options);
  delete newOpts.inputs;
  delete newOpts.allowOneSidedRange;
  delete newOpts.maxNumberOfDates;
  return newOpts;
}
function setupDatepicker(rangepicker, changeDateListener, el, options) {
  registerListeners(rangepicker, [[el, "changeDate", changeDateListener]]);
  new Datepicker$1(el, options, rangepicker);
}
function onChangeDate(rangepicker, ev) {
  if (rangepicker._updating) {
    return;
  }
  rangepicker._updating = true;
  var target = ev.target;
  if (target.datepicker === void 0) {
    return;
  }
  var datepickers = rangepicker.datepickers;
  var setDateOptions = {
    render: false
  };
  var changedSide = rangepicker.inputs.indexOf(target);
  var otherSide = changedSide === 0 ? 1 : 0;
  var changedDate = datepickers[changedSide].dates[0];
  var otherDate = datepickers[otherSide].dates[0];
  if (changedDate !== void 0 && otherDate !== void 0) {
    if (changedSide === 0 && changedDate > otherDate) {
      datepickers[0].setDate(otherDate, setDateOptions);
      datepickers[1].setDate(changedDate, setDateOptions);
    } else if (changedSide === 1 && changedDate < otherDate) {
      datepickers[0].setDate(changedDate, setDateOptions);
      datepickers[1].setDate(otherDate, setDateOptions);
    }
  } else if (!rangepicker.allowOneSidedRange) {
    if (changedDate !== void 0 || otherDate !== void 0) {
      setDateOptions.clear = true;
      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
    }
  }
  datepickers[0].picker.update().render();
  datepickers[1].picker.update().render();
  delete rangepicker._updating;
}
var DateRangePicker = /* @__PURE__ */ (function() {
  function DateRangePicker2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, DateRangePicker2);
    var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
    if (inputs.length < 2) {
      return;
    }
    element.rangepicker = this;
    this.element = element;
    this.inputs = inputs.slice(0, 2);
    this.allowOneSidedRange = !!options.allowOneSidedRange;
    var changeDateListener = onChangeDate.bind(null, this);
    var cleanOptions = filterOptions(options);
    var datepickers = [];
    Object.defineProperty(this, "datepickers", {
      get: function get() {
        return datepickers;
      }
    });
    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
    Object.freeze(datepickers);
    if (datepickers[0].dates.length > 0) {
      onChangeDate(this, {
        target: this.inputs[0]
      });
    } else if (datepickers[1].dates.length > 0) {
      onChangeDate(this, {
        target: this.inputs[1]
      });
    }
  }
  return _createClass(DateRangePicker2, [{
    key: "dates",
    get: function get() {
      return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : void 0;
    }
    /**
     * Set new values to the config options
     * @param {Object} options - config options to update
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.allowOneSidedRange = !!options.allowOneSidedRange;
      var cleanOptions = filterOptions(options);
      this.datepickers[0].setOptions(cleanOptions);
      this.datepickers[1].setOptions(cleanOptions);
    }
    /**
     * Destroy the DateRangePicker instance
     * @return {DateRangePicker} - the instance destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.datepickers[0].destroy();
      this.datepickers[1].destroy();
      unregisterListeners(this);
      delete this.element.rangepicker;
    }
    /**
     * Get the start and end dates of the date range
     *
     * The method returns Date objects by default. If format string is passed,
     * it returns date strings formatted in given format.
     * The result array always contains 2 items (start date/end date) and
     * undefined is used for unselected side. (e.g. If none is selected,
     * the result will be [undefined, undefined]. If only the end date is set
     * when allowOneSidedRange config option is true, [undefined, endDate] will
     * be returned.)
     *
     * @param  {String} [format] - Format string to stringify the dates
     * @return {Array} - Start and end dates
     */
  }, {
    key: "getDates",
    value: function getDates() {
      var _this = this;
      var format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var callback = format2 ? function(date) {
        return formatDate(date, format2, _this.datepickers[0].config.locale);
      } : function(date) {
        return new Date(date);
      };
      return this.dates.map(function(date) {
        return date === void 0 ? date : callback(date);
      });
    }
    /**
     * Set the start and end dates of the date range
     *
     * The method calls datepicker.setDate() internally using each of the
     * arguments in startend order.
     *
     * When a clear: true option object is passed instead of a date, the method
     * clears the date.
     *
     * If an invalid date, the same date as the current one or an option object
     * without clear: true is passed, the method considers that argument as an
     * "ineffective" argument because calling datepicker.setDate() with those
     * values makes no changes to the date selection.
     *
     * When the allowOneSidedRange config option is false, passing {clear: true}
     * to clear the range works only when it is done to the last effective
     * argument (in other words, passed to rangeEnd or to rangeStart along with
     * ineffective rangeEnd). This is because when the date range is changed,
     * it gets normalized based on the last change at the end of the changing
     * process.
     *
     * @param {Date|Number|String|Object} rangeStart - Start date of the range
     * or {clear: true} to clear the date
     * @param {Date|Number|String|Object} rangeEnd - End date of the range
     * or {clear: true} to clear the date
     */
  }, {
    key: "setDates",
    value: function setDates(rangeStart, rangeEnd) {
      var _this$datepickers = _slicedToArray(this.datepickers, 2), datepicker0 = _this$datepickers[0], datepicker1 = _this$datepickers[1];
      var origDates = this.dates;
      this._updating = true;
      datepicker0.setDate(rangeStart);
      datepicker1.setDate(rangeEnd);
      delete this._updating;
      if (datepicker1.dates[0] !== origDates[1]) {
        onChangeDate(this, {
          target: this.inputs[1]
        });
      } else if (datepicker0.dates[0] !== origDates[0]) {
        onChangeDate(this, {
          target: this.inputs[0]
        });
      }
    }
  }]);
})();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var Default = {
  defaultDatepickerId: null,
  autohide: false,
  format: "mm/dd/yyyy",
  maxDate: null,
  minDate: null,
  orientation: "bottom",
  buttons: false,
  autoSelectToday: 0,
  title: null,
  language: "en",
  rangePicker: false,
  onShow: function() {
  },
  onHide: function() {
  }
};
var DefaultInstanceOptions = {
  id: null,
  override: true
};
var Datepicker = (
  /** @class */
  (function() {
    function Datepicker2(datepickerEl, options, instanceOptions) {
      if (datepickerEl === void 0) {
        datepickerEl = null;
      }
      if (options === void 0) {
        options = Default;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : datepickerEl.id;
      this._datepickerEl = datepickerEl;
      this._datepickerInstance = null;
      this._options = __assign(__assign({}, Default), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Datepicker", this, this._instanceId, instanceOptions.override);
    }
    Datepicker2.prototype.init = function() {
      if (this._datepickerEl && !this._initialized) {
        if (this._options.rangePicker) {
          this._datepickerInstance = new DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options));
        } else {
          this._datepickerInstance = new Datepicker$1(this._datepickerEl, this._getDatepickerOptions(this._options));
        }
        this._initialized = true;
      }
    };
    Datepicker2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
        this._datepickerInstance.destroy();
      }
    };
    Datepicker2.prototype.removeInstance = function() {
      this.destroy();
      instances.removeInstance("Datepicker", this._instanceId);
    };
    Datepicker2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Datepicker2.prototype.getDatepickerInstance = function() {
      return this._datepickerInstance;
    };
    Datepicker2.prototype.getDate = function() {
      if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
        return this._datepickerInstance.getDates();
      }
      if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
        return this._datepickerInstance.getDate();
      }
    };
    Datepicker2.prototype.setDate = function(date) {
      if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
        return this._datepickerInstance.setDates(date);
      }
      if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
        return this._datepickerInstance.setDate(date);
      }
    };
    Datepicker2.prototype.show = function() {
      this._datepickerInstance.show();
      this._options.onShow(this);
    };
    Datepicker2.prototype.hide = function() {
      this._datepickerInstance.hide();
      this._options.onHide(this);
    };
    Datepicker2.prototype._getDatepickerOptions = function(options) {
      var datepickerOptions = {};
      if (options.buttons) {
        datepickerOptions.todayBtn = true;
        datepickerOptions.clearBtn = true;
        if (options.autoSelectToday) {
          datepickerOptions.todayBtnMode = 1;
        }
      }
      if (options.autohide) {
        datepickerOptions.autohide = true;
      }
      if (options.format) {
        datepickerOptions.format = options.format;
      }
      if (options.maxDate) {
        datepickerOptions.maxDate = options.maxDate;
      }
      if (options.minDate) {
        datepickerOptions.minDate = options.minDate;
      }
      if (options.orientation) {
        datepickerOptions.orientation = options.orientation;
      }
      if (options.title) {
        datepickerOptions.title = options.title;
      }
      if (options.language) {
        datepickerOptions.language = options.language;
      }
      return datepickerOptions;
    };
    Datepicker2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Datepicker2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    return Datepicker2;
  })()
);
function initDatepickers() {
  document.querySelectorAll("[datepicker], [inline-datepicker], [date-rangepicker]").forEach(function($datepickerEl) {
    if ($datepickerEl) {
      var buttons = $datepickerEl.hasAttribute("datepicker-buttons");
      var autoselectToday = $datepickerEl.hasAttribute("datepicker-autoselect-today");
      var autohide = $datepickerEl.hasAttribute("datepicker-autohide");
      var format2 = $datepickerEl.getAttribute("datepicker-format");
      var maxDate = $datepickerEl.getAttribute("datepicker-max-date");
      var minDate = $datepickerEl.getAttribute("datepicker-min-date");
      var orientation_1 = $datepickerEl.getAttribute("datepicker-orientation");
      var title = $datepickerEl.getAttribute("datepicker-title");
      var language = $datepickerEl.getAttribute("datepicker-language");
      var rangePicker = $datepickerEl.hasAttribute("date-rangepicker");
      new Datepicker($datepickerEl, {
        buttons: buttons ? buttons : Default.buttons,
        autoSelectToday: autoselectToday ? autoselectToday : Default.autoSelectToday,
        autohide: autohide ? autohide : Default.autohide,
        format: format2 ? format2 : Default.format,
        maxDate: maxDate ? maxDate : Default.maxDate,
        minDate: minDate ? minDate : Default.minDate,
        orientation: orientation_1 ? orientation_1 : Default.orientation,
        title: title ? title : Default.title,
        language: language ? language : Default.language,
        rangePicker: rangePicker ? rangePicker : Default.rangePicker
      });
    } else {
      console.error("The datepicker element does not exist. Please check the datepicker attribute.");
    }
  });
}
if (typeof window !== "undefined") {
  window.Datepicker = Datepicker;
  window.initDatepickers = initDatepickers;
}
function initFlowbite() {
  initAccordions();
  initCollapses();
  initCarousels();
  initDismisses();
  initDropdowns();
  initModals();
  initDrawers();
  initTabs();
  initTooltips();
  initPopovers();
  initDials();
  initInputCounters();
  initCopyClipboards();
  initDatepickers();
}
if (typeof window !== "undefined") {
  window.initFlowbite = initFlowbite;
}
var events = new Events("load", [
  initAccordions,
  initCollapses,
  initCarousels,
  initDismisses,
  initDropdowns,
  initModals,
  initDrawers,
  initTabs,
  initTooltips,
  initPopovers,
  initDials,
  initInputCounters,
  initCopyClipboards,
  initDatepickers
]);
events.init();
cleanCurrentUrl();
window.addEventListener("popstate", () => {
  cleanCurrentUrl();
});
function getHelpNode(contextEl) {
  const tplHost = contextEl.closest("[data-help-template]");
  const tplId = tplHost?.getAttribute("data-help-template") || contextEl.getAttribute("data-help-template");
  if (tplId) {
    const tpl = document.getElementById(tplId);
    if (tpl && "content" in tpl) {
      const wrapper = document.createElement("div");
      wrapper.appendChild(tpl.content.cloneNode(true));
      return { node: wrapper, id: tplId };
    }
  }
  const textHost = contextEl.closest("[data-help-text]");
  const helpText = textHost?.getAttribute("data-help-text") || contextEl.getAttribute("data-help-text");
  if (helpText) {
    const wrapper = document.createElement("div");
    wrapper.textContent = helpText;
    return {
      node: wrapper,
      id: "help-" + Math.random().toString(36).slice(2)
    };
  }
  return null;
}
function ensureInfoPanelFor(button) {
  const forId = button.getAttribute("data-info-for") || "";
  const trigger = forId ? document.getElementById(forId) : button.previousElementSibling;
  if (!trigger) return null;
  const existingId = button.getAttribute("aria-controls");
  if (existingId) {
    const existingEl = document.getElementById(existingId);
    if (existingEl) return existingEl;
  }
  const helpHost = trigger.closest("[data-help-text], [data-help-template]") || button.closest("[data-help-text], [data-help-template]");
  const help = getHelpNode(trigger) || (helpHost ? getHelpNode(helpHost) : null) || getHelpNode(button) || (button.parentElement ? getHelpNode(button.parentElement) : null);
  if (!help) return null;
  const panel = document.createElement("div");
  const panelId = "info-" + (forId || help.id || Math.random().toString(36).slice(2));
  panel.id = panelId;
  panel.className = "info-panel-base hidden";
  panel.setAttribute("data-info-panel", "");
  panel.appendChild(help.node);
  if (helpHost) {
    helpHost.insertAdjacentElement("afterend", panel);
  } else {
    button.parentElement?.appendChild(panel);
  }
  button.setAttribute("aria-controls", panelId);
  return panel;
}
const TooltipManager = (() => {
  const hoverMql = matchMedia("(any-hover: hover) and (any-pointer: fine)");
  const lgMql = matchMedia("(min-width: 1024px)");
  let enabled = false;
  const instances2 = /* @__PURE__ */ new Map();
  let docClickHandler = null;
  let observer = null;
  const setupTrigger = (trigger) => {
    if (!enabled) return;
    if (instances2.has(trigger)) return;
    let target = null;
    const id2 = trigger.getAttribute("data-tooltip-target");
    if (id2) target = document.getElementById(id2);
    if (!target) {
      const help = getHelpNode(trigger);
      if (!help) return;
      target = document.createElement("div");
      const tipId = "tt-" + help.id;
      target.id = tipId;
      target.setAttribute("role", "tooltip");
      target.className = "tooltip-base tooltip-hidden";
      target.appendChild(help.node);
      trigger.insertAdjacentElement("afterend", target);
      trigger.setAttribute("aria-describedby", tipId);
    }
    const overridePlacement = (trigger.getAttribute("data-tooltip-placement") || trigger.closest("[data-tooltip-placement]")?.getAttribute("data-tooltip-placement") || "").toLowerCase();
    const allowed = { top: true, bottom: true };
    let placement = allowed[overridePlacement] ? overridePlacement : "top";
    try {
      if (!allowed[overridePlacement]) {
        const rect = trigger.getBoundingClientRect();
        const vh = window.innerHeight || document.documentElement.clientHeight;
        const spaceAbove = rect.top;
        const spaceBelow = vh - rect.bottom;
        placement = spaceAbove >= spaceBelow ? "top" : "bottom";
      }
    } catch {
    }
    const resolveIdleMs = () => {
      const findAttr = (node) => node?.getAttribute("data-tooltip-idle") ?? null;
      const raw = findAttr(trigger) || findAttr(trigger.closest("[data-tooltip-idle]")) || findAttr(document.body);
      const n = raw ? parseInt(raw, 10) : NaN;
      return Number.isFinite(n) && n >= 0 ? n : 500;
    };
    const idleMs = resolveIdleMs();
    const TTip = Tooltip;
    const rawTooltip = new TTip(target, trigger, {
      // We will control show/hide manually to enforce the idle (no-move) requirement
      triggerType: "none",
      placement,
      offset: 8,
      // Prefer fixed positioning to avoid clipping within overflow/scroll containers
      // Some Flowbite type bundles may not include "strategy"
      ...{ strategy: "fixed" }
    });
    const t = rawTooltip;
    const clearIdle = (rec2) => {
      if (rec2.idleTimer != null) {
        clearTimeout(rec2.idleTimer);
        rec2.idleTimer = null;
      }
    };
    const rec = {
      tooltip: t,
      targetEl: target,
      clickHide: () => {
        clearIdle(rec);
        try {
          t.hide();
        } catch {
        } finally {
          target.classList.add("tooltip-hidden");
        }
        rec.suppressedUntil = Date.now() + 400;
      },
      idleTimer: null,
      suppressedUntil: 0
    };
    const onEnter = () => {
      if (Date.now() < (rec.suppressedUntil || 0)) return;
      clearIdle(rec);
      rec.idleTimer = window.setTimeout(() => {
        target.classList.remove("tooltip-hidden");
        try {
          t.show();
        } catch {
          target.classList.add("tooltip-hidden");
        }
      }, idleMs);
    };
    const onMove = () => {
      if (Date.now() < (rec.suppressedUntil || 0)) return;
      clearIdle(rec);
      rec.idleTimer = window.setTimeout(() => {
        target.classList.remove("tooltip-hidden");
        try {
          t.show();
        } catch {
          target.classList.add("tooltip-hidden");
        }
      }, idleMs);
    };
    const onLeave = () => {
      clearIdle(rec);
      try {
        t.hide();
      } catch {
      } finally {
        target.classList.add("tooltip-hidden");
      }
    };
    rec.enter = onEnter;
    rec.leave = onLeave;
    rec.move = onMove;
    const clickHide = rec.clickHide;
    trigger.addEventListener("click", clickHide);
    trigger.addEventListener("mouseenter", onEnter);
    trigger.addEventListener("mousemove", onMove);
    trigger.addEventListener("mouseleave", onLeave);
    instances2.set(trigger, rec);
  };
  const initExisting = () => {
    document.querySelectorAll(
      "[data-tooltip-target], [data-help-text], [data-help-template]"
    ).forEach(setupTrigger);
  };
  const attachObserver = () => {
    if (observer) return;
    observer = new MutationObserver((mutations) => {
      for (const m3 of mutations) {
        m3.addedNodes.forEach((node) => {
          if (!(node instanceof HTMLElement)) return;
          if (node.hasAttribute("data-tooltip-target") || node.hasAttribute("data-help-text") || node.hasAttribute("data-help-template"))
            setupTrigger(node);
          node.querySelectorAll?.(
            "[data-tooltip-target], [data-help-text], [data-help-template]"
          ).forEach((el) => {
            if (el instanceof HTMLElement) setupTrigger(el);
          });
        });
      }
    });
    observer.observe(document.body, { childList: true, subtree: true });
  };
  const detachObserver = () => {
    observer?.disconnect();
    observer = null;
  };
  const attachDocClickHandler = () => {
    if (docClickHandler) return;
    docClickHandler = (event) => {
      const target = event.target;
      instances2.forEach((rec, trigger) => {
        if (!trigger.contains(target)) {
          try {
            rec.tooltip.hide?.();
            if (rec.idleTimer != null) {
              clearTimeout(rec.idleTimer);
              rec.idleTimer = null;
            }
          } catch {
          } finally {
            rec.targetEl.classList.add("tooltip-hidden");
          }
        } else {
          rec.clickHide();
        }
      });
    };
    document.addEventListener("click", docClickHandler, { capture: true });
  };
  const detachDocClickHandler = () => {
    if (!docClickHandler) return;
    document.removeEventListener("click", docClickHandler, true);
    docClickHandler = null;
  };
  const enable = () => {
    if (enabled) return;
    enabled = true;
    initExisting();
    attachDocClickHandler();
    attachObserver();
  };
  const disable = () => {
    if (!enabled) return;
    enabled = false;
    instances2.forEach((rec, trigger) => {
      try {
        rec.tooltip.hide?.();
      } catch {
      } finally {
        rec.targetEl.classList.add("tooltip-hidden");
      }
      try {
        rec.tooltip.destroy?.();
      } catch {
      }
      trigger.removeEventListener("click", rec.clickHide);
      if (rec.enter) trigger.removeEventListener("mouseenter", rec.enter);
      if (rec.leave) trigger.removeEventListener("mouseleave", rec.leave);
      if (rec.move) trigger.removeEventListener("mousemove", rec.move);
      if (rec.idleTimer != null)
        try {
          clearTimeout(rec.idleTimer);
        } catch {
        }
    });
    instances2.clear();
    detachDocClickHandler();
    detachObserver();
  };
  const hideInlinePanelsOnLg = () => {
    if (!lgMql.matches) return;
    document.querySelectorAll("[data-info-panel]:not(.hidden)").forEach((el) => el.classList.add("hidden"));
    document.querySelectorAll('[data-info-for][aria-expanded="true"]').forEach((btn) => btn.setAttribute("aria-expanded", "false"));
  };
  const updateMode = () => {
    const shouldEnable = hoverMql.matches && lgMql.matches;
    if (shouldEnable) enable();
    else disable();
    hideInlinePanelsOnLg();
  };
  const addMqlListener = (mql, handler) => {
    if (typeof mql.addEventListener === "function")
      mql.addEventListener("change", handler);
    else mql.addListener(handler);
  };
  const removeMqlListener = (mql, handler) => {
    if (typeof mql.removeEventListener === "function")
      mql.removeEventListener("change", handler);
    else mql.removeListener(handler);
  };
  const onHoverChange = () => updateMode();
  const onLgChange = () => updateMode();
  const start2 = () => {
    addMqlListener(hoverMql, onHoverChange);
    addMqlListener(lgMql, onLgChange);
    updateMode();
  };
  const stop = () => {
    disable();
    removeMqlListener(hoverMql, onHoverChange);
    removeMqlListener(lgMql, onLgChange);
  };
  return { start: start2, stop };
})();
function initMobileInfoButtons() {
  document.addEventListener(
    "click",
    (e) => {
      const target = e.target;
      const btn = target?.closest("[data-info-for]");
      if (!btn) return;
      const panel = ensureInfoPanelFor(btn);
      if (!panel) return;
      const expanded = btn.getAttribute("aria-expanded") === "true";
      btn.setAttribute("aria-expanded", String(!expanded));
      panel.classList.toggle("hidden", expanded);
    },
    true
  );
}
TooltipManager.start();
initMobileInfoButtons();
void Aurelia2.register(
  RouterConfiguration.customize({
    //title: "Betsy Bot Admin Panel",
    useUrlFragmentHash: false
  })
).register(Resources).register(Elements).app(App).start();
export {
  CustomElement as C,
  bindable as b,
  customElement as c,
  isBlankOrInvalid as i,
  syncParamsToUrl as s,
  watch as w
};
